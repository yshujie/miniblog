name: CI/CD (miniblog - production, linux runner)

# ============================================================================
# GitHub Secrets é…ç½®æŒ‡å¼•
# ----------------------------------------------------------------------------
# å¿…éœ€ï¼ˆmain push / workflow_dispatch æ‰å¼ºåˆ¶ï¼‰ï¼š
#   SVRB_HOST, SVRB_USER, SVRB_SSH_KEY, SVRB_SSH_PORT (å¯é€‰ï¼Œé»˜è®¤ 22)
#   MYSQL_HOST, MYSQL_DBNAME, MYSQL_USERNAME, MYSQL_PASSWORD, MYSQL_PORT (å¯é€‰)
#   REDIS_HOST, REDIS_PASSWORD, REDIS_PORT (å¯é€‰), REDIS_DB (å¯é€‰)
#   JWT_SECRET
#
# å¯é€‰ï¼š
#   ï¼ˆæ— ï¼‰
#   FEISHU_DOCREADER_APPID, FEISHU_DOCREADER_APPSECRET
#
# è¯´æ˜ï¼š
# - PR åªåš lint/testï¼Œä¸ç”¨è¿™äº› Secretsã€‚
# - main push / workflow_dispatch ç¼ºå¿…éœ€é¡¹ä¼šç›´æ¥å¤±è´¥ã€‚
# - éƒ¨ç½²åªé’ˆå¯¹ ServerBï¼ˆåº”ç”¨æœºï¼‰ï¼›è‹¥ nginx åœ¨ ServerAï¼Œå¯é…ç½® SVRA_* ä»¥åœ¨éƒ¨ç½²åè‡ªåŠ¨é‡è½½ nginxã€‚
# å¯é€‰ï¼ˆServerA nginx é‡è½½ï¼‰ï¼šSVRA_HOST, SVRA_USER, SVRA_SSH_KEY, SVRA_SSH_PORTï¼ˆé»˜è®¤ 22ï¼‰
# ============================================================================

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      skip_tests:
        description: "Skip tests"
        type: boolean
        default: false

permissions:
  contents: read
  packages: write

concurrency:
  group: miniblog-prod
  cancel-in-progress: false

env:
  GO_VERSION: "1.24"
  TAG: ${{ github.sha }}
  BACKEND_IMAGE: ghcr.io/${{ github.repository_owner }}/miniblog-backend
  FE_BLOG_IMAGE: ghcr.io/${{ github.repository_owner }}/miniblog-frontend-blog
  FE_ADMIN_IMAGE: ghcr.io/${{ github.repository_owner }}/miniblog-frontend-admin

jobs:
  validate-secrets:
    name: Validate Secrets
    runs-on: ubuntu-latest
    steps:
      - name: Check Required Secrets
        env:
          SVRB_HOST:           ${{ secrets.SVRB_HOST }}
          SVRB_USER:           ${{ secrets.SVRB_USER }}
          SVRB_SSH_KEY:        ${{ secrets.SVRB_SSH_KEY }}
          SVRB_SSH_PORT:       ${{ secrets.SVRB_SSH_PORT }}
          MYSQL_HOST:          ${{ secrets.MYSQL_HOST }}
          MYSQL_PORT:          ${{ secrets.MYSQL_PORT }}
          MYSQL_DBNAME:        ${{ secrets.MYSQL_DBNAME }}
          MYSQL_USERNAME:      ${{ secrets.MYSQL_USERNAME }}
          MYSQL_PASSWORD:      ${{ secrets.MYSQL_PASSWORD }}
          REDIS_HOST:          ${{ secrets.REDIS_HOST }}
          REDIS_PORT:          ${{ secrets.REDIS_PORT }}
          REDIS_DB:            ${{ secrets.REDIS_DB }}
          REDIS_PASSWORD:      ${{ secrets.REDIS_PASSWORD }}
          JWT_SECRET:          ${{ secrets.JWT_SECRET }}
          FEISHU_APPID:        ${{ secrets.FEISHU_DOCREADER_APPID }}
          FEISHU_SECRET:       ${{ secrets.FEISHU_DOCREADER_APPSECRET }}
        run: |
          echo "ğŸ” Validating required secrets (non-blocking)..."
          REQUIRED_APP=(SVRB_HOST SVRB_USER SVRB_SSH_KEY MYSQL_HOST MYSQL_DBNAME MYSQL_USERNAME MYSQL_PASSWORD REDIS_HOST REDIS_PASSWORD JWT_SECRET)
          OPTIONAL_APP=(SVRB_SSH_PORT MYSQL_PORT REDIS_PORT REDIS_DB FEISHU_APPID FEISHU_SECRET)
          FAILED=0
          ENFORCE=0

          if [ "${{ github.event_name }}" = "push" ] && [ "${{ github.ref }}" = "refs/heads/main" ]; then
            ENFORCE=1
            echo "ğŸ“‹ Enforcing required secrets for main push."
          elif [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            ENFORCE=1
            echo "ğŸ“‹ Enforcing required secrets for workflow_dispatch."
          else
            echo "â„¹ï¸ PR/other branches: reporting missing secrets as warnings."
          fi

          for k in "${REQUIRED_APP[@]}"; do
            v="${!k}"
            if [ -z "$v" ]; then
              if [ $ENFORCE -eq 1 ]; then
                echo "âŒ $k is not set"
                FAILED=1
              else
                echo "âš ï¸ $k is not set (required on deploy)"
              fi
            else
              echo "âœ… $k is set"
            fi
          done

          for k in "${OPTIONAL_APP[@]}"; do
            v="${!k}"
            if [ -z "$v" ]; then
              echo "âš ï¸ $k not set (optional)"
            else
              echo "âœ… $k is set"
            fi
          done

          echo
          if [ $FAILED -eq 1 ]; then
            if [ $ENFORCE -eq 1 ]; then
              echo "âŒ Secrets validation failed. Stop pipeline."
              exit 1
            fi
            echo "âš ï¸ Secrets validation failed, but continuing (non-blocking for PRs)."
          else
            echo "âœ… Secrets validation passed."
          fi

  test:
    name: Run Tests
    runs-on: ubuntu-latest
    if: ${{ github.event_name != 'workflow_dispatch' || inputs.skip_tests != true }}
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true
      - name: Download deps
        run: |
          go mod download
          go mod verify
      - name: Run unit tests
        run: |
          go test -v ./...

  lint:
    name: Lint (go vet)
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true
      - name: Run go vet
        run: |
          go vet ./...

  build-and-push:
    name: Build & Push Images (GHCR)
    runs-on: ubuntu-latest
    needs: [validate-secrets, lint, test]
    if: |
      always() &&
      (needs.test.result == 'success' || needs.test.result == 'skipped') &&
      (needs.lint.result == 'success' || needs.lint.result == 'skipped') &&
      (
        (github.event_name == 'push' && github.ref == 'refs/heads/main') ||
        github.event_name == 'workflow_dispatch'
      )
    strategy:
      matrix:
        include:
          - name: backend
            context: .
            file: build/docker/miniblog/Dockerfile.prod.backend
            build_args: |
              GOPROXY=https://goproxy.cn,direct
          - name: frontend-blog
            context: .
            file: build/docker/miniblog/Dockerfile.prod.frontend.blog
          - name: frontend-admin
            context: .
            file: build/docker/miniblog/Dockerfile.prod.frontend.admin
    steps:
      - uses: actions/checkout@v4

      - name: Pre-clean GHCR auth
        run: |
          docker logout ghcr.io || true
          rm -f ~/.docker/config.json || true

      - name: Login to GHCR with GITHUB_TOKEN
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build & Push ${{ matrix.name }}
        uses: docker/build-push-action@v6
        with:
          context: ${{ matrix.context }}
          file: ${{ matrix.file }}
          platforms: linux/amd64
          push: true
          build-args: ${{ matrix.build_args || '' }}
          tags: |
            ${{ matrix.name == 'backend' && env.BACKEND_IMAGE || matrix.name == 'frontend-blog' && env.FE_BLOG_IMAGE || env.FE_ADMIN_IMAGE }}:${{ env.TAG }}
            ${{ matrix.name == 'backend' && env.BACKEND_IMAGE || matrix.name == 'frontend-blog' && env.FE_BLOG_IMAGE || env.FE_ADMIN_IMAGE }}:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

  deploy-app:
    name: Deploy to ServerB (app)
    runs-on: ubuntu-latest
    needs: [build-and-push]
    if: |
      (github.event_name == 'push' && github.ref == 'refs/heads/main') ||
      github.event_name == 'workflow_dispatch'
    env:
      SVRA_HOST: ${{ secrets.SVRA_HOST }}
      SVRA_USER: ${{ secrets.SVRA_USER }}
      SVRA_SSH_KEY: ${{ secrets.SVRA_SSH_KEY }}
      SVRA_SSH_PORT: ${{ secrets.SVRA_SSH_PORT || 22 }}
    steps:
      - uses: actions/checkout@v4

      - name: Upload compose files
        uses: appleboy/scp-action@v0.1.7
        with:
          host:     ${{ secrets.SVRB_HOST }}
          username: ${{ secrets.SVRB_USER }}
          key:      ${{ secrets.SVRB_SSH_KEY }}
          port:     ${{ secrets.SVRB_SSH_PORT || 22 }}
          source:   "docker-compose.yml,docker-compose.prod.yml"
          target:   "/opt/miniblog"

      - name: Deploy on ServerB (docker compose)
        uses: appleboy/ssh-action@v1.0.0
        env:
          _IMG_BACKEND:     ${{ env.BACKEND_IMAGE }}:${{ env.TAG }}
          _IMG_FE_BLOG:     ${{ env.FE_BLOG_IMAGE }}:${{ env.TAG }}
          _IMG_FE_ADMIN:    ${{ env.FE_ADMIN_IMAGE }}:${{ env.TAG }}
          _GH_USER:         ${{ github.repository_owner }}
          _GHCR_USERNAME:   ${{ github.actor }}
          _GHCR_TOKEN:      ${{ secrets.GITHUB_TOKEN }}
          _MYSQL_HOST:      ${{ secrets.MYSQL_HOST }}
          _MYSQL_PORT:      ${{ secrets.MYSQL_PORT }}
          _MYSQL_DBNAME:    ${{ secrets.MYSQL_DBNAME }}
          _MYSQL_USERNAME:  ${{ secrets.MYSQL_USERNAME }}
          _MYSQL_PASSWORD:  ${{ secrets.MYSQL_PASSWORD }}
          _REDIS_HOST:      ${{ secrets.REDIS_HOST }}
          _REDIS_PORT:      ${{ secrets.REDIS_PORT }}
          _REDIS_DB:        ${{ secrets.REDIS_DB }}
          _REDIS_PASSWORD:  ${{ secrets.REDIS_PASSWORD }}
          _JWT_SECRET:      ${{ secrets.JWT_SECRET }}
          _FEISHU_APPID:    ${{ secrets.FEISHU_DOCREADER_APPID }}
          _FEISHU_SECRET:   ${{ secrets.FEISHU_DOCREADER_APPSECRET }}
        with:
          host:     ${{ secrets.SVRB_HOST }}
          username: ${{ secrets.SVRB_USER }}
          key:      ${{ secrets.SVRB_SSH_KEY }}
          port:     ${{ secrets.SVRB_SSH_PORT || 22 }}
          # å…³é”®ï¼šå°†ä¸Šé¢ env ä¸­çš„å˜é‡åä¼ é€’ç»™è¿œç«¯
          envs: >
            _IMG_BACKEND,_IMG_FE_BLOG,_IMG_FE_ADMIN,
            _GH_USER,_GHCR_USERNAME,_GHCR_TOKEN,
            _MYSQL_HOST,_MYSQL_PORT,_MYSQL_DBNAME,_MYSQL_USERNAME,_MYSQL_PASSWORD,
            _REDIS_HOST,_REDIS_PORT,_REDIS_DB,_REDIS_PASSWORD,
            _JWT_SECRET,_FEISHU_APPID,_FEISHU_SECRET
          script_stop: true
          script: |
            set -euo pipefail
            cd /opt/miniblog

            cat > .env <<EOF
            BACKEND_IMAGE_TAG=${_IMG_BACKEND}
            FRONTEND_BLOG_IMAGE_TAG=${_IMG_FE_BLOG}
            FRONTEND_ADMIN_IMAGE_TAG=${_IMG_FE_ADMIN}

            GIN_MODE=release

            MYSQL_HOST=${_MYSQL_HOST}
            MYSQL_PORT=${_MYSQL_PORT}
            MYSQL_DATABASE=${_MYSQL_DBNAME}
            MYSQL_USERNAME=${_MYSQL_USERNAME}
            MYSQL_PASSWORD=${_MYSQL_PASSWORD}

            REDIS_HOST=${_REDIS_HOST}
            REDIS_PORT=${_REDIS_PORT}
            REDIS_DB=${_REDIS_DB}
            REDIS_PASSWORD=${_REDIS_PASSWORD}

            JWT_SECRET=${_JWT_SECRET}

            FEISHU_DOCREADER_APPID=${_FEISHU_APPID}
            FEISHU_DOCREADER_APPSECRET=${_FEISHU_SECRET}
            EOF
            sudo chmod 600 .env

            # åˆ›å»ºä¸šåŠ¡ç½‘ç»œï¼ˆminiblogï¼‰ï¼Œinfra-network ç”±åŸºç¡€è®¾æ–½é¢„åˆ›å»º
            sudo docker network inspect miniblog-network >/dev/null 2>&1 || sudo docker network create miniblog-network
            if ! sudo docker network inspect infra-network >/dev/null 2>&1; then
              echo "âš ï¸ infra-network ä¸å­˜åœ¨ï¼Œè¯·å…ˆåœ¨åŸºç¡€è®¾æ–½ä¾§åˆ›å»ºï¼ˆoverlay/attachableï¼‰"
              exit 1
            fi
            sudo mkdir -p /data/logs/miniblog/backend /data/logs/miniblog/frontend-blog /data/logs/miniblog/frontend-admin

            # ä½¿ç”¨ GITHUB_TOKEN ç™»å½• GHCRï¼ˆä»“åº“å†…ç§æœ‰é•œåƒå¯æ‹‰å–ï¼‰
            if [ -n "${_GHCR_TOKEN}" ]; then
              DOCKER_USER="${_GHCR_USERNAME:-${_GH_USER}}"
              echo "${_GHCR_TOKEN}" | sudo docker login ghcr.io -u "${DOCKER_USER}" --password-stdin
            fi

            sudo docker compose -f docker-compose.yml -f docker-compose.prod.yml pull
            sudo docker compose -f docker-compose.yml -f docker-compose.prod.yml up -d

            # ç­‰å¾…åç«¯å°±ç»ªï¼ˆä¾¿äº ServerA ä¸Š nginx é‡è½½åèƒ½è¿åˆ°æ–°å®ä¾‹ï¼‰
            echo "Waiting for backend health (up to 60s)..."
            for i in $(seq 1 30); do
              if sudo docker exec miniblog-backend wget --spider -q http://localhost:8080/health 2>/dev/null; then
                echo "Backend healthy after $((i*2))s"
                break
              fi
              sleep 2
            done

            sudo docker compose ps

      - name: Reload nginx on ServerA
        if: env.SVRA_HOST != ''
        uses: appleboy/ssh-action@v1.0.0
        with:
          host:     ${{ env.SVRA_HOST }}
          username: ${{ env.SVRA_USER }}
          key:      ${{ env.SVRA_SSH_KEY }}
          port:     ${{ env.SVRA_SSH_PORT }}
          script_stop: true
          script: |
            set -euo pipefail
            # é‡è½½ nginxï¼Œä½¿ upstream æŒ‡å‘ ServerB çš„æ–°å®ä¾‹ï¼ˆé¿å… keepalive è¿åˆ°æ—§è¿æ¥ï¼‰
            # ServerA ä¸Š nginx åœ¨ Docker ä¸­ï¼ŒSSH ç”¨æˆ·é€šå¸¸éœ€ sudo æ‰èƒ½æ‰§è¡Œ docker
            if command -v docker >/dev/null 2>&1; then
              if sudo docker exec nginx nginx -t 2>/dev/null; then
                sudo docker exec nginx nginx -s reload
                echo "Nginx reloaded on ServerA (Docker)."
                exit 0
              fi
              if docker exec nginx nginx -t 2>/dev/null; then
                docker exec nginx nginx -s reload
                echo "Nginx reloaded on ServerA (Docker, no sudo)."
                exit 0
              fi
            fi
            if sudo systemctl is-active -q nginx 2>/dev/null && sudo nginx -t 2>/dev/null; then
              sudo systemctl reload nginx
              echo "Nginx reloaded on ServerA (systemd)."
              exit 0
            fi
            echo "âš ï¸ Nginx not found: docker exec nginx æˆ– systemctl nginx å‡å¤±è´¥ï¼Œè¯·æ£€æŸ¥å®¹å™¨åä¸ sudo æƒé™ã€‚"
            exit 1

  notify:
    name: Send Notification
    needs: [deploy-app]
    runs-on: ubuntu-latest
    if: |
      always() &&
      (
        (github.event_name == 'push' && github.ref == 'refs/heads/main') ||
        github.event_name == 'workflow_dispatch'
      )
    steps:
      - name: Log deployment status
        run: |
          APP_STATUS="${{ needs.deploy-app.result }}"

          echo "App deploy: $APP_STATUS"

          if [ "$APP_STATUS" = "success" ]; then
            echo "âœ… Deployment to production succeeded"
          elif [ "$APP_STATUS" = "skipped" ]; then
            echo "â„¹ï¸ App deployment skipped (non-main push)"
          else
            echo "âŒ Deployment failed"
            exit 1
          fi
