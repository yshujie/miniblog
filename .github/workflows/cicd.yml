name: CI/CD (miniblog)

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      skip_tests:
        description: 'Skip unit tests'
        type: boolean
        default: false
      skip_db_init:
        description: 'Skip database initialization'
        type: boolean
        default: true
      skip_db_migrate:
        description: 'Skip database migration'
        type: boolean
        default: true
      skip_db_seed:
        description: 'Skip database seed data'
        type: boolean
        default: true

permissions:
  contents: read
  packages: write

env:
  BACKEND_IMAGE: ghcr.io/${{ github.repository_owner }}/miniblog-backend
  FE_BLOG_IMAGE: ghcr.io/${{ github.repository_owner }}/miniblog-frontend-blog
  FE_ADMIN_IMAGE: ghcr.io/${{ github.repository_owner }}/miniblog-frontend-admin
  TAG: ${{ github.sha }}

concurrency:
  group: miniblog-prod
  cancel-in-progress: false

jobs:
  # 单元测试阶段
  test:
    if: ${{ !inputs.skip_tests }}
    runs-on: [self-hosted, macmini, prod]
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.24'
          cache: true
          cache-dependency-path: |
            go.sum
            go.work.sum
      
      - name: Cache Go build
        uses: actions/cache@v4
        with:
          path: |
            ~/.cache/go-build
            ~/go/pkg/mod
          key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum', '**/go.work.sum') }}
          restore-keys: |
            ${{ runner.os }}-go-
      
      - name: Download dependencies
        run: go mod download
      
      - name: Run unit tests
        run: make test-backend

  build-and-push:
    needs: [test]
    if: ${{ !cancelled() && (success() || inputs.skip_tests) }}
    runs-on: [self-hosted, macmini, prod]

    steps:
      - uses: actions/checkout@v4

      - name: Setup Docker config directory
        run: |
          DOCKER_CONFIG_DIR="${{ runner.temp }}/.docker"
          mkdir -p "$DOCKER_CONFIG_DIR"
          # 禁用 credsStore，避免使用 macOS Keychain
          echo '{"auths":{},"credsStore":""}' > "$DOCKER_CONFIG_DIR/config.json"
          echo "DOCKER_CONFIG=$DOCKER_CONFIG_DIR" >> $GITHUB_ENV
          echo "Docker config directory: $DOCKER_CONFIG_DIR"

      - uses: docker/setup-qemu-action@v3
      
      - uses: docker/setup-buildx-action@v3
        with:
          driver-opts: |
            env.DOCKER_CONFIG=${{ runner.temp }}/.docker

      - name: Login to GHCR
        run: |
          echo "${{ secrets.GHCR_TOKEN }}" | docker --config="${{ runner.temp }}/.docker" login ghcr.io -u "${{ github.repository_owner }}" --password-stdin

      # === Backend ===
      - name: Build & Push backend (linux/amd64)
        uses: docker/build-push-action@v6
        with:
          context: .
          file: build/docker/miniblog/Dockerfile.prod.backend
          platforms: linux/amd64
          push: true
          # 使用 GitHub Actions 缓存（最稳定）
          cache-from: type=gha,scope=backend
          cache-to: type=gha,mode=max,scope=backend
          # 构建参数：启用 Go 模块和构建缓存
          build-args: |
            GOPROXY=https://goproxy.cn,direct
          tags: |
            ${{ env.BACKEND_IMAGE }}:${{ env.TAG }}
            ${{ env.BACKEND_IMAGE }}:latest

      # === Frontend Blog（两种路径，命中其一即可） ===
      - name: Build & Push frontend-blog (web path)
        if: ${{ hashFiles('web/miniblog-web/Dockerfile.prod.frontend.blog') != '' }}
        uses: docker/build-push-action@v6
        with:
          context: ./web/miniblog-web
          file: ./web/miniblog-web/Dockerfile.prod.frontend.blog
          platforms: linux/amd64
          push: true
          cache-from: type=gha,scope=fe-blog
          cache-to: type=gha,mode=max,scope=fe-blog
          tags: |
            ${{ env.FE_BLOG_IMAGE }}:${{ env.TAG }}
            ${{ env.FE_BLOG_IMAGE }}:latest

      - name: Build & Push frontend-blog (build/docker path)
        if: ${{ hashFiles('build/docker/miniblog/Dockerfile.prod.frontend.blog') != '' }}
        uses: docker/build-push-action@v6
        with:
          context: .
          file: build/docker/miniblog/Dockerfile.prod.frontend.blog
          platforms: linux/amd64
          push: true
          cache-from: type=gha,scope=fe-blog
          cache-to: type=gha,mode=max,scope=fe-blog
          tags: |
            ${{ env.FE_BLOG_IMAGE }}:${{ env.TAG }}
            ${{ env.FE_BLOG_IMAGE }}:latest

      # === Frontend Admin（同理两种路径） ===
      - name: Build & Push frontend-admin (web path)
        if: ${{ hashFiles('web/miniblog-web-admin/Dockerfile.prod.frontend.admin') != '' }}
        uses: docker/build-push-action@v6
        with:
          context: ./web/miniblog-web-admin
          file: ./web/miniblog-web-admin/Dockerfile.prod.frontend.admin
          platforms: linux/amd64
          push: true
          cache-from: type=gha,scope=fe-admin
          cache-to: type=gha,mode=max,scope=fe-admin
          tags: |
            ${{ env.FE_ADMIN_IMAGE }}:${{ env.TAG }}
            ${{ env.FE_ADMIN_IMAGE }}:latest

      - name: Build & Push frontend-admin (build/docker path)
        if: ${{ hashFiles('build/docker/miniblog/Dockerfile.prod.frontend.admin') != '' }}
        uses: docker/build-push-action@v6
        with:
          context: .
          file: build/docker/miniblog/Dockerfile.prod.frontend.admin
          platforms: linux/amd64
          push: true
          cache-from: type=gha,scope=fe-admin
          cache-to: type=gha,mode=max,scope=fe-admin
          tags: |
            ${{ env.FE_ADMIN_IMAGE }}:${{ env.TAG }}
            ${{ env.FE_ADMIN_IMAGE }}:latest

  deploy:
    # 同上：若有 macmini/prod 标签，改成 [self-hosted, macmini, prod]
    runs-on: [self-hosted, macOS, ARM64]
    needs: build-and-push
    environment: production
    timeout-minutes: 30
    # DOCKER_CONFIG 这步对 deploy job 不是必须（docker 命令在远端服务器上执行），留空也行
    steps:
      - uses: actions/checkout@v4

      - name: Deploy to Server A via SSH
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SVRA_HOST }}
          username: ${{ secrets.SVRA_USER }}
          key: ${{ secrets.SVRA_SSH_KEY }}
          script_stop: true
          script: |
            set -euo pipefail

            # 1) 预置网络/目录（幂等）
            docker network inspect miniblog_net >/dev/null 2>&1 || docker network create miniblog_net
            sudo mkdir -p /opt/miniblog /data/logs/miniblog/{backend,frontend-blog,frontend-admin}
            cd /opt/miniblog

            # 2) 拉代码（要求服务器已配置 Deploy Key：Host github-miniblog）
            if [ -d .git ]; then
              git fetch --all -p && git reset --hard origin/main
            else
              git clone github-miniblog:${{ github.repository }} .
            fi

            # 3) 登录 GHCR（拉镜像）
            echo "${{ secrets.GHCR_TOKEN }}" | docker login ghcr.io -u "${{ github.repository_owner }}" --password-stdin

            # 4) 写入 .env（用带引号的 heredoc 防止远端 shell 展开）
            cat > .env <<'EOF'
            BACKEND_IMAGE_TAG=${{ env.BACKEND_IMAGE }}:${{ env.TAG }}
            FRONTEND_BLOG_IMAGE_TAG=${{ env.FE_BLOG_IMAGE }}:${{ env.TAG }}
            FRONTEND_ADMIN_IMAGE_TAG=${{ env.FE_ADMIN_IMAGE }}:${{ env.TAG }}

            GIN_MODE=release

            MYSQL_HOST=${{ secrets.MYSQL_HOST }}
            MYSQL_PORT=${{ secrets.MYSQL_PORT }}
            MYSQL_DATABASE=${{ secrets.MYSQL_DBNAME }}
            MYSQL_USERNAME=${{ secrets.MYSQL_USERNAME }}
            MYSQL_PASSWORD=${{ secrets.MYSQL_PASSWORD }}

            REDIS_HOST=${{ secrets.REDIS_HOST }}
            REDIS_PORT=${{ secrets.REDIS_PORT }}
            REDIS_DB=${{ secrets.REDIS_DB }}
            REDIS_PASSWORD=${{ secrets.REDIS_PASSWORD }}

            JWT_SECRET=${{ secrets.JWT_SECRET }}

            FEISHU_DOCREADER_APPID=${{ secrets.FEISHU_DOCREADER_APPID }}
            FEISHU_DOCREADER_APPSECRET=${{ secrets.FEISHU_DOCREADER_APPSECRET }}
            EOF

            # 5) 拉取并无停机更新（生产覆盖文件固定 8090 端口）
            docker compose -f docker-compose.yml -f docker-compose.prod.yml pull
            docker compose -f docker-compose.yml -f docker-compose.prod.yml up -d

            # 6) 健康检查 + 简要状态
            sleep 2
            (curl -fsS http://127.0.0.1:8090/health && echo " HEALTH=OK") || (echo "HEALTH=FAIL"; exit 1)
            docker ps --format 'table {{.Names}}\t{{.Image}}\t{{.Status}}'

      # 数据库初始化（仅首次部署时需要）
      - name: DB Init
        if: ${{ !inputs.skip_db_init }}
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SVRA_HOST }}
          username: ${{ secrets.SVRA_USER }}
          key: ${{ secrets.SVRA_SSH_KEY }}
          script_stop: true
          script: |
            set -euo pipefail
            cd /opt/miniblog
            
            # 从 .env 加载环境变量
            export $(cat .env | grep -v '^#' | xargs)
            export DB_ROOT_PASSWORD="${{ secrets.MYSQL_ROOT_PASSWORD }}"
            export ENABLE_DB_INIT=true
            
            ./scripts/db-init.sh

      # 数据库迁移
      - name: DB Migrate
        if: ${{ !inputs.skip_db_migrate }}
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SVRA_HOST }}
          username: ${{ secrets.SVRA_USER }}
          key: ${{ secrets.SVRA_SSH_KEY }}
          script_stop: true
          script: |
            set -euo pipefail
            cd /opt/miniblog
            
            # 从 .env 加载环境变量
            export $(cat .env | grep -v '^#' | xargs)
            
            ./scripts/db-migrate.sh

      # 数据库种子数据
      - name: DB Seed
        if: ${{ !inputs.skip_db_seed }}
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SVRA_HOST }}
          username: ${{ secrets.SVRA_USER }}
          key: ${{ secrets.SVRA_SSH_KEY }}
          script_stop: true
          script: |
            set -euo pipefail
            cd /opt/miniblog
            
            # 从 .env 加载环境变量
            export $(cat .env | grep -v '^#' | xargs)
            export ENABLE_DB_SEED=true
            
            make db-seed
