name: CI/CD (miniblog)

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      skip_tests:
        description: 'Skip unit tests'
        type: boolean
        default: false

permissions:
  contents: read
  packages: write

env:
  BACKEND_IMAGE: ghcr.io/${{ github.repository_owner }}/miniblog-backend
  FE_BLOG_IMAGE: ghcr.io/${{ github.repository_owner }}/miniblog-frontend-blog
  FE_ADMIN_IMAGE: ghcr.io/${{ github.repository_owner }}/miniblog-frontend-admin
  TAG: ${{ github.sha }}

concurrency:
  group: miniblog-prod
  cancel-in-progress: false

jobs:
  test:
    if: ${{ !inputs.skip_tests }}
    runs-on: [self-hosted, macOS, ARM64]
    steps:
      - uses: actions/checkout@v4

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.24'
          cache: true
          cache-dependency-path: |
            go.sum
            go.work.sum

      - name: Fix Go module cache permissions (best-effort)
        run: |
          [ -d "$HOME/go/pkg/mod" ] && chmod -R u+w "$HOME/go/pkg/mod" || true

      - name: Download dependencies
        run: go mod download

      - name: Run unit tests
        run: make test-backend

  build-and-push:
    needs: [test]
    if: ${{ !cancelled() && (success() || inputs.skip_tests) }}
    runs-on: [self-hosted, macOS, ARM64]
    steps:
      - uses: actions/checkout@v4

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GHCR_TOKEN || github.token }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build & Push backend
        uses: docker/build-push-action@v5
        with:
          context: .
          file: build/docker/miniblog/Dockerfile.prod.backend
          platforms: linux/amd64
          push: true
          tags: |
            ${{ env.BACKEND_IMAGE }}:${{ env.TAG }}
            ${{ env.BACKEND_IMAGE }}:latest
          build-args: |
            GOPROXY=https://goproxy.cn,direct

      - name: Build & Push frontend-blog
        uses: docker/build-push-action@v5
        with:
          context: .
          file: build/docker/miniblog/Dockerfile.prod.frontend.blog
          platforms: linux/amd64
          push: true
          tags: |
            ${{ env.FE_BLOG_IMAGE }}:${{ env.TAG }}
            ${{ env.FE_BLOG_IMAGE }}:latest

      - name: Build & Push frontend-admin
        uses: docker/build-push-action@v5
        with:
          context: .
          file: build/docker/miniblog/Dockerfile.prod.frontend.admin
          platforms: linux/amd64
          push: true
          tags: |
            ${{ env.FE_ADMIN_IMAGE }}:${{ env.TAG }}
            ${{ env.FE_ADMIN_IMAGE }}:latest

  deploy:
    runs-on: [self-hosted, macOS, ARM64]
    needs: build-and-push
    environment: production
    timeout-minutes: 20
    steps:
      - uses: actions/checkout@v4

      - name: Prepare SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SVRA_SSH_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ secrets.SVRA_HOST }} >> ~/.ssh/known_hosts 2>/dev/null || true

      - name: Ensure remote dir & ownership
        run: |
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no ${{ secrets.SVRA_USER }}@${{ secrets.SVRA_HOST }} \
            "sudo mkdir -p /opt/miniblog && sudo chown $(id -un):$(id -gn) /opt/miniblog"

      - name: Upload compose files
        run: |
          scp -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no \
            docker-compose.yml docker-compose.prod.yml \
            ${{ secrets.SVRA_USER }}@${{ secrets.SVRA_HOST }}:/opt/miniblog/

      - name: Deploy (docker login + compose pull/up)
        env:
          # 远端拉取 GHCR 的 token：优先使用专门的只读 PAT；无则退回 GHCR_TOKEN；再无则用 GITHUB_TOKEN（短时有效）
          GHCR_PULL_TOKEN: ${{ secrets.SVRA_GHCR_PULL_TOKEN || secrets.GHCR_TOKEN || github.token }}
          GHCR_USER: ${{ github.repository_owner }}
          BACKEND_IMAGE: ${{ env.BACKEND_IMAGE }}
          FE_BLOG_IMAGE: ${{ env.FE_BLOG_IMAGE }}
          FE_ADMIN_IMAGE: ${{ env.FE_ADMIN_IMAGE }}
          TAG: ${{ env.TAG }}
          # 应用运行所需的机密
          MYSQL_HOST: ${{ secrets.MYSQL_HOST }}
          MYSQL_PORT: ${{ secrets.MYSQL_PORT }}
          MYSQL_DBNAME: ${{ secrets.MYSQL_DBNAME }}
          MYSQL_USERNAME: ${{ secrets.MYSQL_USERNAME }}
          MYSQL_PASSWORD: ${{ secrets.MYSQL_PASSWORD }}
          REDIS_HOST: ${{ secrets.REDIS_HOST }}
          REDIS_PORT: ${{ secrets.REDIS_PORT }}
          REDIS_DB: ${{ secrets.REDIS_DB }}
          REDIS_PASSWORD: ${{ secrets.REDIS_PASSWORD }}
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
          FEISHU_DOCREADER_APPID: ${{ secrets.FEISHU_DOCREADER_APPID }}
          FEISHU_DOCREADER_APPSECRET: ${{ secrets.FEISHU_DOCREADER_APPSECRET }}
          # 健康检查（可按需调整）
          HEALTH_URL: http://127.0.0.1:8090/health
        run: |
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no ${{ secrets.SVRA_USER }}@${{ secrets.SVRA_HOST }} 'bash -seu -o pipefail << "EOF"
          APP_DIR=/opt/miniblog

          # 1) 预检 docker / compose
          sudo -n docker version >/dev/null
          sudo -n docker compose version >/dev/null

          # 2) 写 .env（把发布镜像 tag 注入）
          cat > "$APP_DIR/.env" <<ENV
          BACKEND_IMAGE_TAG=${BACKEND_IMAGE}:${TAG}
          FRONTEND_BLOG_IMAGE_TAG=${FE_BLOG_IMAGE}:${TAG}
          FRONTEND_ADMIN_IMAGE_TAG=${FE_ADMIN_IMAGE}:${TAG}

          GIN_MODE=release

          MYSQL_HOST=${MYSQL_HOST}
          MYSQL_PORT=${MYSQL_PORT}
          MYSQL_DATABASE=${MYSQL_DBNAME}
          MYSQL_USERNAME=${MYSQL_USERNAME}
          MYSQL_PASSWORD=${MYSQL_PASSWORD}

          REDIS_HOST=${REDIS_HOST}
          REDIS_PORT=${REDIS_PORT}
          REDIS_DB=${REDIS_DB}
          REDIS_PASSWORD=${REDIS_PASSWORD}

          JWT_SECRET=${JWT_SECRET}

          FEISHU_DOCREADER_APPID=${FEISHU_DOCREADER_APPID}
          FEISHU_DOCREADER_APPSECRET=${FEISHU_DOCREADER_APPSECRET}
          ENV

          # 3) 登录 GHCR（stdin，不依赖 DOCKER_AUTH_CONFIG）
          echo "${GHCR_PULL_TOKEN}" | sudo -n docker login ghcr.io -u "${GHCR_USER}" --password-stdin >/dev/null 2>&1

          # 4) 拉取并启动
          cd "$APP_DIR"
          sudo -n docker compose -f docker-compose.yml -f docker-compose.prod.yml pull
          sudo -n docker compose -f docker-compose.yml -f docker-compose.prod.yml up -d

          # 5) 简单健康检查（30s）
          for i in $(seq 1 15); do
            if curl -fsS "${HEALTH_URL}" >/dev/null 2>&1; then
              echo "Health OK"; break
            fi
            sleep 2
            [ "$i" -eq 15 ] && { echo "HEALTH=FAIL"; exit 1; }
          done

          # 6) 展示运行状态
          sudo -n docker ps --format "table {{.Names}}\t{{.Image}}\t{{.Status}}"
          EOF'

      - name: Cleanup SSH Key
        if: always()
        run: rm -f ~/.ssh/deploy_key
