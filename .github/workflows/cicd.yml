name: CI/CD

on:
  push:
    branches: [ main ]
  workflow_dispatch:

# å…è®¸æ¨é€ GHCR
permissions:
  contents: read
  packages: write

concurrency:
  group: cicd-${{ github.ref }}
  cancel-in-progress: false

env:
  # é•œåƒåï¼ˆæŒ‰ä½ çš„ä»“åº“æ”¹ï¼‰
  BACKEND_IMAGE: ghcr.io/yshujie/miniblog-backend
  FE_BLOG_IMAGE: ghcr.io/yshujie/miniblog-frontend-blog
  FE_ADMIN_IMAGE: ghcr.io/yshujie/miniblog-frontend-admin
  TAG: ${{ github.sha }}

jobs:
  build-and-push:
    # ä½ çš„è‡ªæ‰˜ç®¡æœºå™¨ï¼ˆmacOSï¼‰
    runs-on: self-hosted

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Use ephemeral DOCKER_CONFIG (no credsStore, no keychain)
        shell: bash
        run: |
          set -euo pipefail
          export DOCKER_CONFIG="$RUNNER_TEMP/.docker"
          mkdir -p "$DOCKER_CONFIG"
          # ç»ä¸å†™ credsStoreï¼Œé¿å… macOS é’¥åŒ™ä¸²
          cat > "$DOCKER_CONFIG/config.json" <<'JSON'
          { "auths": { "https://index.docker.io/v1/": {} } }
          JSON
          echo "DOCKER_CONFIG=$DOCKER_CONFIG" >> "$GITHUB_ENV"
          echo "ğŸ”’ Using ephemeral DOCKER_CONFIG=$DOCKER_CONFIG (no credsStore)"

      - name: Expose docker-buildx into ephemeral cli-plugins
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p "$DOCKER_CONFIG/cli-plugins"
          if [ -x /Applications/Docker.app/Contents/Resources/cli-plugins/docker-buildx ]; then
            SRC=/Applications/Docker.app/Contents/Resources/cli-plugins/docker-buildx
          elif [ -x "$HOME/.docker/cli-plugins/docker-buildx" ]; then
            SRC="$HOME/.docker/cli-plugins/docker-buildx"
          elif command -v docker-buildx >/dev/null 2>&1; then
            SRC="$(command -v docker-buildx)"
          else
            echo "ERROR: docker-buildx binary not found on this runner" >&2
            exit 1
          fi
          ln -sf "$SRC" "$DOCKER_CONFIG/cli-plugins/docker-buildx"
          docker buildx version

      - name: Prepare GHCR auth (prefer GHCR_TOKEN, fallback GITHUB_TOKEN)
        shell: bash
        env:
          GHCR_TOKEN: ${{ secrets.GHCR_TOKEN }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          USER="${{ github.actor }}"
          TOKEN="${GHCR_TOKEN:-}"
          if [ -z "$TOKEN" ]; then
            TOKEN="${GITHUB_TOKEN:-}"
          fi
          if [ -z "$TOKEN" ]; then
            echo "ERROR: Neither GHCR_TOKEN nor GITHUB_TOKEN available." >&2
            exit 1
          fi
          AUTH=$(printf "%s:%s" "$USER" "$TOKEN" | base64 | tr -d '\n')
          # ä»…å†…è”åˆ°ç¯å¢ƒï¼Œä¸è°ƒç”¨ docker loginï¼ˆå½»åº•ç»•å¼€é’¥åŒ™ä¸²ï¼‰
          echo 'DOCKER_AUTH_CONFIG={"auths":{"ghcr.io":{"auth":"'"$AUTH"'"}}}' >> "$GITHUB_ENV"
          echo "âœ… DOCKER_AUTH_CONFIG ready (inline, no keychain)"

      - name: Create a clean buildx builder bound to this DOCKER_CONFIG
        shell: bash
        run: |
          set -euo pipefail
          # è‹¥å­˜åœ¨æ—§ builderï¼Œå…ˆåˆ ï¼›ä¸å­˜åœ¨å°±å®‰é™è·³è¿‡
          docker buildx inspect miniblog-builder >/dev/null 2>&1 && docker buildx rm -f miniblog-builder || true
          docker buildx create --name miniblog-builder --driver docker-container --use \
            --driver-opt env.DOCKER_CONFIG="$DOCKER_CONFIG"
          docker buildx inspect --bootstrap
          docker buildx ls

      # ===== åç«¯é•œåƒ =====
      - name: Build & Push backend
        shell: bash
        run: |
          set -euo pipefail
          docker buildx build \
            --platform linux/amd64 \
            --file build/docker/miniblog/Dockerfile.prod.backend \
            --build-arg GOPROXY=https://goproxy.cn,direct \
            --tag ${BACKEND_IMAGE}:${TAG} \
            --tag ${BACKEND_IMAGE}:latest \
            --push \
            .

      # ===== å‰ç«¯é•œåƒï¼ˆå¦‚æš‚æ—¶æ²¡æœ‰ç›¸åº” Dockerfileï¼Œå¯æ³¨é‡Šè¿™ä¸¤æ®µï¼‰=====
      - name: Build & Push frontend (blog)
        if: ${{ always() }}
        shell: bash
        run: |
          set -euo pipefail
          if [ -f build/docker/miniblog/Dockerfile.prod.frontend.blog ]; then
            docker buildx build \
              --platform linux/amd64 \
              --file build/docker/miniblog/Dockerfile.prod.frontend.blog \
              --tag ${FE_BLOG_IMAGE}:${TAG} \
              --tag ${FE_BLOG_IMAGE}:latest \
              --push \
              .
          else
            echo "Skip blog FE build: Dockerfile not found."
          fi

      - name: Build & Push frontend (admin)
        if: ${{ always() }}
        shell: bash
        run: |
          set -euo pipefail
          if [ -f build/docker/miniblog/Dockerfile.prod.frontend.admin ]; then
            docker buildx build \
              --platform linux/amd64 \
              --file build/docker/miniblog/Dockerfile.prod.frontend.admin \
              --tag ${FE_ADMIN_IMAGE}:${TAG} \
              --tag ${FE_ADMIN_IMAGE}:latest \
              --push \
              .
          else
            echo "Skip admin FE build: Dockerfile not found."
          fi

  deploy:
    needs: build-and-push
    runs-on: self-hosted

    steps:
      - name: Checkout (for compose files used on server)
        uses: actions/checkout@v4

      - name: Write SSH key
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p ~/.ssh
          echo "${{ secrets.SVRA_SSH_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          # ä¿¡ä»»ä¸€æ¬¡ä¸»æœºæŒ‡çº¹
          ssh-keyscan -H "${{ secrets.SVRA_HOST }}" >> ~/.ssh/known_hosts 2>/dev/null || true

      - name: Preflight check on remote user (shell & docker group)
        shell: bash
        run: |
          set -euo pipefail
          SSH_USER="${{ secrets.SVRA_USER }}"
          SSH_HOST="${{ secrets.SVRA_HOST }}"
          KEY=~/.ssh/deploy_key

          # æ£€æŸ¥ç™»å½• shell
          SHELL_PATH=$(ssh -F /dev/null -i "$KEY" -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
            "$SSH_USER@$SSH_HOST" 'getent passwd "$USER" | cut -d: -f7 || true')
          echo "Remote user shell: ${SHELL_PATH:-<empty>}"
          if [ -z "$SHELL_PATH" ] || [ "$SHELL_PATH" = "/usr/sbin/nologin" ] || [ "$SHELL_PATH" = "/bin/false" ]; then
            echo "::error::Remote user ($SSH_USER) cannot start a login shell ($SHELL_PATH). Please change it to /bin/bash or /bin/sh, or use another user." >&2
            exit 1
          fi

          # å‹æƒ…æç¤ºæ˜¯å¦åœ¨ docker ç»„
          ssh -F /dev/null -i "$KEY" -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
            "$SSH_USER@$SSH_HOST" 'id -nG | tr " " "\n" | grep -qx docker || echo "::warning::User not in docker group; docker may require sudo."'

      - name: Deploy over SSH
        shell: bash
        env:
          # é•œåƒæ ‡ç­¾å†™å…¥ .env
          BACKEND_IMAGE: ${{ env.BACKEND_IMAGE }}
          FE_BLOG_IMAGE: ${{ env.FE_BLOG_IMAGE }}
          FE_ADMIN_IMAGE: ${{ env.FE_ADMIN_IMAGE }}
          TAG: ${{ env.TAG }}
          # å¯é€‰ï¼šæœåŠ¡å™¨æ‹‰ç§æœ‰ GHCR çš„åªè¯»å‡­è¯
          SVRA_GHCR_USER: ${{ secrets.SVRA_GHCR_USER }}
          SVRA_GHCR_TOKEN: ${{ secrets.SVRA_GHCR_TOKEN }}
        run: |
          set -euo pipefail
          SSH_USER="${{ secrets.SVRA_USER }}"
          SSH_HOST="${{ secrets.SVRA_HOST }}"
          KEY=~/.ssh/deploy_key

          ssh -F /dev/null -i "$KEY" -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
            "$SSH_USER@$SSH_HOST" 'bash -s' <<'ENDSSH'
          set -euo pipefail

          # æœåŠ¡å™¨ä¾§åŒæ ·ä½¿ç”¨ä¸´æ—¶ DOCKER_CONFIGï¼Œå½»åº•æœç»ä»»ä½• keychain/credHelper
          export DOCKER_CONFIG="$(mktemp -d)"
          printf '{}' > "$DOCKER_CONFIG/config.json"

          # è‹¥æä¾›äº† GHCR åªè¯»å‡­è¯ï¼Œåˆ™å†…è”åˆ° DOCKER_AUTH_CONFIGï¼ˆç”¨äº docker compose pullï¼‰
          if [ -n "${SVRA_GHCR_USER:-}" ] && [ -n "${SVRA_GHCR_TOKEN:-}" ]; then
            AUTH=$(printf "%s:%s" "$SVRA_GHCR_USER" "$SVRA_GHCR_TOKEN" | base64 | tr -d '\n')
            export DOCKER_AUTH_CONFIG='{"auths":{"ghcr.io":{"auth":"'"$AUTH"'"}}}'
          fi

          # é€‰æ‹© docker å‘½ä»¤ï¼ˆè‹¥æ— æƒé™ï¼Œå°è¯• sudoï¼‰
          if docker ps >/dev/null 2>&1; then
            DOCKER="docker"
          elif sudo -n docker ps >/dev/null 2>&1; then
            DOCKER="sudo docker"
          else
            echo "ERROR: docker not usable (neither user nor sudo)." >&2
            exit 1
          fi

          # ç¡®ä¿éƒ¨ç½²ç›®å½• & æ—¥å¿—ç›®å½•
          APP_DIR="/opt/miniblog"
          LOG_DIR="/data/logs/miniblog"
          if ! mkdir -p "$APP_DIR" "$LOG_DIR"/{backend,frontend-blog,frontend-admin} 2>/dev/null; then
            sudo -n mkdir -p "$APP_DIR" "$LOG_DIR"/{backend,frontend-blog,frontend-admin}
          fi
          cd "$APP_DIR"

          # æ‹‰å–ä»“åº“ï¼ˆè‹¥æœåŠ¡å™¨ç›´æ¥ä»æœ¬ä»“åº“æ‹‰ compose æ–‡ä»¶ï¼‰
          if [ -d .git ]; then
            git fetch --all -p && git reset --hard origin/main
          else
            # å…¬æœ‰ä»“åº“å¯ç›´æ¥ cloneï¼›è‹¥ç§æœ‰ï¼Œå¯æ”¹æˆå¸¦ token çš„ https url
            git clone https://github.com/yshujie/miniblog.git . || {
              echo "Repo private? Provide access or copy compose files manually." >&2
              exit 1
            }
          fi

          # å†™ .envï¼ˆcompose å¼•ç”¨ï¼‰
          cat > .env <<EOF
          BACKEND_IMAGE_TAG=${BACKEND_IMAGE}:${TAG}
          FRONTEND_BLOG_IMAGE_TAG=${FE_BLOG_IMAGE}:${TAG}
          FRONTEND_ADMIN_IMAGE_TAG=${FE
