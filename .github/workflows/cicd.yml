name: CI/CD

on:
  push:
    branches: [ main ]
  workflow_dispatch:

# 允许推送 GHCR
permissions:
  contents: read
  packages: write

concurrency:
  group: cicd-${{ github.ref }}
  cancel-in-progress: false

env:
  # 镜像名（按你的仓库改）
  BACKEND_IMAGE: ghcr.io/yshujie/miniblog-backend
  FE_BLOG_IMAGE: ghcr.io/yshujie/miniblog-frontend-blog
  FE_ADMIN_IMAGE: ghcr.io/yshujie/miniblog-frontend-admin
  TAG: ${{ github.sha }}

jobs:
  build-and-push:
    # 你的自托管机器（macOS）
    runs-on: self-hosted

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Use ephemeral DOCKER_CONFIG (no credsStore, no keychain)
        shell: bash
        run: |
          set -euo pipefail
          export DOCKER_CONFIG="$RUNNER_TEMP/.docker"
          mkdir -p "$DOCKER_CONFIG"
          # 绝不写 credsStore，避免 macOS 钥匙串
          cat > "$DOCKER_CONFIG/config.json" <<'JSON'
          { "auths": { "https://index.docker.io/v1/": {} } }
          JSON
          echo "DOCKER_CONFIG=$DOCKER_CONFIG" >> "$GITHUB_ENV"
          echo "🔒 Using ephemeral DOCKER_CONFIG=$DOCKER_CONFIG (no credsStore)"

      - name: Expose docker-buildx into ephemeral cli-plugins
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p "$DOCKER_CONFIG/cli-plugins"
          if [ -x /Applications/Docker.app/Contents/Resources/cli-plugins/docker-buildx ]; then
            SRC=/Applications/Docker.app/Contents/Resources/cli-plugins/docker-buildx
          elif [ -x "$HOME/.docker/cli-plugins/docker-buildx" ]; then
            SRC="$HOME/.docker/cli-plugins/docker-buildx"
          elif command -v docker-buildx >/dev/null 2>&1; then
            SRC="$(command -v docker-buildx)"
          else
            echo "ERROR: docker-buildx binary not found on this runner" >&2
            exit 1
          fi
          ln -sf "$SRC" "$DOCKER_CONFIG/cli-plugins/docker-buildx"
          docker buildx version

      - name: Prepare GHCR auth (prefer GHCR_TOKEN, fallback GITHUB_TOKEN)
        shell: bash
        env:
          GHCR_TOKEN: ${{ secrets.GHCR_TOKEN }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          USER="${{ github.actor }}"
          TOKEN="${GHCR_TOKEN:-}"
          if [ -z "$TOKEN" ]; then
            TOKEN="${GITHUB_TOKEN:-}"
          fi
          if [ -z "$TOKEN" ]; then
            echo "ERROR: Neither GHCR_TOKEN nor GITHUB_TOKEN available." >&2
            exit 1
          fi
          AUTH=$(printf "%s:%s" "$USER" "$TOKEN" | base64 | tr -d '\n')
          # 仅内联到环境，不调用 docker login（彻底绕开钥匙串）
          echo 'DOCKER_AUTH_CONFIG={"auths":{"ghcr.io":{"auth":"'"$AUTH"'"}}}' >> "$GITHUB_ENV"
          echo "✅ DOCKER_AUTH_CONFIG ready (inline, no keychain)"

      - name: Create a clean buildx builder bound to this DOCKER_CONFIG
        shell: bash
        run: |
          set -euo pipefail
          # 若存在旧 builder，先删；不存在就安静跳过
          docker buildx inspect miniblog-builder >/dev/null 2>&1 && docker buildx rm -f miniblog-builder || true
          docker buildx create --name miniblog-builder --driver docker-container --use \
            --driver-opt env.DOCKER_CONFIG="$DOCKER_CONFIG"
          docker buildx inspect --bootstrap
          docker buildx ls

      # ===== 后端镜像 =====
      - name: Build & Push backend
        shell: bash
        run: |
          set -euo pipefail
          docker buildx build \
            --platform linux/amd64 \
            --file build/docker/miniblog/Dockerfile.prod.backend \
            --build-arg GOPROXY=https://goproxy.cn,direct \
            --tag ${BACKEND_IMAGE}:${TAG} \
            --tag ${BACKEND_IMAGE}:latest \
            --push \
            .

      # ===== 前端镜像（如暂时没有相应 Dockerfile，可注释这两段）=====
      - name: Build & Push frontend (blog)
        if: ${{ always() }}
        shell: bash
        run: |
          set -euo pipefail
          if [ -f build/docker/miniblog/Dockerfile.prod.frontend.blog ]; then
            docker buildx build \
              --platform linux/amd64 \
              --file build/docker/miniblog/Dockerfile.prod.frontend.blog \
              --tag ${FE_BLOG_IMAGE}:${TAG} \
              --tag ${FE_BLOG_IMAGE}:latest \
              --push \
              .
          else
            echo "Skip blog FE build: Dockerfile not found."
          fi

      - name: Build & Push frontend (admin)
        if: ${{ always() }}
        shell: bash
        run: |
          set -euo pipefail
          if [ -f build/docker/miniblog/Dockerfile.prod.frontend.admin ]; then
            docker buildx build \
              --platform linux/amd64 \
              --file build/docker/miniblog/Dockerfile.prod.frontend.admin \
              --tag ${FE_ADMIN_IMAGE}:${TAG} \
              --tag ${FE_ADMIN_IMAGE}:latest \
              --push \
              .
          else
            echo "Skip admin FE build: Dockerfile not found."
          fi

  deploy:
    needs: build-and-push
    runs-on: self-hosted

    steps:
      - name: Checkout (for compose files used on server)
        uses: actions/checkout@v4

      - name: Write SSH key
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p ~/.ssh
          echo "${{ secrets.SVRA_SSH_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          # 信任一次主机指纹
          ssh-keyscan -H "${{ secrets.SVRA_HOST }}" >> ~/.ssh/known_hosts 2>/dev/null || true

      - name: Preflight check on remote user (shell & docker group)
        shell: bash
        run: |
          set -euo pipefail
          SSH_USER="${{ secrets.SVRA_USER }}"
          SSH_HOST="${{ secrets.SVRA_HOST }}"
          KEY=~/.ssh/deploy_key

          # 检查登录 shell
          SHELL_PATH=$(ssh -F /dev/null -i "$KEY" -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
            "$SSH_USER@$SSH_HOST" 'getent passwd "$USER" | cut -d: -f7 || true')
          echo "Remote user shell: ${SHELL_PATH:-<empty>}"
          if [ -z "$SHELL_PATH" ] || [ "$SHELL_PATH" = "/usr/sbin/nologin" ] || [ "$SHELL_PATH" = "/bin/false" ]; then
            echo "::error::Remote user ($SSH_USER) cannot start a login shell ($SHELL_PATH). Please change it to /bin/bash or /bin/sh, or use another user." >&2
            exit 1
          fi

          # 友情提示是否在 docker 组
          ssh -F /dev/null -i "$KEY" -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
            "$SSH_USER@$SSH_HOST" 'id -nG | tr " " "\n" | grep -qx docker || echo "::warning::User not in docker group; docker may require sudo."'

      - name: Deploy over SSH
        shell: bash
        env:
          # 镜像标签写入 .env
          BACKEND_IMAGE: ${{ env.BACKEND_IMAGE }}
          FE_BLOG_IMAGE: ${{ env.FE_BLOG_IMAGE }}
          FE_ADMIN_IMAGE: ${{ env.FE_ADMIN_IMAGE }}
          TAG: ${{ env.TAG }}
          # 可选：服务器拉私有 GHCR 的只读凭证
          SVRA_GHCR_USER: ${{ secrets.SVRA_GHCR_USER }}
          SVRA_GHCR_TOKEN: ${{ secrets.SVRA_GHCR_TOKEN }}
        run: |
          set -euo pipefail
          SSH_USER="${{ secrets.SVRA_USER }}"
          SSH_HOST="${{ secrets.SVRA_HOST }}"
          KEY=~/.ssh/deploy_key

          ssh -F /dev/null -i "$KEY" -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
            "$SSH_USER@$SSH_HOST" 'bash -s' <<'ENDSSH'
          set -euo pipefail

          # 服务器侧同样使用临时 DOCKER_CONFIG，彻底杜绝任何 keychain/credHelper
          export DOCKER_CONFIG="$(mktemp -d)"
          printf '{}' > "$DOCKER_CONFIG/config.json"

          # 若提供了 GHCR 只读凭证，则内联到 DOCKER_AUTH_CONFIG（用于 docker compose pull）
          if [ -n "${SVRA_GHCR_USER:-}" ] && [ -n "${SVRA_GHCR_TOKEN:-}" ]; then
            AUTH=$(printf "%s:%s" "$SVRA_GHCR_USER" "$SVRA_GHCR_TOKEN" | base64 | tr -d '\n')
            export DOCKER_AUTH_CONFIG='{"auths":{"ghcr.io":{"auth":"'"$AUTH"'"}}}'
          fi

          # 选择 docker 命令（若无权限，尝试 sudo）
          if docker ps >/dev/null 2>&1; then
            DOCKER="docker"
          elif sudo -n docker ps >/dev/null 2>&1; then
            DOCKER="sudo docker"
          else
            echo "ERROR: docker not usable (neither user nor sudo)." >&2
            exit 1
          fi

          # 确保部署目录 & 日志目录
          APP_DIR="/opt/miniblog"
          LOG_DIR="/data/logs/miniblog"
          if ! mkdir -p "$APP_DIR" "$LOG_DIR"/{backend,frontend-blog,frontend-admin} 2>/dev/null; then
            sudo -n mkdir -p "$APP_DIR" "$LOG_DIR"/{backend,frontend-blog,frontend-admin}
          fi
          cd "$APP_DIR"

          # 拉取仓库（若服务器直接从本仓库拉 compose 文件）
          if [ -d .git ]; then
            git fetch --all -p && git reset --hard origin/main
          else
            # 公有仓库可直接 clone；若私有，可改成带 token 的 https url
            git clone https://github.com/yshujie/miniblog.git . || {
              echo "Repo private? Provide access or copy compose files manually." >&2
              exit 1
            }
          fi

          # 写 .env（compose 引用）
          cat > .env <<EOF
          BACKEND_IMAGE_TAG=${BACKEND_IMAGE}:${TAG}
          FRONTEND_BLOG_IMAGE_TAG=${FE_BLOG_IMAGE}:${TAG}
          FRONTEND_ADMIN_IMAGE_TAG=${FE
