name: CI/CD (miniblog)

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      skip_tests:
        description: 'Skip unit tests'
        type: boolean
        default: false

permissions:
  contents: read
  packages: write

env:
  BACKEND_IMAGE: ghcr.io/${{ github.repository_owner }}/miniblog-backend
  FE_BLOG_IMAGE: ghcr.io/${{ github.repository_owner }}/miniblog-frontend-blog
  FE_ADMIN_IMAGE: ghcr.io/${{ github.repository_owner }}/miniblog-frontend-admin
  TAG: ${{ github.sha }}

concurrency:
  group: miniblog-prod
  cancel-in-progress: false

jobs:
  # å•å…ƒæµ‹è¯•é˜¶æ®µ
  test:
    if: ${{ !inputs.skip_tests }}
    runs-on: [self-hosted, macOS, ARM64]
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.24'
          cache: true
          cache-dependency-path: |
            go.sum
            go.work.sum
      
      - name: Fix Go module cache permissions
        run: |
          # ä¿®å¤ Go æ¨¡å—ç¼“å­˜çš„æƒé™é—®é¢˜
          if [ -d ~/go/pkg/mod ]; then
            chmod -R u+w ~/go/pkg/mod || true
            echo "âœ… Go æ¨¡å—ç¼“å­˜æƒé™å·²ä¿®å¤"
          else
            echo "âœ… Go æ¨¡å—ç¼“å­˜ç›®å½•ä¸å­˜åœ¨ï¼Œè·³è¿‡"
          fi
      
      - name: Download dependencies
        run: go mod download
      
      - name: Run unit tests
        run: make test-backend

  build-and-push:
    needs: [test]
    if: ${{ !cancelled() && (success() || inputs.skip_tests) }}
    runs-on: [self-hosted, macOS, ARM64]

    steps:
      - uses: actions/checkout@v4

      - name: Login to GitHub Container Registry
        run: |
          echo "${{ secrets.GHCR_TOKEN }}" | docker login ghcr.io -u "${{ github.repository_owner }}" --password-stdin
          echo "âœ… å·²ç™»å½•åˆ° GHCR"

      - name: Setup Docker Buildx
        run: |
          # éªŒè¯ buildx å·²å®‰è£…
          echo "=== Buildx ç‰ˆæœ¬ ==="
          docker buildx version
          echo ""
          
          # åˆ›å»ºæˆ–ä½¿ç”¨ç°æœ‰çš„ builder
          if docker buildx inspect miniblog-builder &>/dev/null; then
            echo "âœ… ä½¿ç”¨ç°æœ‰ builder: miniblog-builder"
            docker buildx use miniblog-builder
          else
            echo "ğŸ“¦ åˆ›å»ºæ–°çš„ builder: miniblog-builder"
            docker buildx create --name miniblog-builder --driver docker-container --use
          fi
          
          # å¯åŠ¨ builder
          docker buildx inspect --bootstrap
          
          echo ""
          echo "=== å¯ç”¨çš„ Builders ==="
          docker buildx ls

      # === Backend ===
      - name: Build & Push backend (linux/amd64)
        run: |
          echo "ğŸ”¨ æ„å»º Backend é•œåƒ..."
          docker buildx build \
            --platform linux/amd64 \
            --file build/docker/miniblog/Dockerfile.prod.backend \
            --build-arg GOPROXY=https://goproxy.cn,direct \
            --tag ${{ env.BACKEND_IMAGE }}:${{ env.TAG }} \
            --tag ${{ env.BACKEND_IMAGE }}:latest \
            --push \
            .
          echo "âœ… Backend é•œåƒæ„å»ºå¹¶æ¨é€æˆåŠŸ"

      # === Frontend Blog ===
      - name: Build & Push frontend-blog
        run: |
          echo "ğŸ”¨ æ„å»º Frontend Blog é•œåƒ..."
          docker buildx build \
            --platform linux/amd64 \
            --file build/docker/miniblog/Dockerfile.prod.frontend.blog \
            --tag ${{ env.FE_BLOG_IMAGE }}:${{ env.TAG }} \
            --tag ${{ env.FE_BLOG_IMAGE }}:latest \
            --push \
            .
          echo "âœ… Frontend Blog é•œåƒæ„å»ºå¹¶æ¨é€æˆåŠŸ"

      # === Frontend Admin ===
      - name: Build & Push frontend-admin
        run: |
          echo "ğŸ”¨ æ„å»º Frontend Admin é•œåƒ..."
          docker buildx build \
            --platform linux/amd64 \
            --file build/docker/miniblog/Dockerfile.prod.frontend.admin \
            --tag ${{ env.FE_ADMIN_IMAGE }}:${{ env.TAG }} \
            --tag ${{ env.FE_ADMIN_IMAGE }}:latest \
            --push \
            .
          echo "âœ… Frontend Admin é•œåƒæ„å»ºå¹¶æ¨é€æˆåŠŸ"

  deploy:
    # ä½¿ç”¨ macOS è‡ªæ‰˜ç®¡ runnerï¼Œé¿å…å®¹å™¨ action é™åˆ¶
    runs-on: [self-hosted, macOS, ARM64]
    needs: build-and-push
    environment: production
    timeout-minutes: 30
    steps:
      - uses: actions/checkout@v4

      # å‡†å¤‡ SSH å¯†é’¥ï¼ˆä¸€æ¬¡æ€§è®¾ç½®ï¼‰
      - name: Setup SSH Key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SVRA_SSH_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ secrets.SVRA_HOST }} >> ~/.ssh/known_hosts 2>/dev/null || true

      - name: Deploy to Server A via SSH
        run: |
          ssh -F /dev/null \
            -i ~/.ssh/deploy_key \
            -o StrictHostKeyChecking=no \
            -o UserKnownHostsFile=/dev/null \
            ${{ secrets.SVRA_USER }}@${{ secrets.SVRA_HOST }} \
            'bash -s' <<'ENDSSH'
          set -euo pipefail

          # 1) é¢„ç½®ç½‘ç»œ/ç›®å½•ï¼ˆå¹‚ç­‰ï¼‰
          docker network inspect miniblog_net >/dev/null 2>&1 || docker network create miniblog_net
          # Try to create directories; if normal mkdir fails (permission), try non-interactive sudo (-n).
          if ! mkdir -p /opt/miniblog /data/logs/miniblog/{backend,frontend-blog,frontend-admin} 2>/dev/null; then
            echo "Attempting to use sudo to create directories (non-interactive)" >&2
            sudo -n mkdir -p /opt/miniblog /data/logs/miniblog/{backend,frontend-blog,frontend-admin} || (
              echo "ERROR: Unable to create required directories. Ensure deploy user has NOPASSWD sudo or create these dirs manually." >&2
              exit 1
            )
          fi
          cd /opt/miniblog

          # 2) æ‹‰ä»£ç ï¼ˆè¦æ±‚æœåŠ¡å™¨å·²é…ç½® Deploy Keyï¼šHost github-miniblogï¼‰
          if [ -d .git ]; then
            git fetch --all -p && git reset --hard origin/main
          else
            git clone github-miniblog:${{ github.repository }} .
          fi

          # 3) ç™»å½• GHCRï¼ˆæ‹‰é•œåƒï¼‰
          echo "${{ secrets.GHCR_TOKEN }}" | docker login ghcr.io -u "${{ github.repository_owner }}" --password-stdin

          # 4) å†™å…¥ .envï¼ˆç”¨å¸¦å¼•å·çš„ heredoc é˜²æ­¢è¿œç«¯ shell å±•å¼€ï¼‰
          cat > .env <<'EOF'
          BACKEND_IMAGE_TAG=${{ env.BACKEND_IMAGE }}:${{ env.TAG }}
          FRONTEND_BLOG_IMAGE_TAG=${{ env.FE_BLOG_IMAGE }}:${{ env.TAG }}
          FRONTEND_ADMIN_IMAGE_TAG=${{ env.FE_ADMIN_IMAGE }}:${{ env.TAG }}

          GIN_MODE=release

          MYSQL_HOST=${{ secrets.MYSQL_HOST }}
          MYSQL_PORT=${{ secrets.MYSQL_PORT }}
          MYSQL_DATABASE=${{ secrets.MYSQL_DBNAME }}
          MYSQL_USERNAME=${{ secrets.MYSQL_USERNAME }}
          MYSQL_PASSWORD=${{ secrets.MYSQL_PASSWORD }}

          REDIS_HOST=${{ secrets.REDIS_HOST }}
          REDIS_PORT=${{ secrets.REDIS_PORT }}
          REDIS_DB=${{ secrets.REDIS_DB }}
          REDIS_PASSWORD=${{ secrets.REDIS_PASSWORD }}

          JWT_SECRET=${{ secrets.JWT_SECRET }}

          FEISHU_DOCREADER_APPID=${{ secrets.FEISHU_DOCREADER_APPID }}
          FEISHU_DOCREADER_APPSECRET=${{ secrets.FEISHU_DOCREADER_APPSECRET }}
          EOF

          # 5) æ‹‰å–å¹¶æ— åœæœºæ›´æ–°ï¼ˆç”Ÿäº§è¦†ç›–æ–‡ä»¶å›ºå®š 8090 ç«¯å£ï¼‰
          docker compose -f docker-compose.yml -f docker-compose.prod.yml pull
          docker compose -f docker-compose.yml -f docker-compose.prod.yml up -d

          # Ensure nginx is connected to the application network and reload config to pick up new upstreams
          docker network inspect miniblog_net >/dev/null 2>&1 || docker network create miniblog_net
          docker network connect miniblog_net nginx || true

          # Poll backend health endpoint (from inside miniblog_net) before reloading nginx
          echo "Polling backend health (up to 60s)..."
          HEALTH_OK=1
          for i in $(seq 1 30); do
            if docker run --rm --network=miniblog_net curlimages/curl:8.1.2 -fsS http://miniblog-backend:8080/health >/dev/null 2>&1; then
              echo "Backend healthy after $((i*2))s"
              HEALTH_OK=0
              break
            fi
            sleep 2
          done
          if [ "$HEALTH_OK" -ne 0 ]; then
            echo "WARNING: Backend health check failed after 60s; nginx reload will not be attempted" >&2
            exit 1
          fi

          docker exec nginx nginx -t && docker exec nginx nginx -s reload || true

          # 6) å¥åº·æ£€æŸ¥ + ç®€è¦çŠ¶æ€
          sleep 2
          (curl -fsS http://127.0.0.1:8090/health && echo " HEALTH=OK") || (echo "HEALTH=FAIL"; exit 1)
          docker ps --format 'table {{.Names}}\t{{.Image}}\t{{.Status}}'
          ENDSSH

      # æ•°æ®åº“ç›¸å…³æ­¥éª¤ï¼ˆé¦–æ¬¡éƒ¨ç½²æ—¶å¯èƒ½éœ€è¦ï¼‰ï¼š
      # å·²ç”±ç»´æŠ¤äººå‘˜åœ¨ç›®æ ‡ç¯å¢ƒæ‰‹åŠ¨æ‰§è¡Œã€‚è‹¥å°†æ¥éœ€è¦æ¢å¤è‡ªåŠ¨åŒ–ï¼Œè¯·æ¢å¤ä¸‹é¢è¢«ç§»é™¤çš„æ­¥éª¤ï¼š
      #  - DB Init  (é¦–æ¬¡åˆå§‹åŒ–)
      #  - DB Migrate (æ•°æ®åº“è¿ç§»)
      #  - DB Seed (ç§å­æ•°æ®å¯¼å…¥)
      # ä¸ºé¿å…æ„å¤–åœ¨æ¯æ¬¡éƒ¨ç½²æ‰§è¡Œï¼Œå·²æš‚æ—¶ç§»é™¤è¿™äº›æ­¥éª¤ã€‚

      # æ¸…ç† SSH å¯†é’¥
      - name: Cleanup SSH Key
        if: always()
        run: |
          rm -f ~/.ssh/deploy_key
