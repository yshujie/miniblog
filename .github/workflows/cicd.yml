name: CI/CD (miniblog-prod)

on:
  push:
    branches: [ main ]
  workflow_dispatch:

permissions:
  contents: read
  packages: write

env:
  BACKEND_IMAGE: ghcr.io/${{ github.repository_owner }}/miniblog-backend
  FE_BLOG_IMAGE: ghcr.io/${{ github.repository_owner }}/miniblog-frontend-blog
  FE_ADMIN_IMAGE: ghcr.io/${{ github.repository_owner }}/miniblog-frontend-admin
  TAG: ${{ github.sha }}

concurrency:
  group: miniblog-prod
  cancel-in-progress: false

jobs:
  build-and-push:
    # 如果你已经给 Runner 加了 macmini/prod 标签，改成：
    # runs-on: [self-hosted, macmini, prod]
    runs-on: [self-hosted, macOS, ARM64]

    steps:
      - uses: actions/checkout@v4

      - uses: docker/setup-qemu-action@v3
      - uses: docker/setup-buildx-action@v3

      - name: Login GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GHCR_TOKEN }}

      # === 后端镜像（确认 Dockerfile 路径）===
      # 常见1：项目根有 Dockerfile.prod.backend（你本机列表里就是这个）
      - name: Build & Push backend
        uses: docker/build-push-action@v6
        with:
          context: .
          file: Dockerfile.prod.backend
          platforms: linux/amd64
          push: true
          cache-from: type=gha
          cache-to: type=gha,mode=max
          tags: |
            ${{ env.BACKEND_IMAGE }}:${{ env.TAG }}
            ${{ env.BACKEND_IMAGE }}:latest

      # === 博客前端镜像（把 context/file 对上你的仓库结构）===
      # 方案A（常见）：web/miniblog-web 目录下有 Dockerfile.prod.frontend.blog
      - name: Build & Push frontend-blog
        uses: docker/build-push-action@v6
        with:
          context: ./web/miniblog-web
          file: ./web/miniblog-web/Dockerfile.prod.frontend.blog
          platforms: linux/amd64
          push: true
          cache-from: type=gha
          cache-to: type=gha,mode=max
          tags: |
            ${{ env.FE_BLOG_IMAGE }}:${{ env.TAG }}
            ${{ env.FE_BLOG_IMAGE }}:latest
      # 如果你的前端 Dockerfile 在别处，改 context/file 即可；实在不确定，先把这整个 step 注释掉，后端先跑通。

      # === Admin 前端镜像（同理改路径）===
      - name: Build & Push frontend-admin
        uses: docker/build-push-action@v6
        with:
          context: ./web/miniblog-web-admin
          file: ./web/miniblog-web-admin/Dockerfile.prod.frontend.admin
          platforms: linux/amd64
          push: true
          cache-from: type=gha
          cache-to: type=gha,mode=max
          tags: |
            ${{ env.FE_ADMIN_IMAGE }}:${{ env.TAG }}
            ${{ env.FE_ADMIN_IMAGE }}:latest

  deploy:
    # 同上，若已加自定义标签，改成 [self-hosted, macmini, prod]
    runs-on: [self-hosted, macOS, ARM64]
    needs: build-and-push
    environment: production
    timeout-minutes: 30

    steps:
      - uses: actions/checkout@v4

      - name: Deploy to Server A via SSH
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SVRA_HOST }}
          username: ${{ secrets.SVRA_USER }}
          key: ${{ secrets.SVRA_SSH_KEY }}
          script_stop: true
          script: |
            set -euo pipefail

            # 1) 预置网络/目录（幂等）
            docker network inspect miniblog_net >/dev/null 2>&1 || docker network create miniblog_net
            sudo mkdir -p /opt/miniblog /data/logs/miniblog/{backend,frontend-blog,frontend-admin}

            # 2) 拉代码（要求服务器已配置 Deploy Key: Host github-miniblog）
            cd /opt/miniblog
            if [ -d .git ]; then
              git fetch --all -p && git reset --hard origin/main
            else
              git clone github-miniblog:${{ github.repository }} .
            fi

            # 3) 登录 GHCR（拉镜像用）
            echo "${{ secrets.GHCR_TOKEN }}" | docker login ghcr.io -u "${{ github.repository_owner }}" --password-stdin

            # 4) 写入 .env 注入镜像与业务配置
            cat > .env <<EOF
BACKEND_IMAGE_TAG=${{ env.BACKEND_IMAGE }}:${{ env.TAG }}
FRONTEND_BLOG_IMAGE_TAG=${{ env.FE_BLOG_IMAGE }}:${{ env.TAG }}
FRONTEND_ADMIN_IMAGE_TAG=${{ env.FE_ADMIN_IMAGE }}:${{ env.TAG }}

GIN_MODE=release
MYSQL_HOST=${{ secrets.MYSQL_HOST }}
MYSQL_PORT=3306
MYSQL_DATABASE=${{ secrets.MYSQL_DATABASE }}
MYSQL_USERNAME=${{ secrets.MYSQL_USERNAME }}
MYSQL_PASSWORD=${{ secrets.MYSQL_PASSWORD }}
REDIS_HOST=${{ secrets.REDIS_HOST }}
REDIS_DB=${{ secrets.REDIS_DB }}
JWT_SECRET=${{ secrets.JWT_SECRET }}
EOF

            # 5) 拉取并无停机更新（生产覆盖文件固定 8090 端口）
            docker compose -f docker-compose.yml -f docker-compose.prod.yml pull
            docker compose -f docker-compose.yml -f docker-compose.prod.yml up -d

            # 6) 健康检查 + 简要状态
            sleep 2
            (curl -fsS http://127.0.0.1:8090/health && echo " HEALTH=OK") || (echo "HEALTH=FAIL"; exit 1)
            docker ps --format 'table {{.Names}}\t{{.Image}}\t{{.Status}}'
