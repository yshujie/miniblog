name: CI/CD (miniblog)

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      skip_tests:
        description: 'Skip unit tests'
        type: boolean
        default: false

permissions:
  contents: read
  packages: write

env:
  BACKEND_IMAGE: ghcr.io/${{ github.repository_owner }}/miniblog-backend
  FE_BLOG_IMAGE: ghcr.io/${{ github.repository_owner }}/miniblog-frontend-blog
  FE_ADMIN_IMAGE: ghcr.io/${{ github.repository_owner }}/miniblog-frontend-admin
  TAG: ${{ github.sha }}

concurrency:
  group: miniblog-prod
  cancel-in-progress: false

jobs:
  # ====== å•å…ƒæµ‹è¯• ======
  test:
    if: ${{ !inputs.skip_tests }}
    runs-on: [self-hosted, macOS, ARM64]
    steps:
      - uses: actions/checkout@v4

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.24'
          cache: true
          cache-dependency-path: |
            go.sum
            go.work.sum

      - name: Fix Go module cache permissions (best-effort)
        run: |
          [ -d "$HOME/go/pkg/mod" ] && chmod -R u+w "$HOME/go/pkg/mod" || true

      - name: Download dependencies
        run: go mod download

      - name: Run unit tests
        run: make test-backend

  # ====== æ„å»ºå¹¶æ¨é€é•œåƒ ======
  build-and-push:
    needs: [test]
    if: ${{ !cancelled() && (success() || inputs.skip_tests) }}
    runs-on: [self-hosted, macOS, ARM64]
    env:
      HTTP_PROXY: ""
      HTTPS_PROXY: ""
      NO_PROXY: ghcr.io,*.ghcr.io,github.com,*.github.com
    steps:
      - uses: actions/checkout@v4

      # 0) æœ¬ job ä½¿ç”¨â€œç©ºâ€çš„ Docker é…ç½®ï¼Œæ˜ç¡®ç»™ docker.io åŒ¿åæ¡ç›®ï¼Œå®Œå…¨ä¸è§¦å‘é’¥åŒ™ä¸²
      - name: Disable macOS keychain for this job
        run: |
          export DOCKER_CONFIG="$RUNNER_TEMP/.docker"
          mkdir -p "$DOCKER_CONFIG"
          cat > "$DOCKER_CONFIG/config.json" <<'JSON'
          {
            "auths": {
              "https://index.docker.io/v1/": {}
            }
          }
          JSON
          echo "DOCKER_CONFIG=$DOCKER_CONFIG" >> "$GITHUB_ENV"
          echo "ğŸ”’ Using ephemeral DOCKER_CONFIG=$DOCKER_CONFIG (no credsStore, docker.io anon)"

      # 0.1) æŠŠ buildx æ’ä»¶æ˜¾å¼æš´éœ²åˆ°ä¸´æ—¶ DOCKER_CONFIGï¼ˆæ–¹æ¡ˆ Aï¼‰
      - name: Make buildx available with ephemeral DOCKER_CONFIG
        run: |
          mkdir -p "$DOCKER_CONFIG/cli-plugins"
          if [ -x /Applications/Docker.app/Contents/Resources/cli-plugins/docker-buildx ]; then
            SRC=/Applications/Docker.app/Contents/Resources/cli-plugins/docker-buildx
          elif [ -x "$HOME/.docker/cli-plugins/docker-buildx" ]; then
            SRC="$HOME/.docker/cli-plugins/docker-buildx"
          elif command -v docker-buildx >/dev/null 2>&1; then
            SRC="$(command -v docker-buildx)"
          else
            echo "ERROR: docker-buildx binary not found on this runner" >&2
            exit 1
          fi
          ln -sf "$SRC" "$DOCKER_CONFIG/cli-plugins/docker-buildx"
          docker buildx version

      # 1) ä»…å¯¹ ghcr.io æ³¨å…¥å†…è”å‡­è¯ï¼›å¹¶â€œé‡å»ºâ€ builderï¼ŒæŠŠ DOCKER_CONFIG æ³¨å…¥ buildkit
      - name: Prepare registry auth and Setup Docker Buildx
        env:
          HTTP_PROXY: ""
          HTTPS_PROXY: ""
          NO_PROXY: ghcr.io,*.ghcr.io,github.com,*.github.com
        run: |
          # GHCR å‡­è¯ï¼ˆGHCR_TOKEN ä¼˜å…ˆï¼Œå¦åˆ™ GITHUB_TOKENï¼‰
          USER="${{ github.repository_owner }}"
          TOKEN="${{ secrets.GHCR_TOKEN }}"
          [ -z "$TOKEN" ] && TOKEN="${{ secrets.GITHUB_TOKEN }}"
          [ -n "$TOKEN" ] || { echo "ERROR: Neither GHCR_TOKEN nor GITHUB_TOKEN available." >&2; exit 1; }
          AUTH=$(printf "%s:%s" "$USER" "$TOKEN" | base64 | tr -d '\n')
          echo 'DOCKER_AUTH_CONFIG={"auths":{"ghcr.io":{"auth":"'"$AUTH"'"}}}' >> "$GITHUB_ENV"
          echo "âœ… DOCKER_AUTH_CONFIG ready (inline, no keychain)"

          # å…³é”®ï¼šåˆ é™¤æ—§ builderï¼ŒæŒ‰å½“å‰ DOCKER_CONFIG ç¯å¢ƒé‡å»ºï¼Œå¹¶æŠŠ env æ³¨å…¥ buildkit
          docker buildx rm -f miniblog-builder || true
          docker buildx create --name miniblog-builder --driver docker-container --use \
            --driver-opt env.DOCKER_CONFIG="$DOCKER_CONFIG" \
            --driver-opt env.HTTP_PROXY="$HTTP_PROXY" \
            --driver-opt env.HTTPS_PROXY="$HTTPS_PROXY" \
            --driver-opt env.NO_PROXY="$NO_PROXY"
          docker buildx inspect --bootstrap
          docker buildx ls

      # === Backend ===
      - name: Build & Push backend (linux/amd64)
        run: |
          docker buildx build \
            --platform linux/amd64 \
            --file build/docker/miniblog/Dockerfile.prod.backend \
            --build-arg GOPROXY=https://goproxy.cn,direct \
            --tag ${{ env.BACKEND_IMAGE }}:${{ env.TAG }} \
            --tag ${{ env.BACKEND_IMAGE }}:latest \
            --push \
            .

      # === Frontend Blog ===
      - name: Build & Push frontend-blog (linux/amd64)
        run: |
          docker buildx build \
            --platform linux/amd64 \
            --file build/docker/miniblog/Dockerfile.prod.frontend.blog \
            --tag ${{ env.FE_BLOG_IMAGE }}:${{ env.TAG }} \
            --tag ${{ env.FE_BLOG_IMAGE }}:latest \
            --push \
            .

      # === Frontend Admin ===
      - name: Build & Push frontend-admin (linux/amd64)
        run: |
          docker buildx build \
            --platform linux/amd64 \
            --file build/docker/miniblog/Dockerfile.prod.frontend.admin \
            --tag ${{ env.FE_ADMIN_IMAGE }}:${{ env.TAG }} \
            --tag ${{ env.FE_ADMIN_IMAGE }}:latest \
            --push \
            .

  # ====== éƒ¨ç½²åˆ° Server A ======
  deploy:
    runs-on: [self-hosted, macOS, ARM64]
    needs: build-and-push
    environment: production
    timeout-minutes: 30
    steps:
      - uses: actions/checkout@v4

      - name: Setup SSH Key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SVRA_SSH_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ secrets.SVRA_HOST }} >> ~/.ssh/known_hosts 2>/dev/null || true

      - name: Deploy to server (login with a real shell user)
        env:
          HOST: ${{ secrets.SVRA_HOST }}
          # ä¼˜å…ˆä½¿ç”¨å¯ç™»å½•è´¦å·ï¼ˆå»ºè®®è®¾ç½®è¿™ä¸ªæœºå¯†ï¼‰ï¼Œå¦åˆ™å›é€€åˆ°æ—§å˜é‡ï¼Œå†ä¸è¡Œç”¨ root
          LOGIN_USER: ${{ secrets.SVRA_LOGIN_USER }}
          LEGACY_USER: ${{ secrets.SVRA_USER }}
        run: |
          USER="${LOGIN_USER:-$LEGACY_USER}"
          [ -n "$USER" ] || USER="root"
          echo "â†’ SSH as $USER@${HOST}"

          ssh -F /dev/null \
            -i ~/.ssh/deploy_key \
            -o StrictHostKeyChecking=no \
            -o UserKnownHostsFile=/dev/null \
            "$USER@$HOST" 'bash -s' <<'ENDSSH'
          set -euo pipefail

          # è¿œç«¯åŒæ ·ä½¿ç”¨ä¸´æ—¶ DOCKER_CONFIGï¼Œé¿å…ä»»ä½• credsStore/é’¥åŒ™ä¸²
          export DOCKER_CONFIG="$(mktemp -d)"
          printf '{}' > "$DOCKER_CONFIG/config.json"

          # åŸºç¡€å‡†å¤‡
          docker network inspect miniblog_net >/dev/null 2>&1 || docker network create miniblog_net
          if ! mkdir -p /opt/miniblog /data/logs/miniblog/{backend,frontend-blog,frontend-admin} 2>/dev/null; then
            sudo -n mkdir -p /opt/miniblog /data/logs/miniblog/{backend,frontend-blog,frontend-admin} || {
              echo "ERROR: Need permission to create /opt/miniblog & /data/logs/miniblog/*" >&2
              exit 1
            }
          fi
          cd /opt/miniblog

          # æ‹‰å–/æ›´æ–°ä»“åº“ï¼ˆç§åº“å¯åœ¨ä»“åº“æœºå¯†ä¸­æä¾› SVRA_GIT_TOKENï¼‰
          if [ -d .git ]; then
            git fetch --all -p && git reset --hard origin/main
          else
            REPO_URL="https://github.com/${{ github.repository }}.git"
            if [ -n "${{ secrets.SVRA_GIT_TOKEN }}" ]; then
              REPO_URL="https://${{ secrets.SVRA_GIT_TOKEN }}@github.com/${{ github.repository }}.git"
            fi
            git clone "$REPO_URL" .
          fi

          # GHCR é‰´æƒï¼ˆä¼˜å…ˆ GHCR_TOKENï¼Œå…¶æ¬¡ GITHUB_TOKENï¼‰
          USER_GH="${{ github.repository_owner }}"
          TOKEN_GH="${{ secrets.GHCR_TOKEN }}"
          [ -z "$TOKEN_GH" ] && TOKEN_GH="${{ secrets.GITHUB_TOKEN }}"
          AUTH=$(printf "%s:%s" "$USER_GH" "$TOKEN_GH" | base64 | tr -d '\n')
          export DOCKER_AUTH_CONFIG='{"auths":{"ghcr.io":{"auth":"'"$AUTH"'"}}}'

          # å†™ .envï¼ˆé•œåƒæ ‡ç­¾ä½¿ç”¨æœ¬æ¬¡æ„å»ºçš„ SHAï¼‰
          cat > .env <<'EOF'
          BACKEND_IMAGE_TAG=${{ env.BACKEND_IMAGE }}:${{ env.TAG }}
          FRONTEND_BLOG_IMAGE_TAG=${{ env.FE_BLOG_IMAGE }}:${{ env.TAG }}
          FRONTEND_ADMIN_IMAGE_TAG=${{ env.FE_ADMIN_IMAGE }}:${{ env.TAG }}

          GIN_MODE=release

          MYSQL_HOST=${{ secrets.MYSQL_HOST }}
          MYSQL_PORT=${{ secrets.MYSQL_PORT }}
          MYSQL_DATABASE=${{ secrets.MYSQL_DBNAME }}
          MYSQL_USERNAME=${{ secrets.MYSQL_USERNAME }}
          MYSQL_PASSWORD=${{ secrets.MYSQL_PASSWORD }}

          REDIS_HOST=${{ secrets.REDIS_HOST }}
          REDIS_PORT=${{ secrets.REDIS_PORT }}
          REDIS_DB=${{ secrets.REDIS_DB }}
          REDIS_PASSWORD=${{ secrets.REDIS_PASSWORD }}

          JWT_SECRET=${{ secrets.JWT_SECRET }}

          FEISHU_DOCREADER_APPID=${{ secrets.FEISHU_DOCREADER_APPID }}
          FEISHU_DOCREADER_APPSECRET=${{ secrets.FEISHU_DOCREADER_APPSECRET }}
          EOF

          # æ‹‰é•œåƒ & å¯åŠ¨
          docker compose -f docker-compose.yml -f docker-compose.prod.yml pull
          docker compose -f docker-compose.yml -f docker-compose.prod.yml up -d

          # æ¥å…¥å…±äº«ç½‘ç»œ & æ¢æ´» & reload
          docker network inspect miniblog_net >/dev/null 2>&1 || docker network create miniblog_net
          docker network connect miniblog_net nginx || true

          echo "Polling backend health (up to 60s)..."
          for i in $(seq 1 30); do
            if docker run --rm --network=miniblog_net curlimages/curl:8.1.2 -fsS http://miniblog-backend:8080/health >/dev/null 2>&1; then
              echo "Backend healthy"
              break
            fi
            sleep 2
          done

          docker exec nginx nginx -t && docker exec nginx nginx -s reload || true

          sleep 2
          (curl -fsS http://127.0.0.1:8090/health && echo " HEALTH=OK") || (echo "HEALTH=FAIL"; exit 1)
          docker ps --format 'table {{.Names}}\t{{.Image}}\t{{.Status}}'
          ENDSSH

      - name: Cleanup SSH Key
        if: always()
        run: rm -f ~/.ssh/deploy_key
