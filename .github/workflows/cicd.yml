name: CI/CD (miniblog - production, linux runner)

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      skip_tests:
        description: "Skip tests"
        type: boolean
        default: false

permissions:
  contents: read
  packages: write

concurrency:
  group: miniblog-prod
  cancel-in-progress: false

env:
  GO_VERSION: "1.24"
  TAG: ${{ github.sha }}
  BACKEND_IMAGE: ghcr.io/${{ github.repository_owner }}/miniblog-backend
  FE_BLOG_IMAGE: ghcr.io/${{ github.repository_owner }}/miniblog-frontend-blog
  FE_ADMIN_IMAGE: ghcr.io/${{ github.repository_owner }}/miniblog-frontend-admin

jobs:
  validate-secrets:
    name: Validate Secrets
    runs-on: ubuntu-latest
    steps:
      - name: Check Required Secrets (non-blocking)
        env:
          SVRA_HOST:           ${{ secrets.SVRA_HOST }}
          SVRA_USER:           ${{ secrets.SVRA_USER }}
          DEPLOY_SSH_KEY:      ${{ secrets.DEPLOY_SSH_KEY }}
          GHCR_TOKEN:          ${{ secrets.GHCR_TOKEN }}
          GHCR_USERNAME:       ${{ secrets.GHCR_USERNAME }}
          MYSQL_HOST:          ${{ secrets.MYSQL_HOST }}
          MYSQL_PORT:          ${{ secrets.MYSQL_PORT }}
          MYSQL_DBNAME:        ${{ secrets.MYSQL_DBNAME }}
          MYSQL_USERNAME:      ${{ secrets.MYSQL_USERNAME }}
          MYSQL_PASSWORD:      ${{ secrets.MYSQL_PASSWORD }}
          REDIS_HOST:          ${{ secrets.REDIS_HOST }}
          REDIS_PORT:          ${{ secrets.REDIS_PORT }}
          REDIS_DB:            ${{ secrets.REDIS_DB }}
          REDIS_PASSWORD:      ${{ secrets.REDIS_PASSWORD }}
          JWT_SECRET:          ${{ secrets.JWT_SECRET }}
          FEISHU_APPID:        ${{ secrets.FEISHU_DOCREADER_APPID }}
          FEISHU_SECRET:       ${{ secrets.FEISHU_DOCREADER_APPSECRET }}
        run: |
          echo "ğŸ” Validating required secrets (non-blocking)..."
          REQUIRED_ON_MAIN=(SVRA_HOST SVRA_USER DEPLOY_SSH_KEY MYSQL_HOST MYSQL_DBNAME MYSQL_USERNAME MYSQL_PASSWORD REDIS_HOST REDIS_PASSWORD JWT_SECRET)
          OPTIONAL=(MYSQL_PORT REDIS_PORT REDIS_DB FEISHU_APPID FEISHU_SECRET GHCR_TOKEN GHCR_USERNAME)
          FAILED=0

          if [ "${{ github.ref }}" = "refs/heads/main" ]; then
            for k in "${REQUIRED_ON_MAIN[@]}"; do
              v="${!k}"
              if [ -z "$v" ]; then
                echo "âŒ $k is not set"
                FAILED=1
              else
                echo "âœ… $k is set"
              fi
            done
          else
            echo "â„¹ï¸ Not on main, skipping strict checks"
          fi

          for k in "${OPTIONAL[@]}"; do
            v="${!k}"
            if [ -z "$v" ]; then
              echo "âš ï¸ $k not set (optional)"
            else
              echo "âœ… $k is set"
            fi
          done

          echo
          if [ $FAILED -eq 1 ]; then
            echo "âš ï¸ Secrets validation failed, but continuing (non-blocking)."
          else
            echo "âœ… Secrets validation passed."
          fi

  test:
    name: Run Tests
    runs-on: ubuntu-latest
    if: ${{ github.event_name != 'workflow_dispatch' || inputs.skip_tests != true }}
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true
      - name: Download deps
        run: |
          go mod download
          go mod verify
      - name: Run unit tests
        run: |
          go test -v ./...

  build-and-push:
    name: Build & Push Images (GHCR)
    runs-on: ubuntu-latest
    needs: [validate-secrets, test]
    if: always() && (needs.test.result == 'success' || needs.test.result == 'skipped')
    env:
      GHCR_TOKEN: ${{ secrets.GHCR_TOKEN }}
      GHCR_USERNAME: ${{ secrets.GHCR_USERNAME }}
    steps:
      - uses: actions/checkout@v4

      - name: Pre-clean GHCR auth
        run: |
          docker logout ghcr.io || true
          rm -f ~/.docker/config.json || true

      # ä¼˜å…ˆä½¿ç”¨ PATï¼ˆå¯è·¨ä»“åº“/ç»„ç»‡ï¼‰ï¼Œå¯é€‰æä¾› GHCR_USERNAME
      - name: Login to GHCR with PAT (if provided)
        if: env.GHCR_TOKEN != ''
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ env.GHCR_USERNAME != '' && env.GHCR_USERNAME || github.repository_owner }}
          password: ${{ env.GHCR_TOKEN }}

      # å›è½åˆ° GITHUB_TOKENï¼ˆéœ€ä¸å½“å‰ä»“åº“/åŒ…å½’å±ä¸€è‡´ï¼‰
      - name: Login to GHCR with GITHUB_TOKEN (fallback)
        if: env.GHCR_TOKEN == ''
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Buildx
        uses: docker/setup-buildx-action@v3

      # Backend
      - name: Build & Push backend
        uses: docker/build-push-action@v6
        with:
          context: .
          file: build/docker/miniblog/Dockerfile.prod.backend
          platforms: linux/amd64
          push: true
          build-args: |
            GOPROXY=https://goproxy.cn,direct
          tags: |
            ${{ env.BACKEND_IMAGE }}:${{ env.TAG }}
            ${{ env.BACKEND_IMAGE }}:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

      # Frontend - blog
      - name: Build & Push frontend-blog
        uses: docker/build-push-action@v6
        with:
          context: .
          file: build/docker/miniblog/Dockerfile.prod.frontend.blog
          platforms: linux/amd64
          push: true
          tags: |
            ${{ env.FE_BLOG_IMAGE }}:${{ env.TAG }}
            ${{ env.FE_BLOG_IMAGE }}:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

      # Frontend - admin
      - name: Build & Push frontend-admin
        uses: docker/build-push-action@v6
        with:
          context: .
          file: build/docker/miniblog/Dockerfile.prod.frontend.admin
          platforms: linux/amd64
          push: true
          tags: |
            ${{ env.FE_ADMIN_IMAGE }}:${{ env.TAG }}
            ${{ env.FE_ADMIN_IMAGE }}:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

  deploy:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [build-and-push]
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    steps:
      - uses: actions/checkout@v4

      - name: Upload compose files
        uses: appleboy/scp-action@v0.1.7
        with:
          host:     ${{ secrets.SVRA_HOST }}
          username: ${{ secrets.SVRA_USER }}
          key:      ${{ secrets.DEPLOY_SSH_KEY }}
          port:     ${{ secrets.SVRA_SSH_PORT || 22 }}
          source:   "docker-compose.yml,docker-compose.prod.yml"
          target:   "/opt/miniblog"

      - name: Deploy on server (docker compose)
        uses: appleboy/ssh-action@v1.0.0
        env:
          _IMG_BACKEND:     ${{ env.BACKEND_IMAGE }}:${{ env.TAG }}
          _IMG_FE_BLOG:     ${{ env.FE_BLOG_IMAGE }}:${{ env.TAG }}
          _IMG_FE_ADMIN:    ${{ env.FE_ADMIN_IMAGE }}:${{ env.TAG }}
          _GH_USER:         ${{ github.repository_owner }}
          _GH_TOKEN:        ${{ secrets.GHCR_TOKEN }}
          _GHCR_USERNAME:   ${{ secrets.GHCR_USERNAME }}
          _MYSQL_HOST:      ${{ secrets.MYSQL_HOST }}
          _MYSQL_PORT:      ${{ secrets.MYSQL_PORT }}
          _MYSQL_DBNAME:    ${{ secrets.MYSQL_DBNAME }}
          _MYSQL_USERNAME:  ${{ secrets.MYSQL_USERNAME }}
          _MYSQL_PASSWORD:  ${{ secrets.MYSQL_PASSWORD }}
          _REDIS_HOST:      ${{ secrets.REDIS_HOST }}
          _REDIS_PORT:      ${{ secrets.REDIS_PORT }}
          _REDIS_DB:        ${{ secrets.REDIS_DB }}
          _REDIS_PASSWORD:  ${{ secrets.REDIS_PASSWORD }}
          _JWT_SECRET:      ${{ secrets.JWT_SECRET }}
          _FEISHU_APPID:    ${{ secrets.FEISHU_DOCREADER_APPID }}
          _FEISHU_SECRET:   ${{ secrets.FEISHU_DOCREADER_APPSECRET }}
        with:
          host:     ${{ secrets.SVRA_HOST }}
          username: ${{ secrets.SVRA_USER }}
          key:      ${{ secrets.DEPLOY_SSH_KEY }}
          port:     ${{ secrets.SVRA_SSH_PORT || 22 }}
          # å…³é”®ï¼šå°†ä¸Šé¢ env ä¸­çš„å˜é‡åä¼ é€’ç»™è¿œç«¯
          envs: >
            _IMG_BACKEND,_IMG_FE_BLOG,_IMG_FE_ADMIN,
            _GH_USER,_GH_TOKEN,_GHCR_USERNAME,
            _MYSQL_HOST,_MYSQL_PORT,_MYSQL_DBNAME,_MYSQL_USERNAME,_MYSQL_PASSWORD,
            _REDIS_HOST,_REDIS_PORT,_REDIS_DB,_REDIS_PASSWORD,
            _JWT_SECRET,_FEISHU_APPID,_FEISHU_SECRET
          script_stop: true
          script: |
            set -euo pipefail
            cd /opt/miniblog

            cat > .env <<EOF
            BACKEND_IMAGE_TAG=${_IMG_BACKEND}
            FRONTEND_BLOG_IMAGE_TAG=${_IMG_FE_BLOG}
            FRONTEND_ADMIN_IMAGE_TAG=${_IMG_FE_ADMIN}

            GIN_MODE=release

            MYSQL_HOST=${_MYSQL_HOST}
            MYSQL_PORT=${_MYSQL_PORT}
            MYSQL_DATABASE=${_MYSQL_DBNAME}
            MYSQL_USERNAME=${_MYSQL_USERNAME}
            MYSQL_PASSWORD=${_MYSQL_PASSWORD}

            REDIS_HOST=${_REDIS_HOST}
            REDIS_PORT=${_REDIS_PORT}
            REDIS_DB=${_REDIS_DB}
            REDIS_PASSWORD=${_REDIS_PASSWORD}

            JWT_SECRET=${_JWT_SECRET}

            FEISHU_DOCREADER_APPID=${_FEISHU_APPID}
            FEISHU_DOCREADER_APPSECRET=${_FEISHU_SECRET}
            EOF
            sudo chmod 600 .env

            sudo docker network inspect miniblog_net >/dev/null 2>&1 || sudo docker network create miniblog_net
            sudo mkdir -p /data/logs/miniblog/backend /data/logs/miniblog/frontend-blog /data/logs/miniblog/frontend-admin

            # ä½¿ç”¨ PAT ç™»å½• GHCRï¼ˆå¦‚æä¾›ï¼‰ï¼Œæ”¯æŒè‡ªå®šä¹‰ GHCR ç”¨æˆ·åï¼›å¦åˆ™è·³è¿‡ï¼ˆcompose ä¼šå°è¯•åŒ¿å/å·²æœ‰ç™»å½•ï¼‰
            if [ -n "${_GH_TOKEN}" ]; then
              DOCKER_USER="${_GHCR_USERNAME:-${_GH_USER}}"
              echo "${_GH_TOKEN}" | sudo docker login ghcr.io -u "${DOCKER_USER}" --password-stdin
            fi

            sudo docker compose -f docker-compose.yml -f docker-compose.prod.yml pull
            sudo docker compose -f docker-compose.yml -f docker-compose.prod.yml up -d

            sudo docker compose ps

  notify:
    name: Send Notification
    needs: [deploy]
    runs-on: ubuntu-latest
    if: always()
    steps:
      - name: Log deployment status
        run: |
          STATUS="${{ needs.deploy.result }}"
          if [ "$STATUS" = "success" ]; then
            echo "âœ… Deployment to production succeeded"
          elif [ "$STATUS" = "skipped" ]; then
            echo "â„¹ï¸ Deployment skipped (non-main push)"
          else
            echo "âŒ Deployment to production failed"
            exit 1
          fi
