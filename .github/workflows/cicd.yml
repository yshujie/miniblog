name: CI/CD (miniblog - simple A)

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      skip_tests:
        description: 'Skip unit tests'
        type: boolean
        default: false

permissions:
  contents: read
  packages: write   # push 到 GHCR 需要

env:
  BACKEND_IMAGE: ghcr.io/${{ github.repository_owner }}/miniblog-backend
  FE_BLOG_IMAGE: ghcr.io/${{ github.repository_owner }}/miniblog-frontend-blog
  FE_ADMIN_IMAGE: ghcr.io/${{ github.repository_owner }}/miniblog-frontend-admin
  TAG: ${{ github.sha }}

concurrency:
  group: miniblog-prod
  cancel-in-progress: false

jobs:
  build-and-deploy:
    runs-on: [self-hosted, macOS, ARM64]

    steps:
      - uses: actions/checkout@v4

      # ----(可选) 后端单元测试----
      - name: Setup Go
        if: ${{ !inputs.skip_tests }}
        uses: actions/setup-go@v5
        with:
          go-version: '1.24'
          cache: true
          cache-dependency-path: |
            go.sum
            go.work.sum

      - name: Run unit tests
        if: ${{ !inputs.skip_tests }}
        run: |
          [ -d "$HOME/go/pkg/mod" ] && chmod -R u+w "$HOME/go/pkg/mod" || true
          go mod download
          make test-backend

      # ---- Docker 构建并推送 GHCR（linux/amd64）----
      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GHCR_TOKEN }}

      - name: Build & Push backend
        uses: docker/build-push-action@v6
        with:
          context: .
          file: build/docker/miniblog/Dockerfile.prod.backend
          platforms: linux/amd64
          push: true
          build-args: |
            GOPROXY=https://goproxy.cn,direct
          tags: |
            ${{ env.BACKEND_IMAGE }}:${{ env.TAG }}
            ${{ env.BACKEND_IMAGE }}:latest

      - name: Build & Push frontend-blog
        uses: docker/build-push-action@v6
        with:
          context: .
          file: build/docker/miniblog/Dockerfile.prod.frontend.blog
          platforms: linux/amd64
          push: true
          tags: |
            ${{ env.FE_BLOG_IMAGE }}:${{ env.TAG }}
            ${{ env.FE_BLOG_IMAGE }}:latest

      - name: Build & Push frontend-admin
        uses: docker/build-push-action@v6
        with:
          context: .
          file: build/docker/miniblog/Dockerfile.prod.frontend.admin
          platforms: linux/amd64
          push: true
          tags: |
            ${{ env.FE_ADMIN_IMAGE }}:${{ env.TAG }}
            ${{ env.FE_ADMIN_IMAGE }}:latest

      # ---- 部署（方案 A：远端用户可直接运行 docker）----
      - name: Prepare SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.DEPLOY_SSH_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ secrets.SVRA_HOST }} >> ~/.ssh/known_hosts 2>/dev/null || true

      - name: Upload compose files and configs
        run: |
          REMOTE="${{ secrets.SVRA_USER }}@${{ secrets.SVRA_HOST }}"
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=yes "$REMOTE" "mkdir -p /opt/miniblog"
          scp -i ~/.ssh/deploy_key docker-compose.yml docker-compose.prod.yml "$REMOTE:/opt/miniblog/"
          scp -i ~/.ssh/deploy_key -r configs "$REMOTE:/opt/miniblog/"

      - name: Deploy on server
        env:
          BACKEND_TAG: ${{ env.BACKEND_IMAGE }}:${{ env.TAG }}
          FE_BLOG_TAG: ${{ env.FE_BLOG_IMAGE }}:${{ env.TAG }}
          FE_ADMIN_TAG: ${{ env.FE_ADMIN_IMAGE }}:${{ env.TAG }}
          GHCR_TOKEN: ${{ secrets.GHCR_TOKEN }}
          GHCR_USER: ${{ github.repository_owner }}
          MYSQL_HOST: ${{ secrets.MYSQL_HOST }}
          MYSQL_PORT: ${{ secrets.MYSQL_PORT }}
          MYSQL_DBNAME: ${{ secrets.MYSQL_DBNAME }}
          MYSQL_USERNAME: ${{ secrets.MYSQL_USERNAME }}
          MYSQL_PASSWORD: ${{ secrets.MYSQL_PASSWORD }}
          REDIS_HOST: ${{ secrets.REDIS_HOST }}
          REDIS_PORT: ${{ secrets.REDIS_PORT }}
          REDIS_DB: ${{ secrets.REDIS_DB }}
          REDIS_PASSWORD: ${{ secrets.REDIS_PASSWORD }}
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
          FEISHU_APPID: ${{ secrets.FEISHU_DOCREADER_APPID }}
          FEISHU_SECRET: ${{ secrets.FEISHU_DOCREADER_APPSECRET }}
        run: |
          REMOTE="${{ secrets.SVRA_USER }}@${{ secrets.SVRA_HOST }}"
          
          # 在本地准备 .env 内容
          cat > /tmp/miniblog.env << 'ENVEOF'
          BACKEND_IMAGE_TAG=${BACKEND_TAG}
          FRONTEND_BLOG_IMAGE_TAG=${FE_BLOG_TAG}
          FRONTEND_ADMIN_IMAGE_TAG=${FE_ADMIN_TAG}
          
          GIN_MODE=release
          
          MYSQL_HOST=${MYSQL_HOST}
          MYSQL_PORT=${MYSQL_PORT}
          MYSQL_DATABASE=${MYSQL_DBNAME}
          MYSQL_USERNAME=${MYSQL_USERNAME}
          MYSQL_PASSWORD=${MYSQL_PASSWORD}
          
          REDIS_HOST=${REDIS_HOST}
          REDIS_PORT=${REDIS_PORT}
          REDIS_DB=${REDIS_DB}
          REDIS_PASSWORD=${REDIS_PASSWORD}
          
          JWT_SECRET=${JWT_SECRET}
          
          FEISHU_DOCREADER_APPID=${FEISHU_APPID}
          FEISHU_DOCREADER_APPSECRET=${FEISHU_SECRET}
          ENVEOF
          
          # 用实际值替换变量
          sed -i '' \
            -e "s|\${BACKEND_TAG}|${BACKEND_TAG}|g" \
            -e "s|\${FE_BLOG_TAG}|${FE_BLOG_TAG}|g" \
            -e "s|\${FE_ADMIN_TAG}|${FE_ADMIN_TAG}|g" \
            -e "s|\${MYSQL_HOST}|${MYSQL_HOST}|g" \
            -e "s|\${MYSQL_PORT}|${MYSQL_PORT}|g" \
            -e "s|\${MYSQL_DBNAME}|${MYSQL_DBNAME}|g" \
            -e "s|\${MYSQL_USERNAME}|${MYSQL_USERNAME}|g" \
            -e "s|\${MYSQL_PASSWORD}|${MYSQL_PASSWORD}|g" \
            -e "s|\${REDIS_HOST}|${REDIS_HOST}|g" \
            -e "s|\${REDIS_PORT}|${REDIS_PORT}|g" \
            -e "s|\${REDIS_DB}|${REDIS_DB}|g" \
            -e "s|\${REDIS_PASSWORD}|${REDIS_PASSWORD}|g" \
            -e "s|\${JWT_SECRET}|${JWT_SECRET}|g" \
            -e "s|\${FEISHU_APPID}|${FEISHU_APPID}|g" \
            -e "s|\${FEISHU_SECRET}|${FEISHU_SECRET}|g" \
            /tmp/miniblog.env
          
          # 上传 .env 文件
          scp -i ~/.ssh/deploy_key /tmp/miniblog.env "$REMOTE:/opt/miniblog/.env"
          rm -f /tmp/miniblog.env
          
          # 执行部署
          ssh -i ~/.ssh/deploy_key "$REMOTE" bash -s <<DEPLOY_SCRIPT
          set -euo pipefail

          APP_DIR=/opt/miniblog
          cd "\$APP_DIR"

          # 创建必要的网络
          docker network inspect miniblog_net >/dev/null 2>&1 || docker network create miniblog_net

          # 创建必要的目录
          mkdir -p /data/logs/miniblog/backend /data/logs/miniblog/frontend-blog /data/logs/miniblog/frontend-admin

          # GHCR 登录
          echo "${GHCR_TOKEN}" | docker login ghcr.io -u "${GHCR_USER}" --password-stdin

          # 拉取并启动
          docker compose -f docker-compose.yml -f docker-compose.prod.yml pull
          docker compose -f docker-compose.yml -f docker-compose.prod.yml up -d

          # 健康检查
          echo "等待服务启动..."
          sleep 10
          
          # 检查后端健康
          if curl -fsS http://localhost:8090/health >/dev/null 2>&1; then
            echo "✅ 后端服务健康"
          else
            echo "⚠️  后端服务未就绪"
          fi

          # 查看状态
          docker compose ps
          DEPLOY_SCRIPT

      - name: Cleanup SSH key
        if: always()
        run: rm -f ~/.ssh/deploy_key
