name: CI/CD (miniblog - simple A)

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      skip_tests:
        description: 'Skip unit tests'
        type: boolean
        default: false

permissions:
  contents: read
  packages: write   # push 到 GHCR 需要

env:
  BACKEND_IMAGE: ghcr.io/${{ github.repository_owner }}/miniblog-backend
  FE_BLOG_IMAGE: ghcr.io/${{ github.repository_owner }}/miniblog-frontend-blog
  FE_ADMIN_IMAGE: ghcr.io/${{ github.repository_owner }}/miniblog-frontend-admin
  TAG: ${{ github.sha }}

concurrency:
  group: miniblog-prod
  cancel-in-progress: false

jobs:
  build-and-deploy:
    runs-on: [self-hosted, macOS, ARM64]

    steps:
      - uses: actions/checkout@v4

      # ----(可选) 后端单元测试----
      - name: Setup Go
        if: ${{ !inputs.skip_tests }}
        uses: actions/setup-go@v5
        with:
          go-version: '1.24'
          cache: true
          cache-dependency-path: |
            go.sum
            go.work.sum

      - name: Run unit tests
        if: ${{ !inputs.skip_tests }}
        run: |
          [ -d "$HOME/go/pkg/mod" ] && chmod -R u+w "$HOME/go/pkg/mod" || true
          go mod download
          make test-backend

      # ---- Docker 构建并推送 GHCR（linux/amd64）----
      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GHCR_TOKEN }}

      - name: Build & Push backend
        uses: docker/build-push-action@v6
        with:
          context: .
          file: build/docker/miniblog/Dockerfile.prod.backend
          platforms: linux/amd64
          push: true
          build-args: |
            GOPROXY=https://goproxy.cn,direct
          tags: |
            ${{ env.BACKEND_IMAGE }}:${{ env.TAG }}
            ${{ env.BACKEND_IMAGE }}:latest

      - name: Build & Push frontend-blog
        uses: docker/build-push-action@v6
        with:
          context: .
          file: build/docker/miniblog/Dockerfile.prod.frontend.blog
          platforms: linux/amd64
          push: true
          tags: |
            ${{ env.FE_BLOG_IMAGE }}:${{ env.TAG }}
            ${{ env.FE_BLOG_IMAGE }}:latest

      - name: Build & Push frontend-admin
        uses: docker/build-push-action@v6
        with:
          context: .
          file: build/docker/miniblog/Dockerfile.prod.frontend.admin
          platforms: linux/amd64
          push: true
          tags: |
            ${{ env.FE_ADMIN_IMAGE }}:${{ env.TAG }}
            ${{ env.FE_ADMIN_IMAGE }}:latest

      # ---- 部署（方案 A：远端用户可直接运行 docker）----
      - name: Prepare SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.DEPLOY_SSH_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ secrets.SVRA_HOST }} >> ~/.ssh/known_hosts 2>/dev/null || true

      - name: Upload compose files
        run: |
          REMOTE="${{ secrets.SVRA_USER }}@${{ secrets.SVRA_HOST }}"
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=yes "$REMOTE" "mkdir -p /opt/miniblog"
          scp -i ~/.ssh/deploy_key docker-compose.yml docker-compose.prod.yml "$REMOTE:/opt/miniblog/"

      - name: Deploy on server
        env:
          _IMG_BACKEND: ${{ env.BACKEND_IMAGE }}:${{ env.TAG }}
          _IMG_FE_BLOG: ${{ env.FE_BLOG_IMAGE }}:${{ env.TAG }}
          _IMG_FE_ADMIN: ${{ env.FE_ADMIN_IMAGE }}:${{ env.TAG }}
          _GH_USER: ${{ github.repository_owner }}
          _GH_TOKEN: ${{ secrets.GHCR_TOKEN }}
        run: |
          REMOTE="${{ secrets.SVRA_USER }}@${{ secrets.SVRA_HOST }}"
          ssh -i ~/.ssh/deploy_key "$REMOTE" 'bash -s' <<'EOSSH'
          set -euo pipefail

          APP_DIR=/opt/miniblog
          cd "$APP_DIR"

          # 写 .env（仅运行态配置）
          cat > .env <<EOF
          BACKEND_IMAGE_TAG=${_IMG_BACKEND}
          FRONTEND_BLOG_IMAGE_TAG=${_IMG_FE_BLOG}
          FRONTEND_ADMIN_IMAGE_TAG=${_IMG_FE_ADMIN}

          GIN_MODE=release

          MYSQL_HOST=${{ secrets.MYSQL_HOST }}
          MYSQL_PORT=${{ secrets.MYSQL_PORT }}
          MYSQL_DATABASE=${{ secrets.MYSQL_DBNAME }}
          MYSQL_USERNAME=${{ secrets.MYSQL_USERNAME }}
          MYSQL_PASSWORD=${{ secrets.MYSQL_PASSWORD }}

          REDIS_HOST=${{ secrets.REDIS_HOST }}
          REDIS_PORT=${{ secrets.REDIS_PORT }}
          REDIS_DB=${{ secrets.REDIS_DB }}
          REDIS_PASSWORD=${{ secrets.REDIS_PASSWORD }}

          JWT_SECRET=${{ secrets.JWT_SECRET }}

          FEISHU_DOCREADER_APPID=${{ secrets.FEISHU_DOCREADER_APPID }}
          FEISHU_DOCREADER_APPSECRET=${{ secrets.FEISHU_DOCREADER_APPSECRET }}
          EOF

          # GHCR 登录（无需 sudo；deploy 用户需在 docker 组）
          echo "${_GH_TOKEN}" | docker login ghcr.io -u "${_GH_USER}" --password-stdin

          # 拉取并启动
          docker compose -f docker-compose.yml -f docker-compose.prod.yml pull
          docker compose -f docker-compose.yml -f docker-compose.prod.yml up -d

          # 可选：查看状态
          docker compose ps
          EOSSH

      - name: Cleanup SSH key
        if: always()
        run: rm -f ~/.ssh/deploy_key
