name: CI/CD (miniblog - production)

on:
  push:
    branches: [main]
  workflow_dispatch:
    inputs:
      skip_tests:
        description: 'Skip tests'
        type: boolean
        default: false

permissions:
  contents: read
  packages: write

env:
  BACKEND_IMAGE: ghcr.io/${{ github.repository_owner }}/miniblog-backend
  FE_BLOG_IMAGE: ghcr.io/${{ github.repository_owner }}/miniblog-frontend-blog
  FE_ADMIN_IMAGE: ghcr.io/${{ github.repository_owner }}/miniblog-frontend-admin
  TAG: ${{ github.sha }}

concurrency:
  group: miniblog-prod
  cancel-in-progress: false

jobs:
  # ========================================
  # Job 1: 测试阶段（临时禁用以加快 CI/CD 测试）
  # ========================================
  test:
    name: Run Tests
    runs-on: [self-hosted, macOS, ARM64]
    if: false  # 临时禁用

    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-go@v5
        with:
          go-version: '1.24'
          cache: true
          cache-dependency-path: |
            go.sum
            go.work.sum
      - name: Fix Go module cache permissions
        run: |
          [ -d "$HOME/go/pkg/mod" ] && chmod -R u+w "$HOME/go/pkg/mod" || true
      - name: Download dependencies
        run: go mod download
      - name: Run unit tests
        run: make test-backend

  # ========================================
  # Job 2: 构建后端镜像
  # ========================================
  build-backend:
    name: Build Backend Image
    runs-on: [self-hosted, macOS, ARM64]
    needs: test
    if: always() && (needs.test.result == 'success' || needs.test.result == 'skipped')
    env:
      # 关键：让 Docker 使用工作目录下的临时配置，绕过 macOS Keychain
      DOCKER_CONFIG: ${{ github.workspace }}/.docker-ci

    steps:
      - uses: actions/checkout@v4

      - uses: docker/setup-qemu-action@v3
      - uses: docker/setup-buildx-action@v3

      - name: Prepare temp Docker config (no keychain)
        run: |
          mkdir -p "$DOCKER_CONFIG"
          echo '{"auths":{}}' > "$DOCKER_CONFIG/config.json"

      - name: Login to GHCR (via GITHUB_TOKEN)
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
          logout: false

      - name: Build & Push backend
        uses: docker/build-push-action@v6
        with:
          context: .
          file: build/docker/miniblog/Dockerfile.prod.backend
          platforms: linux/amd64
          push: true
          build-args: |
            GOPROXY=https://goproxy.cn,direct
          tags: |
            ${{ env.BACKEND_IMAGE }}:${{ env.TAG }}
            ${{ env.BACKEND_IMAGE }}:latest

      - name: Cleanup temp Docker config
        if: always()
        run: rm -rf "$DOCKER_CONFIG"

  # ========================================
  # Job 3: 构建前端镜像（并行）
  # ========================================
  build-frontends:
    name: Build Frontend Images
    runs-on: [self-hosted, macOS, ARM64]
    needs: test
    if: always() && (needs.test.result == 'success' || needs.test.result == 'skipped')
    env:
      DOCKER_CONFIG: ${{ github.workspace }}/.docker-ci

    steps:
      - uses: actions/checkout@v4

      - uses: docker/setup-qemu-action@v3
      - uses: docker/setup-buildx-action@v3

      - name: Prepare temp Docker config (no keychain)
        run: |
          mkdir -p "$DOCKER_CONFIG"
          echo '{"auths":{}}' > "$DOCKER_CONFIG/config.json"

      - name: Login to GHCR (via GITHUB_TOKEN)
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
          logout: false

      - name: Build & Push frontend-blog
        uses: docker/build-push-action@v6
        with:
          context: .
          file: build/docker/miniblog/Dockerfile.prod.frontend.blog
          platforms: linux/amd64
          push: true
          tags: |
            ${{ env.FE_BLOG_IMAGE }}:${{ env.TAG }}
            ${{ env.FE_BLOG_IMAGE }}:latest

      - name: Build & Push frontend-admin
        uses: docker/build-push-action@v6
        with:
          context: .
          file: build/docker/miniblog/Dockerfile.prod.frontend.admin
          platforms: linux/amd64
          push: true
          tags: |
            ${{ env.FE_ADMIN_IMAGE }}:${{ env.TAG }}
            ${{ env.FE_ADMIN_IMAGE }}:latest

      - name: Cleanup temp Docker config
        if: always()
        run: rm -rf "$DOCKER_CONFIG"

  # ========================================
  # Job 4: 部署到生产环境
  # ========================================
  deploy:
    name: Deploy to Production
    runs-on: [self-hosted, macOS, ARM64]
    needs: [build-backend, build-frontends]

    steps:
      - uses: actions/checkout@v4

      - name: Prepare SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.DEPLOY_SSH_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ secrets.SVRA_HOST }} >> ~/.ssh/known_hosts 2>/dev/null || true

      - name: Upload compose files
        run: |
          REMOTE="${{ secrets.SVRA_USER }}@${{ secrets.SVRA_HOST }}"
          ssh -i ~/.ssh/deploy_key "$REMOTE" "mkdir -p /opt/miniblog"
          scp -i ~/.ssh/deploy_key docker-compose.yml docker-compose.prod.yml "$REMOTE:/opt/miniblog/"

      - name: Deploy on server
        env:
          _IMG_BACKEND: ${{ env.BACKEND_IMAGE }}:${{ env.TAG }}
          _IMG_FE_BLOG: ${{ env.FE_BLOG_IMAGE }}:${{ env.TAG }}
          _IMG_FE_ADMIN: ${{ env.FE_ADMIN_IMAGE }}:${{ env.TAG }}
          _GH_USER: ${{ github.repository_owner }}
          _GH_TOKEN: ${{ secrets.GHCR_TOKEN }}   # 服务器用 PAT；GITHUB_TOKEN 不可用
          _MYSQL_HOST: ${{ secrets.MYSQL_HOST }}
          _MYSQL_PORT: ${{ secrets.MYSQL_PORT }}
          _MYSQL_DBNAME: ${{ secrets.MYSQL_DBNAME }}
          _MYSQL_USERNAME: ${{ secrets.MYSQL_USERNAME }}
          _MYSQL_PASSWORD: ${{ secrets.MYSQL_PASSWORD }}
          _REDIS_HOST: ${{ secrets.REDIS_HOST }}
          _REDIS_PORT: ${{ secrets.REDIS_PORT }}
          _REDIS_DB: ${{ secrets.REDIS_DB }}
          _REDIS_PASSWORD: ${{ secrets.REDIS_PASSWORD }}
          _JWT_SECRET: ${{ secrets.JWT_SECRET }}
          _FEISHU_APPID: ${{ secrets.FEISHU_DOCREADER_APPID }}
          _FEISHU_SECRET: ${{ secrets.FEISHU_DOCREADER_APPSECRET }}
        run: |
          REMOTE="${{ secrets.SVRA_USER }}@${{ secrets.SVRA_HOST }}"
          ssh -i ~/.ssh/deploy_key "$REMOTE" bash -s <<'EOSSH'
          set -euo pipefail
          cd /opt/miniblog

          # 生成 .env 文件（Actions 已展开变量）
          cat > .env <<EOF
          BACKEND_IMAGE_TAG=${_IMG_BACKEND}
          FRONTEND_BLOG_IMAGE_TAG=${_IMG_FE_BLOG}
          FRONTEND_ADMIN_IMAGE_TAG=${_IMG_FE_ADMIN}

          GIN_MODE=release

          MYSQL_HOST=${_MYSQL_HOST}
          MYSQL_PORT=${_MYSQL_PORT}
          MYSQL_DATABASE=${_MYSQL_DBNAME}
          MYSQL_USERNAME=${_MYSQL_USERNAME}
          MYSQL_PASSWORD=${_MYSQL_PASSWORD}

          REDIS_HOST=${_REDIS_HOST}
          REDIS_PORT=${_REDIS_PORT}
          REDIS_DB=${_REDIS_DB}
          REDIS_PASSWORD=${_REDIS_PASSWORD}

          JWT_SECRET=${_JWT_SECRET}

          FEISHU_DOCREADER_APPID=${_FEISHU_APPID}
          FEISHU_DOCREADER_APPSECRET=${_FEISHU_SECRET}
          EOF

          # 创建必要的网络和目录
          sudo docker network inspect miniblog_net >/dev/null 2>&1 || sudo docker network create miniblog_net
          sudo mkdir -p /data/logs/miniblog/backend /data/logs/miniblog/frontend-blog /data/logs/miniblog/frontend-admin

          # GHCR 登录（Linux 主机，不牵扯 Keychain）
          echo "${_GH_TOKEN}" | sudo docker login ghcr.io -u "${_GH_USER}" --password-stdin

          # 拉取&滚更
          sudo docker compose -f docker-compose.yml -f docker-compose.prod.yml pull
          sudo docker compose -f docker-compose.yml -f docker-compose.prod.yml up -d

          sudo docker compose ps
          EOSSH

      - name: Cleanup
        if: always()
        run: rm -f ~/.ssh/deploy_key
