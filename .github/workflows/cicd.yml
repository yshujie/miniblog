name: CI/CD (miniblog - production)

on:
  push:
    branches: [main]
  workflow_dispatch:
    inputs:
      skip_tests:
        description: 'Skip tests'
        type: boolean
        default: false

permissions:
  contents: read
  packages: write

env:
  BACKEND_IMAGE: ghcr.io/${{ github.repository_owner }}/miniblog-backend
  FE_BLOG_IMAGE: ghcr.io/${{ github.repository_owner }}/miniblog-frontend-blog
  FE_ADMIN_IMAGE: ghcr.io/${{ github.repository_owner }}/miniblog-frontend-admin
  TAG: ${{ github.sha }}

concurrency:
  group: miniblog-prod
  cancel-in-progress: false

jobs:
  # ========================================
  # Job 1: 测试阶段（临时禁用）
  # ========================================
  test:
    name: Run Tests
    runs-on: [self-hosted, macOS, ARM64]
    if: false

    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-go@v5
        with:
          go-version: '1.24'
          cache: true
          cache-dependency-path: |
            go.sum
            go.work.sum
      - name: Fix Go module cache permissions
        run: |
          [ -d "$HOME/go/pkg/mod" ] && chmod -R u+w "$HOME/go/pkg/mod" || true
      - run: go mod download
      - run: make test-backend

  # ========================================
  # Job 2: 构建后端镜像
  # ========================================
  build-backend:
    name: Build Backend Image
    runs-on: [self-hosted, macOS, ARM64]
    needs: test
    if: always() && (needs.test.result == 'success' || needs.test.result == 'skipped')
    env:
      # 用本仓库里的临时 Docker 配置，避免读取/写入 macOS Keychain
      DOCKER_CONFIG: ${{ github.workspace }}/.docker-ci

    steps:
      - uses: actions/checkout@v4

      - uses: docker/setup-qemu-action@v3
        with:
          cache-image: false

      - uses: docker/setup-buildx-action@v3
        with:
          install: true     # 安装 buildx 插件，避免后续 post 阶段告警
          cleanup: false    # 保留到作业结束

      # 强制把 Dockerfile 的 syntax 指令替换为 local，避免访问 docker/dockerfile:1.x
      - name: Force Dockerfile syntax=local (backend)
        run: |
          f="build/docker/miniblog/Dockerfile.prod.backend"
          if [ -f "$f" ]; then
            if head -n1 "$f" | grep -q '^# syntax='; then
              sed -i '' -e '1s|^# syntax=.*|# syntax=local|' "$f"
            else
              sed -i '' '1s;^;# syntax=local\n;' "$f"
            fi
          fi

      - name: Prepare temp Docker config (no keychain)
        run: |
          mkdir -p "$DOCKER_CONFIG"
          cat > "$DOCKER_CONFIG/config.json" <<'JSON'
          {
            "auths": {},
            "credsStore": "",
            "credHelpers": {
              "docker.io": "",
              "ghcr.io": ""
            }
          }
          JSON

      - name: Set registry auth for GHCR (via GITHUB_TOKEN)
        env:
          USER:  ${{ github.actor }}
          TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          AUTH=$(printf '%s:%s' "$USER" "$TOKEN" | base64 | tr -d '\n')
          {
            echo 'DOCKER_AUTH_CONFIG<<EOF'
            # 同样写入 credsStore/credHelpers，保证 buildx 转发给 buildkit 后也不触发 Keychain
            echo "{\"auths\": {\"ghcr.io\": {\"auth\": \"$AUTH\"}}, \"credsStore\": \"\", \"credHelpers\": {\"docker.io\": \"\", \"ghcr.io\": \"\"}}"
            echo 'EOF'
          } >> "$GITHUB_ENV"

      - name: Build & Push backend
        uses: docker/build-push-action@v6
        env:
          DOCKER_CONFIG: ${{ env.DOCKER_CONFIG }}
        with:
          context: .
          file: build/docker/miniblog/Dockerfile.prod.backend
          platforms: linux/amd64
          push: true
          build-args: |
            GOPROXY=https://goproxy.cn,direct
          tags: |
            ${{ env.BACKEND_IMAGE }}:${{ env.TAG }}
            ${{ env.BACKEND_IMAGE }}:latest
          # 可选缓存
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Cleanup temp Docker config
        if: always()
        run: rm -rf "$DOCKER_CONFIG"

  # ========================================
  # Job 3: 构建前端镜像（并行）
  # ========================================
  build-frontends:
    name: Build Frontend Images
    runs-on: [self-hosted, macOS, ARM64]
    needs: test
    if: always() && (needs.test.result == 'success' || needs.test.result == 'skipped')
    env:
      DOCKER_CONFIG: ${{ github.workspace }}/.docker-ci

    steps:
      - uses: actions/checkout@v4

      - uses: docker/setup-qemu-action@v3
        with:
          cache-image: false

      - uses: docker/setup-buildx-action@v3
        with:
          install: true
          cleanup: false

      # 强制把两个前端 Dockerfile 的 syntax 置为 local
      - name: Force Dockerfile syntax=local (frontends)
        run: |
          for f in build/docker/miniblog/Dockerfile.prod.frontend.blog build/docker/miniblog/Dockerfile.prod.frontend.admin; do
            if [ -f "$f" ]; then
              if head -n1 "$f" | grep -q '^# syntax='; then
                sed -i '' -e '1s|^# syntax=.*|# syntax=local|' "$f"
              else
                sed -i '' '1s;^;# syntax=local\n;' "$f"
              fi
            fi
          done

      - name: Prepare temp Docker config (no keychain)
        run: |
          mkdir -p "$DOCKER_CONFIG"
          cat > "$DOCKER_CONFIG/config.json" <<'JSON'
          {
            "auths": {},
            "credsStore": "",
            "credHelpers": {
              "docker.io": "",
              "ghcr.io": ""
            }
          }
          JSON

      - name: Set registry auth for GHCR (via GITHUB_TOKEN)
        env:
          USER:  ${{ github.actor }}
          TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          AUTH=$(printf '%s:%s' "$USER" "$TOKEN" | base64 | tr -d '\n')
          {
            echo 'DOCKER_AUTH_CONFIG<<EOF'
            echo "{\"auths\": {\"ghcr.io\": {\"auth\": \"$AUTH\"}}, \"credsStore\": \"\", \"credHelpers\": {\"docker.io\": \"\", \"ghcr.io\": \"\"}}"
            echo 'EOF'
          } >> "$GITHUB_ENV"

      - name: Build & Push frontend-blog
        uses: docker/build-push-action@v6
        env:
          DOCKER_CONFIG: ${{ env.DOCKER_CONFIG }}
        with:
          context: .
          file: build/docker/miniblog/Dockerfile.prod.frontend.blog
          platforms: linux/amd64
          push: true
          tags: |
            ${{ env.FE_BLOG_IMAGE }}:${{ env.TAG }}
            ${{ env.FE_BLOG_IMAGE }}:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Build & Push frontend-admin
        uses: docker/build-push-action@v6
        env:
          DOCKER_CONFIG: ${{ env.DOCKER_CONFIG }}
        with:
          context: .
          file: build/docker/miniblog/Dockerfile.prod.frontend.admin
          platforms: linux/amd64
          push: true
          tags: |
            ${{ env.FE_ADMIN_IMAGE }}:${{ env.TAG }}
            ${{ env.FE_ADMIN_IMAGE }}:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Cleanup temp Docker config
        if: always()
        run: rm -rf "$DOCKER_CONFIG"

  # ========================================
  # Job 4: 部署到生产环境
  # ========================================
  deploy:
    name: Deploy to Production
    runs-on: [self-hosted, macOS, ARM64]
    needs: [build-backend, build-frontends]

    steps:
      - uses: actions/checkout@v4

      - name: Prepare SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.DEPLOY_SSH_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ secrets.SVRA_HOST }} >> ~/.ssh/known_hosts 2>/dev/null || true

      - name: Upload compose files
        run: |
          REMOTE="${{ secrets.SVRA_USER }}@${{ secrets.SVRA_HOST }}"
          ssh -i ~/.ssh/deploy_key "$REMOTE" "mkdir -p /opt/miniblog"
          scp -i ~/.ssh/deploy_key docker-compose.yml docker-compose.prod.yml "$REMOTE:/opt/miniblog/"

      - name: Deploy on server
        env:
          _IMG_BACKEND: ${{ env.BACKEND_IMAGE }}:${{ env.TAG }}
          _IMG_FE_BLOG: ${{ env.FE_BLOG_IMAGE }}:${{ env.TAG }}
          _IMG_FE_ADMIN: ${{ env.FE_ADMIN_IMAGE }}:${{ env.TAG }}
          _GH_USER: ${{ github.repository_owner }}
          _GH_TOKEN: ${{ secrets.GHCR_TOKEN }}
          _MYSQL_HOST: ${{ secrets.MYSQL_HOST }}
          _MYSQL_PORT: ${{ secrets.MYSQL_PORT }}
          _MYSQL_DBNAME: ${{ secrets.MYSQL_DBNAME }}
          _MYSQL_USERNAME: ${{ secrets.MYSQL_USERNAME }}
          _MYSQL_PASSWORD: ${{ secrets.MYSQL_PASSWORD }}
          _REDIS_HOST: ${{ secrets.REDIS_HOST }}
          _REDIS_PORT: ${{ secrets.REDIS_PORT }}
          _REDIS_DB: ${{ secrets.REDIS_DB }}
          _REDIS_PASSWORD: ${{ secrets.REDIS_PASSWORD }}
          _JWT_SECRET: ${{ secrets.JWT_SECRET }}
          _FEISHU_APPID: ${{ secrets.FEISHU_DOCREADER_APPID }}
          _FEISHU_SECRET: ${{ secrets.FEISHU_DOCREADER_APPSECRET }}
        run: |
          REMOTE="${{ secrets.SVRA_USER }}@${{ secrets.SVRA_HOST }}"
          ssh -i ~/.ssh/deploy_key "$REMOTE" bash -s <<'EOSSH'
          set -euo pipefail
          cd /opt/miniblog

          cat > .env <<EOF
          BACKEND_IMAGE_TAG=${_IMG_BACKEND}
          FRONTEND_BLOG_IMAGE_TAG=${_IMG_FE_BLOG}
          FRONTEND_ADMIN_IMAGE_TAG=${_IMG_FE_ADMIN}

          GIN_MODE=release

          MYSQL_HOST=${_MYSQL_HOST}
          MYSQL_PORT=${_MYSQL_PORT}
          MYSQL_DATABASE=${_MYSQL_DBNAME}
          MYSQL_USERNAME=${_MYSQL_USERNAME}
          MYSQL_PASSWORD=${_MYSQL_PASSWORD}

          REDIS_HOST=${_REDIS_HOST}
          REDIS_PORT=${_REDIS_PORT}
          REDIS_DB=${_REDIS_DB}
          REDIS_PASSWORD=${_REDIS_PASSWORD}

          JWT_SECRET=${_JWT_SECRET}

          FEISHU_DOCREADER_APPID=${_FEISHU_APPID}
          FEISHU_DOCREADER_APPSECRET=${_FEISHU_SECRET}
          EOF

          sudo docker network inspect miniblog_net >/dev/null 2>&1 || sudo docker network create miniblog_net
          sudo mkdir -p /data/logs/miniblog/backend /data/logs/miniblog/frontend-blog /data/logs/miniblog/frontend-admin

          echo "${_GH_TOKEN}" | sudo docker login ghcr.io -u "${_GH_USER}" --password-stdin

          sudo docker compose -f docker-compose.yml -f docker-compose.prod.yml pull
          sudo docker compose -f docker-compose.yml -f docker-compose.prod.yml up -d

          sudo docker compose ps
          EOSSH

      - name: Cleanup
        if: always()
        run: rm -f ~/.ssh/deploy_key
