INSERT INTO miniblog.article (id, title, content, external_link, section_code, author, tags, pos, status, created_at, updated_at) VALUES (573483961993409070, '事件风暴实践指南：以事件为中心的业务建模方法', '# 事件风暴

事件风暴通过**业务人员与技术人员一同协作，**以**业务事件为核心出发点**，逐步识别**领域事件**（Event）、**触发事件的命令**（Command）、与事件相关的关键**领域概念（领域名词）**，从而**捕获行为需求、挖掘领域知识、补全需求细节、形成统一语言**的工具。

注意，事件风暴的核心视角是**以事件为中心，**事件风暴强调协作式、互动式、可视化的探索过程。



#### **事件风暴有什么作用呢？**

- 事件风暴可以帮助领域专家和技术人员建立统一的领域语言，达成共同想象。

- 事件风暴提供了对业务流程的直观理解，便于发现隐藏的业务需求和约束。

- 事件风暴明确了领域模型的边界（Bounded Context）和领域模型中关键元素之间的关系，为下一步设计领域模型提供基础。



#### **事件风暴的流程步骤：**

- 确定业务目标、明确业务范围

- 识别领域事件

- 识别命令

- 识别领域名词



##### **步骤一：确定业务目标、明确业务范围。**

明确业务目标的目的，是明确为什么要进行此次事件风暴，团队希望通过此次活动解决哪些问题、澄清哪些需求或知识。

明确业务范围的目的，是明确此次事件风暴具体关注哪些业务场景或问题范围，以避免讨论漫无边界或走偏话题。

这一阶段通常会产生一个明确且简短的“业务目标与范围定义”文档或说明，例如：

| **项目** | **描述** |
| --- | --- |
| **活动目的** | 明确订单处理流程，形成统一语言和清晰的业务模型 |
| **具体关注范围** | 用户支付成功后，到商品出库发货完成这一段业务 |
| **主要参与人员** | 业务专家、产品经理、架构师、开发负责人 |



##### **步骤二：识别领域事件**

**领域事件（Domain Event）**的本质是**业务流程中每个步骤所引发的结果或状态变化**，以完成式“已\\*\\*\\*”命名，如“订单已提交”、“商品已发货”、“订单已完成”等。



这里要注意：

- 描述领域事件时要与业务方统一语言，命名时，优先使用约定俗成的业务术语。

- 领域事件必须有实际业务含义和价值，应关注实际发生的、值得记录和通知的事件，技术事件、查询功能都不属于领域事件。

- 识别领域事件也要注意分离关注点。



领域事件的核心特征：

- **业务重要性**：事件必须对业务产生实质的影响或改变。

- **发生于过去**：事件应该表明业务步骤已完成。

- **明确清晰**：描述的事件应该让业务人员和技术人员都明确发生了什么。



那么如何识别呢？

- 识别领域事件要领域专家与技术人员一起协作，通过头脑风暴识别事件。

- 识别领域事件时要使用可视化工具（如便利贴）记录，促进互动讨论。

- 在识别领域事件过程中，不断筛选、合并、澄清事件，逐步达成对业务的统一认知。

注意，识别领域事件的过程，是领域专家和技术人员反复进行头脑风暴，逐步绘制业务流程、描述业务细节的过程，协作是第一要义。



**领域事件示例：**

<table><tbody>
<tr>
<td>

**好的领域事件 ✅**

</td>
<td>

**不合适的领域事件 ❌**

</td>
</tr>
<tr>
<td>

用户已注册

</td>
<td>

数据保存成功

</td>
</tr>
<tr>
<td>

订单已提交

</td>
<td>

接口已调用

</td>
</tr>
<tr>
<td>

订单已支付

</td>
<td>

日志已记录

</td>
</tr>
<tr>
<td>

库存已减少

</td>
<td>

查询订单状态成功

</td>
</tr>
</tbody></table>



##### **步骤三：事件风暴 \\- 识别命令**

命令（Command）就是触发领域事件的行为操作，包括行为的操作人角色、操作、需要查询的数据。



识别命令有什么作用呢？

- 在领域建模过程中，可以通过对命令的走查，细化和验证领域模型。

- 在实现层面，一个命令可能代表前端的一个操作，或后端的一个接口。



**命令表达常用方式：**

- 以动宾结构命名，如“提交订单”、“支付订单”、“更新库存”

<table><tbody>
<tr>
<td>

命令示例

</td>
<td>

引发的领域事件示例

</td>
</tr>
<tr>
<td>

提交订单

</td>
<td>

订单已提交

</td>
</tr>
<tr>
<td>

支付订单

</td>
<td>

订单已支付

</td>
</tr>
<tr>
<td>

发货

</td>
<td>

商品已发货

</td>
</tr>
</tbody></table>



##### **步骤四：识别领域名词**

**从领域事件、命令和业务流程中发现的重要名词性概念，**这些概念应该对业务人员清晰易懂，便于沟通。



识别领域名词（或领域概念）的最终目的是**要找到领域模型中的对象，**而**领域名词（领域概念）不一定是最终的领域对象**，很多时候需要进行合并/拆解后，才可以抽象出合适的领域对象。



**领域名词示例：**

- “订单”、“支付”、“商品”、“购物车”、“库存”等都是清晰明确的领域概念。

- 技术专有名词不属于业务核心领域概念（如：“数据库记录”、“缓存”）。



以上，就是我对事件风暴的认知。

', 'https://vdbapmvz0i.feishu.cn/docx/ZYaUdZWr1o8u27xcgp8cEZrFnYf?from=from_copylink', 'analysis', 'clack', '领域事件,领域命令,领域名词', 2, 2, '2025-06-18 14:43:12', '2025-08-12 14:13:12');
INSERT INTO miniblog.article (id, title, content, external_link, section_code, author, tags, pos, status, created_at, updated_at) VALUES (573483962110849582, '分层架构全景解析：从单体到领域驱动的演进之路', '# 分层架构 

### 定义：

分层架构是以**分离关注点 **[**MEMO**](https://v.flomoapp.com/mine/?memo_id=NTQxNzE1Mg)** **为原则，将系统**按照功能和职责划进行多层划分，并分别进行实现**的一种设计理念。

分层架构通过系统层次的划分和独立实现，极大的提高了每一层内部的内聚性，降低了层与层之间的耦合性，也是**“高内聚、低耦合“**设计原则的典型体现**。**

分层架构也是在软件开发领域对“**分而治之**“思想的运用，即将一个复杂问题拆分为多个小问题，分别解决后再整合到一起，从而解决整个大问题。



### **发展历程：**

- **单体结构**阶段（软件开发的早期）

    - 表现：没有明确的职责划分，几乎所有的用户操作、业务逻辑、数据存储代码都庞杂的堆砌在一起。

    - 问题：更改用户操作时可能影响业务逻辑、更改业务逻辑时又可能导致数据存储出问题，导致系统维护异常困难。

- **MVC 分层架构**

    - Martin Fowler 在《企业应用架构模式》中大力推广 **MVC 分层架构**，提倡将**用户界面层（View）、业务逻辑层（Model/Controller）和数据存储（Data Access Layer）层相分离**，有效解决单体结构的高耦合问题。

- **分离领域**

    - Eric Evans 在领域驱动设计中进一步提出了 **分离领域** 的设计思想，**强调领域层（Domain Layer）作为系统的核心，专注于表达业务逻辑和领域知识，并严格独立于基础设施层、应用服务层**，以更好的应对复杂业务场景的建模。



### **优点\\&amp;作用：**

- 分层架构的设计，**使得层级内部更有内聚性，并只依赖下层**。

- 不同的层级是为了描述不同的问题，且以不同的速度发展，所以**层级之间具有低耦合性**，使得层级更清楚，更容易维护。



### **抽象化实现：**

分层架构示意图：

- 分层架构将代码**分成若干层**，**每层负责不同的关注点**；

- 箭头标识依赖关系，**外层只能依赖内层，内层不能依赖外层**；

    - 这表明软件架构中的一个重要原则：**代码中不稳定的部分，应该依赖稳定的部分**；

    - 所以分层架构中越是内层越稳定，越是外层越容易变化。

|  |  |
| --- | --- |



### **MVC 分层架构实现**

MVC 分层架构是在软件开发中，以**分离关注点**为核心设计原则，通过划分出业务逻辑（Model）、用户界面（View）、用户交互控制（Controller）三个核心职责，来降低系统耦合度，提高系统可维护性、可扩展性的架构设计。



在企业级应用开发中，通常基于经典的 MVC 架构，还会独立出数据访问层（Data Access Layer / DAO），以便于更清楚的隔离业务逻辑和数据访问的依赖关系。



#### 发展历程：

- 经典 MVC 架构

    - **提出者**：Trygve Reenskaug 于 1979 年提出

    - 应用领域：最初用于桌面应用的用户界面设计

    - 具体描述：

        - **Model（模型层）**

            - 负责管理和维护应用程序的业务逻辑与业务数据。

        - **View（视图层）**

            - 负责用户界面的显示，接收用户输入，向用户呈现数据。

        - **Controller（控制器层）**

            - 接受用户输入事件，调用 Model 层处理业务逻辑，并更新视图，起到 Model 与 View 间的协调和控制作用。

    - **特点**： 经典 MVC 的 Model 层通常涵盖了业务逻辑和数据访问逻辑，没有单独的数据访问层概念。

- Martin Fowler 提出的企业级三层架构（对经典 MVC 的扩展）

    - **提出者**：Martin Fowler 于 2002 年在《企业应用架构模式》中提出

    - **应用领域**：企业级应用架构设计

    - **具体描述**：

        - **表现层（Presentation Layer）**

            - 专注于用户界面的显示和用户交互处理，通常包含视图（View）和控制器（Controller）的部分职责。

        - **领域层（Domain Layer）**

            - 专注于表达和实现核心业务逻辑和业务规则，与经典 MVC 中的 Model 层职责相似，但明确强调不包含数据访问逻辑。

        - **数据源层（Data Source Layer）**

            - 专注于处理数据持久化（如数据库、缓存）等技术细节，通常以数据访问对象（DAO）的方式实现。

    - **特点：**Fowler 明确提出领域层和数据访问层的分离，以适应企业级应用架构的更高维护性和扩展性需求。



#### 实践中企业开发的分层架构（综合经典 MVC 与 Fowler 架构）

在实际的企业软件开发中，将经典 MVC 和 Fowler 三层架构结合，形成更清晰的五层架构模式：

<table><tbody>
<tr>
<td>

层次

</td>
<td>

名称

</td>
<td>

职责描述

</td>
</tr>
<tr>
<td>

表现层

</td>
<td>

View

</td>
<td>

只负责界面的显示逻辑和用户输入

</td>
</tr>
<tr>
<td>

表现层

</td>
<td>

Controller

</td>
<td>

负责接收并处理用户请求，协调调用业务服务

</td>
</tr>
<tr>
<td>

服务层

</td>
<td>

Service

</td>
<td>

业务逻辑的聚合与协调，调用领域模型实现业务

</td>
</tr>
<tr>
<td>

领域模型层

</td>
<td>

Domain Model

</td>
<td>

表达纯粹的业务规则与领域知识，不涉及技术细节

</td>
</tr>
<tr>
<td>

数据访问层

</td>
<td>

DAO

</td>
<td>

处理数据持久化、数据库交互与外部资源访问

</td>
</tr>
</tbody></table>



### DDD 分离领域 \\&amp; 六边形架构

#### DDD 分离领域

在领域驱动设计（DDD）中，**分离领域** 的设计思想强调将 **领域层** 作为系统的核心，专注于表达业务逻辑和领域知识。领域层应严格独立于基础设施层和应用服务层，目的是为了更好地应对复杂业务场景的建模，并保持业务逻辑的纯粹性与可重用性。



#### 六边形架构（Hexagonal Architecture）

六边形架构（又称为 **Ports and Adapters** 架构）旨在创建一个与用户界面和数据库解耦的应用系统。通过这种方式，应用程序可以在没有依赖数据库或特定用户界面的情况下运行，从而便于进行**自动化回归测试**、**脱离数据库的开发**，并且能轻松地与其他系统进行连接和交互。

六边形架构强调将应用的核心与外部世界进行隔离，通过\\*\\*端口（Ports）**与**适配器（Adapters）\\*\\*来与外部环境（如数据库、用户界面、外部系统等）进行交互。



#### 分离领域 \\&amp; 六边形架构的层级架构

以下是分离领域与六边形架构的层级架构描述：

1. **领域层（Domain Layer）**

    - **元素**：领域对象、领域服务

    - **定义**：领域层是系统的核心，专注于表达业务逻辑和领域知识。它不依赖于外部基础设施，体现业务规则和领域模型。

    - **职责**：领域层实现的是“纯业务逻辑”，它独立于技术实现，保证了系统的灵活性和可维护性。

2. **应用层（Application Layer）**

    - **元素**：应用服务

    - **定义**：应用层不包含业务逻辑，而是对领域层的业务逻辑进行封装、调用和编排。

    - **作用**：

        - 接受客户端请求，并协调领域层进行业务处理。

        - 将领域层的处理结果封装为数据传输对象（DTO），并对外输出。

        - 负责处理事务、日志、权限等横切关注点。

3. **适配器层（Adapter Layer）**

    - **元素**：主动适配器（由外向内）、被动适配器（由内向外）

    - **定义**：适配器层处理系统与外部的交互技术，分为两类：

        - **主动适配器**：由外部系统触发，访问内部模块。例如：Restful API、RPC、Web 页面等。

        - **被动适配器**：由系统内部发起，访问外部资源。例如：数据库持久化层、云文件访问层等。

    - **作用**：

        - **分离关注点**：通过适配器层将系统核心与外界隔离，保证内部模块的稳定性。

        - **扩展性**：适配器层能够根据需要扩展多种不同的适配器，从而增加系统的灵活性。

4. **通用服务层（Common Layer）**

    - **元素**：工具类（Util）、框架性代码、公共库等

    - **定义**：通用服务层包含系统中用于支撑其他层的基础类和工具类代码，提供系统所需的通用功能和服务。

    - **作用**：

        - 为系统提供公共支持，简化其他层次的实现。

        - 例如：日志、缓存、配置管理、加密解密等基础功能。



#### 架构示意图：

<table><tbody><tr>
<td>

</td>
<td>

</td>
</tr></tbody></table>



', 'https://vdbapmvz0i.feishu.cn/docx/HYCid9j8soGR4lxrcjOcVTdlnDM', 'architecture_base', 'clack', 'mvc,六边形架构', 1, 2, '2025-06-18 14:44:16', '2025-08-12 14:13:12');
INSERT INTO miniblog.article (id, title, content, external_link, section_code, author, tags, pos, status, created_at, updated_at) VALUES (573483962228290094, '「 问卷&量表」系统软件架构设计', '# 「量表测评」软件架构设计

## 架构图



### 系统架构图



### 系统组件

| **序号** | **分类** | **组件** | **职责** | **接口形式** | **对外依赖** |
| --- | --- | --- | --- | --- | --- |
| 1 | 核心组件 | **qs\\-api\\-server**<br><br>**（核心领域服务）** | - 管理核心聚合根，实现聚合模块：<br><br>    - 问卷（Questionnaire）<br><br>    - 量表（MedicalScale）<br><br>    - 答卷（AnswerSheet）<br><br>    - 解读报告（InterpretReport）<br><br>- 定义参与角色：<br><br>    - Writer（填写人）<br><br>    - Testee（受试者）<br><br>    - Reader（阅读者）<br><br>- 提供对运营系统的 RESTful API（如问卷编辑、量表配置、答卷查看）<br><br>- 提供对其他服务的 gRPC 接口（如问卷查阅、答卷保存、报告读取） | - RESTful<br><br>- gRPC | - 统一用户服务（UserService）<br><br>- 统一权限服务（AuthService）<br><br>#### |
| 2 | **qs\\-collection\\-server**<br><br>**\\(问卷收集服务\\)** | - 实现功能模块：<br><br>    - 校验（Validation）<br><br>- 从 qs\\-api\\-server 拉取问卷，缓存至 RedisJSON<br><br>- 提交答卷后，向 Redis 发布“原始答卷保存”事件<br><br>- 提供对问卷收集系统（小程序）的 RESTful 接口<br><br>    - 查看问卷<br><br>    - 提交答卷<br><br>    - 查看原始问卷<br><br>    - 查看解读报告 | - 对外提供<br><br>    - RESTful<br><br>- 调用其他组件<br><br>    - gRPC | - qs\\-api\\-server（gRPC）<br><br>- Redis（缓存 \\+ Pub/Sub） |  |
| 3 | **qs\\-evaluation\\-server**<br><br>**（测评解读服务）** | - 实现功能模块：<br><br>    - 分数计算（Scoring）<br><br>    - 量表解析（Evaluation）<br><br>- 订阅“原始答卷保存”事件，完成<br><br>    - 加载答卷、问卷、量表信息<br><br>    - 执行 scoring 模块（得分计算）<br><br>    - 执行evaluation 模块（报告生成）<br><br>    - 生成并保存解读报告 | - 调用其他组件<br><br>    - gRPC | - qs\\-api\\-server（gRPC）<br><br>- Redis（订阅） |  |
| 4 | **qs\\-sdk\\-php**<br><br>**（PHP版SDK）** | 封装 qs\\-api\\-server 中部分功能，供其他业务系统调用，封装功能包含：<br><br>- 获取问卷列表<br><br>- 获取问卷详情<br><br>- 获取原始答卷列表<br><br>- 获取原始答卷详情<br><br>- 获取解读包含列表<br><br>- 获取解读报告详情 | - 调用其他组件<br><br>    - gRPC | - qs\\-api\\-server（gRPC） |  |
| 5 | 旁路组件 | **qs\\-collection\\-system（小程序端）** | - 接入「统一用户」服务<br><br>    - 用户注册\\&登录<br><br>    - 孩子信息登记<br><br>- 接入qs\\-collection\\-server服务<br><br>    - 展示问卷<br><br>    - 提交答卷<br><br>    - 展示原始答卷<br><br>    - 展示解读报告 | - 调用其他组件<br><br>    - RESTful | - qs\\-collection\\-server<br><br>- 统一用户系统 |
| 6 | **qs\\-operating\\-system（问卷\\&量表后台）** | - 接入「统一用户」服务<br><br>    - 登录鉴权<br><br>- 接入qs\\-api\\-server服务<br><br>    - 提供问卷、量表的管理 UI（创建、编辑、版本发布）<br><br>    - 查看答卷与解读报告 | - 调用其他组件<br><br>    - RESTful | - qs\\-api\\-server<br><br>- 统一用户系统 |  |



### 功能模块

<table><tbody>
<tr>
<td>

**序号**

</td>
<td>

**分类**

</td>
<td>

**模块名**

</td>
<td>

**职责**

</td>
<td>

**是否聚合根？**

</td>
<td>

**是否状态存储？**

</td>
</tr>
<tr>
<td>

1

</td>
<td rowspan="4">

聚合模块

</td>
<td>

questionnaire



</td>
<td>

问卷聚合建模：

- 包含：问卷、问题、选项

- 负责：

    - 问卷

    - 问题题型组织

    - 问题选项

</td>
<td>

✅ 是

</td>
<td>

✅ 是（Mongo）

</td>
</tr>
<tr>
<td>

2

</td>
<td>

medical\\-scale

</td>
<td>

量表聚合建模：

- 包含：医学量表、因子

- 负责：

    - 量表

    - 因子的配置

</td>
<td>

✅ 是

</td>
<td>

✅ 是（Mongo）

</td>
</tr>
<tr>
<td>

3

</td>
<td>

answer\\-sheet

</td>
<td>

答卷聚合建模：

- 包含：答卷、答案

- 负责：

    - 答卷

    - 答案题型组织

</td>
<td>

✅ 是

</td>
<td>

✅ 是（Mongo）

</td>
</tr>
<tr>
<td>

4

</td>
<td>

interpret\\-report



</td>
<td>

解读聚合建模：

- 包含：解读报告、解读项

- 负责：

    - 解读报告

    - 解读项



</td>
<td>

✅ 是

</td>
<td>

✅ 是（Mongo）

</td>
</tr>
<tr>
<td>

5

</td>
<td rowspan="3">

功能模块

</td>
<td>

validation

</td>
<td>

校验功能模块：

- 包含：校验规则、校验数据

- 负责：

    - 根据校验规则、校验数据，返回校验结果



</td>
<td>

❌ 否

</td>
<td>

❌ 无状态

</td>
</tr>
<tr>
<td>

6

</td>
<td>

scoring



</td>
<td>

计算功能模块：

- 包含：运算规则、运算数据

- 负责：

    - 根据运算规则、运算数据计算得分

</td>
<td>

❌ 否

</td>
<td>

❌ 无状态

</td>
</tr>
<tr>
<td>

7

</td>
<td>

evaluation

</td>
<td>

解析功能模块：

- 包含：解读规则、解读数据

- 负责：根据解读规则、解读数据，得出解读文案

</td>
<td>

❌ 否

</td>
<td>

❌ 无状态

</td>
</tr>
</tbody></table>



### 数据库存储

<table><tbody>
<tr>
<td>

数据库

</td>
<td>

功能说明

</td>
</tr>
<tr>
<td>

MySQL

</td>
<td>

持久化存储信息：

- 用户信息：User，Child，WxAccount等

- 问卷基础信息

</td>
</tr>
<tr>
<td>

MongoDB

</td>
<td>

持久化存储文档数据：

- 问卷文档

- 答卷文档

- 解读报告

</td>
</tr>
<tr>
<td>

Redis

</td>
<td>

缓存数据库：

- 通过 RedisJSON 缓存问卷信息

- 使用 Pub/Sub 实现 “原始答卷保存” 的发布订阅模型

</td>
</tr>
</tbody></table>







## 组件设计



### 核心组件 qs\\-api\\-server 设计









## 数据库设计

', '', 'ai_prompt', 'clack', '架构设计', 0, 1, '2025-06-19 15:12:02', '2025-07-10 11:15:16');
INSERT INTO miniblog.article (id, title, content, external_link, section_code, author, tags, pos, status, created_at, updated_at) VALUES (573941328732238382, 'Go 语言的诞生：在 C 语言的基础上重塑编程的未来', '
## 编译型语言&解释型语言

在介绍 Go 语言声明周期前，我们需要介绍两个概念：编译型语言 & 解释型语言。
<br/>
在计算机发展的早期阶段，先辈程序员们在苦哈哈的编写汇编语言，而这种由机器指令构成的汇编语言其实属于更偏向计算机一侧的计算机友好型语言，人类使用起来相当困难。
<br/>
为解决汇编语言这种编码困难的问题，1952 年早期高级语言 Autocode 语言诞生。Autocode 是编译型还是解释型？
<br/>
早期计算机资源有限，不需要考虑跨平台问题，这种背景下生长出的 Autocode 语言自然是解释型语言，解释器只需“读取一条→执行一条”，利于交互式开发。

<br/><br/>

## **解释型语言的切肤之痛**

随着解释型语言 Autocode 的使用，开发者们发现执行代码时源码每次都要逐行解释执行，速度慢，而且编码错误往往运行时才暴露，如变量未定义等。
<br/>

**能不能让源码编译提前完成？能不能让错误在编码环节就被发现？**
<br/>
让我们把从源码变成机器能直接运行的二进制指令提前完成，并且在程序运行前就保证类型、结构、访问都是合法的，编译型语言就此孕育而生。早期的 FORTRAN 语言、C语言等都是编译型语言。
<br/><br/>


## **站在巨人肩膀上的语言**

为什么说 Go 语言是站在巨人肩膀上的语言呢？Go 语言的创始人有三位，分别是肯·汤普森（Ken Thompson）（图灵奖获得者、C 语法联合发明人）、罗伯·派克（Rob Pike）（Unix 之父，Plan 9 操作系统领导者、UTF\\-8 编码的最初设计者），以及罗伯特·格瑞史莫（Robert Griesemer）（Java 的 HotSpot 虚拟机和 Chrome 浏览器的 JavaScript V8 引擎的设计者之一）
<br/>
在 2007 年 9 月 20 日下午，在谷歌山景城总部罗伯·派克启动了一个 C++ 工程的编译构建。按照以往的经验判断，这次构建大约需要一个小时。利用这段时间，罗伯·派克和罗伯特·格瑞史莫、肯·汤普森坐在一处，交换了关于设计一门新编程语言的想法。
![image](https://image.yangshujie.com/article/%E7%BC%96%E8%AF%91%E6%BC%AB%E7%94%BB.png)
<br/>
之所以有设计新的编程语言的想法，是因为当时谷歌内部主要使用 C++ 构建各种系统，但 C++ 巨大的复杂性、编译构建速度慢以及在编写服务端程序时对并发支持的不足，让三位大佬觉得十分不便。
<br/>
在他们的初步构想中，这门新语言应该是能够给程序员带来快乐、匹配未来硬件发展趋势并适合用来开发谷歌内部大规模网络服务程序的。而设计的主要思路是，在 C 语言的基础上，修正一些明显的缺陷，删除一些被诟病较多的特性，增加一些缺失的功能，比如，使用 import 替代 include、去掉宏、增加垃圾回收、支持接口等。
<br/>
讨论过后罗伯特·格瑞史莫发出了一封题为“prog lang discussion”的电邮，对这门新编程语言的功能特性做了初步的归纳总结。这封电邮成为了这门新语言的第一版特性设计稿，三位大佬在这门语言的一些基础语法特性上达成了初步一致。
![image](https://image.yangshujie.com/article/prog-lang-discussion.png)
<br/>

9 月 25 日，罗伯·派克在一封回复电邮中把这门新编程语言命名为“go”
![image](https://image.yangshujie.com/article/go-email.png)
<br/>
到这里其实我们就已经知晓：Go 语言是在 C 语言的基础上进行设计的，而 Go 语言也延续了 C 语言的传统，通过编译器提前编译源码，产生可执行文件。

<br/>

```Plain Text
源码 → 编译器 → 平台相关机器码（二进制）
                              │
                              ▼
                    直接部署运行（无需环境）
```

<br/><br/>

## 横向对比各主流语言

| 特性     | 编译型语言（Go、C/C++） | 中间字节码型语言（Java） | 解释型语言（Python、Node.js） |
| ------ | --------------- | -------------- | --------------------- |
| 编译步骤   | ✅ 需要            | ✅ 需要（生成字节码）    | ❌ 不需要                 |
| 执行方式   | 直接执行机器码         | 虚拟机执行字节码       | 解释器逐行解析执行             |
| 执行效率   | 高效              | 较高             | 中等至较低                 |
| 跨平台性   | 差（需单独编译）        | 优秀（一次编译，跨平台）   | 优秀（源代码跨平台）            |
| 运行环境依赖 | 无需额外依赖环境        | 需要JVM/CLR环境    | 需要解释器环境               |
| 部署文件   | 单独二进制文件         | 字节码文件（.class等） | 源码文件（.py/.js/.php）    |


', 'https://vdbapmvz0i.feishu.cn/docx/LHjidY6dBo22vGxfaFMcRQiXnd2', 'go_interesting', 'clack', '编译型语言', 1, 2, '2025-06-18 13:52:31', '2025-08-12 14:13:12');
INSERT INTO miniblog.article (id, title, content, external_link, section_code, author, tags, pos, status, created_at, updated_at) VALUES (574073215433847342, '生命周期（上）：从构建到服务关停的全景', '
阅读 《Go 程序设计语言》《Go 语言实战》等书籍时，经常看到 “*** 有 Go 语言`运行时`分配、控制”之类的描述。“运行时”是什么？还有其他 “**时” 吗？ 带着这些问题，我们来看一看 Go 语言的生命周期。

<br/>

**在介绍 Go 语言生命周期前有这样的背景知识：**

> 编程语言大致分为两类：编译型语言、解释型语言；Go 语言是编译型语言。
> 
> - **编译型语言（Compiled Languages）**：源代码 → 编译 → 可执行文件 → 执行
> 
> - **解释型语言（Interpreted Languages）**：源代码 → 解释器直接运行（无显式编译为机器码步骤）

--- 
<br/>

### Go 程序生命周期

当我们编写完 Go 应用程序之后，Go 语言编写的程序是如何在计算机上运行的呢？
<br/>
现在我们以 Go Web Server 为案例，从全局角度看一看 Go 语言的生命周期：

```Plain Text
[开发]
   ↓
go build
   ↓
[编译时]（Compile time）
 ────> 编译阶段
 ────> 链接阶段
   ↓
[加载时]（Loading time）
 ────> 启动程序进程
 ────> 程序加载到内存
 ────> 堆栈准备
   ↓
[运行时] (Running time)
 ────> Runtime 初始化阶段
 ────> init() 执行阶段
 ────> main() 函数执行阶段
 ────> 业务运行阶段
   ↓
[关停&终止] （Graceful Shutdown & Exit）
 ────> 捕获信号
 ────> 优雅退出（Shutdown）
 ────> 退出主 goroutine
 ────> 程序结束、内存清理、退出码返回
```

<br/>


#### 编译时（Compile time）：通过编译 & 链接，将源码转为可执行文件


在 Go 程序源码开发完毕后，我们会运行 `go build` 命令完成编译工作，产生可执行文件。而在 `go build `命令运行时，则经历了如下两个阶段：编译阶段、链接阶段。

<br/>


**编译阶段：**

- 工具：编译器

- 目的：将开发者编写的 \\.go 源码转成 \\.a / \\.o 等中间文件；

- 过程：

    - 分析（词法分析 & 语法分析）

    - 检查（类型检查）

    - 优化（代码优化）



> 注：编译阶段会将开发者编写的项目源码、第三方类库源码都进行编译，分别生成 \\.a / \\.o 中间文件，不过当前阶段不会根据 import 语句将第三方类库源码引入到项目源码中去。
> 
> 


<br/>

**链接阶段：**

- 工具：链接器

- 目的：将 .a /.o 中介文件串联，并生成可执行文件；

- 过程：

    - 完成符号解析

    - 虚拟内存地址重定位

    - 段合并

    - 构建init()执行顺序图

    

> 注：
> 
> - 使用链接器将 .a / .o 等中间文件串联，会根据 import 引入其他类库，生成可执行文件的过程。
> 
> - 此阶段分配的是虚拟内存地址布局，运行时实际的内存（堆栈等）由 runtime 运行时动态处理。
> 
> 


---

<br/>


#### 加载时（Loading time）：将可执行文件加载到内存，为程序执行做准备



当编译和链接完成后，我们得到一个完整的**可执行文件**。但是，要运行这个程序，操作系统还需要完成一些额外的工作，才能真正进入程序的运行阶段。
<br/>


这段**从可执行文件被调用、加载到内存，直到执行第一个指令前的阶段**，就叫做**加载时（Load Time）：**

<br/>


- **操作系统调用程序启动（启动进程）**

    - 当执行：`./app`时，操作系统会执行以下步骤：

        - 使用系统调用（如`execve`）启动新进程；

        - 为进程创建**进程控制块（PCB）**、分配**进程号（PID）**。

- **将程序加载到内存（Program Loading）**

    - 操作系统读取可执行文件

- **堆栈准备（Stack Setup）**

    - 为主线程创建初始运行栈；

    - 设置好栈指针（Stack Pointer）和程序计数器（PC）寄存器。


---

<br/>

#### 运行时 (Running time)：Go 应用程序正式运行

**运行时（Runtime）** 指的是从程序开始执行第一条 Go 指令（即 init()）到程序完全退出的整个生命周期阶段。而这一阶段的核心是 Go runtime 持续地进行并发调度、内存管理和异常控制。

<br/>


- **Runtime 初始化阶段：**

    - **目的**：**为运行时阶段搭建好并发与内存管理的基础设施**

    - 过程：

        - **调度器初始化（P / M / G）**

            - 创建与 CPU 核数相等的逻辑处理器 P

            - 启动初始的操作系统线程 M0

            - 准备全局队列与本地队列

        - **GC 等子系统初始化**

            - 设置垃圾回收器参数

            - 启动 GC 后台协程

- **init() 执行阶段：**

    - **目的：完成各个包的静态初始化**

    - 过程：

        - 按照编译时链接器确定的依赖顺序，依次调用每个包的 init()

        - 准备好全局变量、注册驱动、加载插件等

- **main() 执行阶段（业务准备）**

    - **目的：搭建业务运行时环境**

    - 过程：

        - 读取/校验配置

        - 初始化数据库连接池、缓存、外部客户端

        - 注册 HTTP 路由、Middlewares

        - 启动 Web Server（ListenAndServe 或者 Server\\.Serve）

- **业务运行阶段（请求处理）**

    - **目的：高效、稳定地处理并发请求**

    - 过程：

        - **Goroutine 调度**：G ↔ P ↔ M 的多路复用

        - **网络 I/O 轮询**：非阻塞地接收和发送数据

        - **垃圾回收**：并发三色标记回收，无停顿或低停顿

        - **panic/recover**：局部错误隔离，防止整个进程崩溃

        - **监控/诊断**：runtime/pprof、runtime/trace 等支持



---

<br/>

#### **关停&终止 （Graceful Shutdown & Exit）：应用的关闭 & 退出**



停机/退出时指的是 Go 程序在接收到关闭信号（如`SIGINT`、`SIGTERM`）后，安全且优雅地终止程序的过程。通常我们把它再细分成两个子阶段：

- **Graceful Shutdown 阶段（优雅关闭阶段）**

- **Exit 阶段（程序彻底退出阶段）**


<br/>


**优雅关闭阶段（Graceful Shutdown）**

**目的**：平滑地停止服务，保证在处理完在飞请求后再退出

- 捕获系统信号（`SIGINT`、`SIGTERM`）

- 调用 `Server.Shutdown(ctx)` 或自定义关闭逻辑

- 拒绝新连接，等待正在处理的请求完成或超时

- 释放数据库连接、缓存、文件句柄等资源


<br/>


**程序彻底退出阶段（Exit）**

**目的**：彻底清理并退出进程

- `main()` 返回，所有 goroutine 退出

- runtime 终止调度器、停止后台协程

- 系统回收剩余内存、线程等资源

- 返回退出码给操作系统

', 'https://vdbapmvz0i.feishu.cn/docx/KwGLdPFGIo1wbax8kJ3cmIulnXb', 'go_lifecycle', 'clack', '生命周期', 1, 2, '2025-06-18 13:54:12', '2025-08-12 14:13:12');
INSERT INTO miniblog.article (id, title, content, external_link, section_code, author, tags, pos, status, created_at, updated_at) VALUES (574341382857044526, '用户故事映射：从用户角度的需求分析', '# 用户故事映射

用户故事映射是以用户的使用场景和行为路径为基础，通过将**用户活动（Activity）**、**用户任务（Task）**、**用户故事（User Story）**按照流程顺序和优先级进行二维组织，从而清晰表达产品功能结构、优先级安排的方法工具。

二维组织方式：

- 纵向：体现需求的优先级、发布计划

- 横向：体现用户使用产品或功能的完整流程与逻辑顺序



**用户故事映射有什么作用？**

- **可视化需求结构**：直观展现用户使用产品的全过程

- **快速捕获需求细节**，发现遗漏需求或隐藏需求

- 明确需求优先级和版本划分



**用户故事映射的流程步骤：**

- **明确目标、确定范围**

    - 明确关注的业务场景范围。

    - 明确要解决的业务问题，要达到哪些目标。

- **识别关键用户活动（Activities）**

    - 从用户视角，列出使用产品或功能时的关键活动。

- **分解用户任务（Tasks）**

    - 将活动进一步拆解成具体任务（Tasks），体现用户从开始到结束的完整交互流程。

- **编写具体用户故事（User Stories） **[**MEMO**](https://v.flomoapp.com/mine/?memo_id=MTQ2MTI0NDI)

    - 在每个任务下面写出具体的、粒度更细的用户故事，描述明确的功能点和交互细节。

- **横纵向整理映射、明确优先级**

    - 横向排序：明确用户故事执行顺序

    - 纵向排序：按业务价值、优先级划分发布版本



**对于用户故事：**

用户故事是从用户的角度出发，描述用户需求的方式。



**用户故事的句式：**

> As a \\&lt;Role\\&gt;, I want to \\&lt;Activity\\&gt;, so than \\&lt;Bussness value\\&gt;\\.
> 
> 作为一个\\&lt;角色\\&gt;, 我想要\\&lt;完成活动\\&gt;, 以便于\\&lt;实现价值\\&gt;
> 
> 



**为什么需要用户故事？**

- 软件开发的过程中，用户需求的一般会经历“用户 —\\&gt; 产品经理 —\\&gt; 开发人员”的流程。而信息的传递其实是编码与解码过程，传递必然会导致信息丢失。使用固定的格式描述用户需求，可以减少编码/解码过程中的失真，而导致的信息丢失；

- 用户故事是以用户角度为出发点（而非传统开发使用的功能列表），可以让软件开发的下游可以完整的了解用户的原始需求，已经用户需求的目的是什么；

- 使用固定句式的用户故事描述需求，也是对软件开发的上游提出要求，需要上游想清楚做的事情，已经做事的目的。



**编写用户故事的 3C原则：**

- 卡片（Card）：用户故事一般在卡片上写着故事的简短描述、规则、完成标准；

- 交谈（Conversation）：用户故事背后的细节，来源于用户与产品负责人的交流，以便于各方达成理解一致；

- 确认（Contrimation）：通过验收测试确认用户故事是否被正确完成。





**用户故事映射 \\&amp; 事件风暴 的结合使用**

在敏捷开发实践中，将**用户故事映射**和**事件风暴结**合使用，是敏捷需求分析与领域驱动设计（DDD）相结合的实践方式。

- 用户故事映射：强调**用户体验流程与功能优先级**。

- 事件风暴：强调**业务领域知识挖掘与统一语言形成**。

|  | **事件风暴（业务分析）** | **用户故事映射（产品设计）** |
| --- | --- | --- |
| **核心关注** | 事件、命令、名词、领域概念 | 用户活动流程、功能需求、发布优先级 |
| **目的** | 领域知识统一语言 | 明确需求拆分和版本划分 |
| **适用场景** | 深入挖掘业务需求细节 | 迭代开发、敏捷规划 |



**具体使用步骤：**

- 步骤一：从用户故事映射开始，明确用户使用场景和整体流程

    - 交付：用户故事映射板（横向功能流程\\+纵向版本划分）

- 步骤二：使用事件风暴的方式，进行领域知识挖掘与细节澄清

    - 交付：

        - 领域事件列表、命令列表、领域名词列表

        - 领域模型 （UML 图）

- 步骤三：再次回到用户故事，重新细化用户故事

    - 交付：

        - 细致化的用户故事（含详细描述和验收标准）

        - 验收标准

        - 业务约束



', 'https://vdbapmvz0i.feishu.cn/docx/FyVZdEwNto2qkMxF5oBcNYtxnXd', 'analysis', 'clack', '用户故事,用户行为', 1, 2, '2025-06-18 14:41:51', '2025-08-12 14:13:12');
INSERT INTO miniblog.article (id, title, content, external_link, section_code, author, tags, pos, status, created_at, updated_at) VALUES (574517839474471470, '静态类型 vs 强类型，到底有啥区别？', '
我们常说 Go 语言是静态类型语言，是强类型语言。很多初学者会将“静态类型语言”和“强类型语言”混为一谈，但其实它们是两个不同维度的概念。

静态类型具体是什么，“静”在哪里？强类型语言的强又是什么？今天我们一起分析分析。

<br/>


### 类型的含义


**我们先向前思考一步：“类型”是个啥？编程语言搞个“类型系统”想要做什么事情？**

<br/>

计算机本身并没有“类型”这个概念，在计算机眼里只有 0 / 1 的数据，而到了汇编语言阶段，它操作的是固定长度的字节，比如 movb 操作 1 字节，movl 操作 4 字节，也不关心这块内存空间代表什么意义。

在高级语言中，则抽象出“类型”这个概念。在声明变量时定义类型，其实就是表明告诉大家：

- 这个变量需要多少内存空间
- 这个变量表示什么意义
- 这个变量具有哪些行为

![image](https://image.yangshujie.com/article/%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E6%BC%94%E5%8F%98.png)

<br/>

类型系统也是“契约式编程”的一种体现，定义了类型，那么内存空间、表示意义、行为模式就都已经确定下来了，既是人\\-人（多个开发者）之间的共识，也是人\\-机（开发者与机器）之间的共识。大家都在统一共识下去做事情，就避免出现很多程序错误。

![image](https://image.yangshujie.com/article/go%20%E8%AF%AD%E8%A8%80%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F.png)

<br/>

### 静态/动态类型语言


我们已经知道 go 语言程序的生命周期分为 `开发` - `编译时` - `加载时` - `运行时` - `关停&停止` 五个阶段，而静态/动态类型语言的本质区别，其实就是在不同的生命周期阶段确定变量类型：

- **静态类型语言在编译期确定变量类型，类型到了运行时不再发生改变**
- **动态类型语言在运行时确定变量类型，且类型在运行时可以发生改变**

<br/>

#### 区别

根据变量类型确定阶段不同的特性，静态/动态类型语言出现了产生了如下一些的区别：

| **维度** | **静态类型语言** | **动态类型语言** |
| --- | --- | --- |
| **类型绑定时机** | **编译期** | **运行时** |
| **类型检查时机** | **编译期（由编译器完成）** | **运行时（由解释器完成）** |
| **性能** | 较高：类型已知，编译器可做优化 | 较低：需频繁做运行时类型检查 |
| **灵活性** | 较低：代码书写更严格 | 高：变量可以随时变化类型 |
| **可维护性** | 高：类型信息完整，利于 IDE 静态分析 | 较低：需要更多测试来弥补类型信息缺失 |
| **开发效率** | 初期慢：需写明类型 | 初期快：无需声明，迭代快 |


<br/>

#### 类型检查


我们说“类型系统”是让 人 & 机器 在统一的共识下做事情，从而避免出现程序错误，那具体避免哪些程序错误呢？这就要说的“类型检查”了。虽然静态类型语言与动态类型语言的类型绑定、类型检查时机不同，但他们都要做同样的类型检查操作：

<br/>

1. 操作类型检查，避免不兼容的类型操作

    ```Go
    var a string = "abc"
    var b int = 1
    fmt.Println(a + b) // ❌ 编译错误，string + int 不合法
    ```

<br/>


2. 参数类型检查，避免出现参数类型错误

    ```Go
    func SendEmail(to Email) { ... }
    
    type Email string
    type Phone string
    
    var p Phone = "1234567890"
    SendEmail(p) // ❌ 编译错误，Phone 不能传给 Email
    ```

<br/>

3. 字段访问检查，避免访问不存在的字段

    ```Go
    type User struct {
        Name string
    }
    
    var u User
    fmt.Println(u.Age) // ❌ 编译错误：User 没有 Age 字段
    ```

<br/>

4. 返回值类型检查，避免出现返回值类型错误

    ```Go
    func GetUserID() int {
        return 42
    }
    
    var id string = GetUserID() // ❌ 编译错误：int → string 不兼容
    ```

<br/>

5. 接口检查，避免出现接口未实现完全的问题

    ```Go
    type Reader interface {
        Read([]byte) (int, error)
    }
    
    type MyReader struct{}
    
    // 没有实现 Read 方法
    var _ Reader = (*MyReader)(nil) // ❌ 编译错误
    ```







<br/>

### 强/弱类型语言


强/弱类型语言指的是编程语言是否允许隐式类型转换：

- **强类型语言不允许隐式类型转换**
- **弱类型语言允许隐式类型转换**

<br/>

#### **强类型语言不允许隐式类型转换：**

要进行类型转换的话必须开发者显示的写出来，也就是说开发者必须知道自己在做什么。

```Go
var a int = 1
var b float64 = 2.0
c := a + b // ❌ 编译错误：int 和 float64 不自动转换

d := a + int(b) // ✅ 允许显示类型转换
```

<br/>

#### **弱类型语言允许隐式类型转换：**

弱类型语言中可以进行隐式类型转换，可能引发不易察觉的运行时 bug，也就是 JS 那句臭名昭著的：“你永远不知道它会干什么”。

```JavaScript
"1" + 1         // "11"
"1" - 1         // 0
true + 1        // 2
null + undefined // NaN
[] == false     // true（wtf）
```


<br/>


### 总结


静态/动态类型语言指的是不同时期绑定变量\\&amp;类型的编程语言：

- **静态类型语言在编译期确定变量类型，类型到了运行时不再发生改变**

- **动态类型语言在运行时确定变量类型，且类型在运行时可以发生改变**

<br/>

强/弱类型语言是指编程语言是否允许隐式类型转换：

- **强类型语言不允许隐式类型转换**

- **弱类型语言允许隐式类型转换**

<br/>

Go 是强类型 + 静态类型语言，类型检查严格，禁止隐式转换，Go 语言在编译器就确定了变量类型，到运行时不再发生类型改变。



', 'https://vdbapmvz0i.feishu.cn/docx/LB0gd8bF5oqe3cxQXFZcQixvn3e', 'go_interesting', 'clack', '静态/动态类型语言,强类型/弱类型语言', 2, 2, '2025-06-23 13:27:59', '2025-08-12 14:13:12');
INSERT INTO miniblog.article (id, title, content, external_link, section_code, author, tags, pos, status, created_at, updated_at) VALUES (574518135256789550, '项目首页', '# 项目首页

### 一、项目基本信息

- **项目名称：** 互联网医院 -- 问卷&量表系统
- **项目负责人：** 杨舒杰

<br/>

### 二、项目背景

- 在精神科领域， 量表测评是常用的检测手段， 而线下填写量表存在算分困难、解­读不便利、测评结果趋势不方便、填写结果易丢失的问题；

- 调研问卷星、金数据产品，探求市场上是否一存在成熟的产品，结果为上述产品仍然只是“调查问卷”，无法满足医学量表测评领域的需求。

<br/>

### 三、项目目的

- 从 0 到 1 的实现医学量表测评系统，为医院门诊场景、在线咨询场景、患者院外随访场景提供医学量表测评渠道；

- 测评填写完成后进行算分、解析，生成解读报告，为医生对患者进行诊断提供依据；

- 留存患者疾病生命周期中所有的测评记录，根据测评结果绘制可视化图表，展示患者疾病生命周期中各个指标的变化。

### 四、项目范围与边界

- **项目范围：**

    - 问卷&量表后台：承担问卷&量表的创建、编辑职能
    - 问卷小程序：承担用户查看问卷、填写问卷、提交答卷、查看原始问卷、查看解读报告的职能


<br/>

- **不包括内容：**

    - 用户注册 & 患者报到
    - 线下医院管理系统的对接与集成

<br/>

### 五、项目预期（成功标准）

- **编辑问卷&量表**

    - 提供问卷后台供医生助理编辑问卷
    - 问题
        - 可选择单选、多选、下拉选择、打分单选等结构化题型
        - 可选择段落、单行文本、多行文本、数字、日期等非结构化题型
        - 结构化题型可支持设置选项分数，在用户填写完毕后由系统自动计算得分
        - 结构化、非结构化题型都可以设置校验规则，题型不同校验规则不同
    - 因子
        - 因子分为一级因子和二级因子，一级因子由问题聚合而成，二级因子由一级因子聚合而成
        - 可对因子计算得分，计算方式根据因子选择项的得分和计算方式共同决定
        - 根据因子得分，可对每个因子配置不同的解读
    - 解读
        - 由因子解读汇聚而成

- **用户填写问卷**

    - 用户可访问问卷助手小程序，进行填写问卷
    - 填写完毕后，系统自动进行算分、解读，生成原始答卷和解读报告
    - 用户在填写完毕后，可查看原始答卷、解读报告




', 'https://vdbapmvz0i.feishu.cn/docx/Ef2OdJMMfoq1OGxWFtFcJMLonjh', 'qs', 'clack', '调查问卷,医学量表', 1, 2, '2025-06-23 14:07:51', '2025-08-12 14:29:39');
INSERT INTO miniblog.article (id, title, content, external_link, section_code, author, tags, pos, status, created_at, updated_at) VALUES (574518224796791342, '事件风暴分析笔记（原始行为→领域事件映射）', '## 明确目标、确定范围


### 目的
梳理医学量表测评业务中用户行为、发现用户需求、挖掘领域知识 

<br/>

### 关注范围 

- 维护问卷&测评库
  - 编辑问卷、问题
  - 配置量表、因子
- 问卷收集
  - 问卷展示
  - 答卷提交
  - 计算答案分
  - 保存答卷
- 分析解读
  - 计算因子分
  - 生成解读文案
  - 保存解读报告
- 展示结果
  - 展示答卷
  - 展示解读报告 |

<br/>

### 不关注的范围
- 用户注册 &患者报到
- 医生开通量表测评服务、绑定量表
- 患者端查看量表列表、解读报告列表
- 在线咨询场景查看量表列表、解读报告列表
- 线下医院管理系统的对接与集成 


<br/>


## **用户故事映射板**

**横向：用户活动 → 用户任务 → 用户故事**

维护量表库 -> 选择测评量表 -> 进行测评 -> 查看解读报告


<table><tbody>
<tr>
<td>

**用户活动**

</td>
<td>

**用户任务**

</td>
<td>

**用户故事**

</td>
</tr>
<tr>
<td>

维护量表库

</td>
<td>

- 新建医学量表，填写标题、简述等基本信息

- 编辑量表问题，设置题目

- 编辑量表因子，设置一级/二级因子

- 编辑量表解读规则，设置因子解读\\&amp;总分解读

</td>
<td>

作为医生助理，我希望可以创建医学量表，并编辑量表的问题、因子、解读规则，以便于供患者进行测评。



</td>
</tr>
<tr>
<td>

门诊测评



</td>
<td>

- 扫描测评二维码，进入测评页面

- 填写测评内容，提交答卷

- 查看测评解读报告、查看原始答卷

</td>
<td>

作为患者，我希望可以在门诊进行医学量表测评，以便于检查是否存在某些方面的问题。

作为医生，我希望可以查看到患者填写的测评解读报告，以便于为患者进行疾病诊断。

</td>
</tr>
<tr>
<td>

在线问诊测评

</td>
<td>

- 医生给患者推送测评邀约

- 患者进入测评页面

- 患者填写测评内容，提交答卷

- 医生查看测评解读报告、查看原始答卷

</td>
<td>

作为医生，我希望在线问诊过程中可以让患者填写医学量表测评，以便于检查患者疾病发展状况。

作为患者，我希望可以在线问诊过程中可以填写医生推送的医学量表测评，以便于检查疾病发展状况。

</td>
</tr>
</tbody></table>



## 事件风暴

### 识别领域事件



### 识别命令



### 识别领域名词（领域概念）





', 'https://vdbapmvz0i.feishu.cn/docx/AQx6dAleioLnIYxKFescjxlknvb', 'qs', 'clack', '调查问卷,医学量表', 2, 2, '2025-06-23 14:13:09', '2025-08-12 14:29:39');
INSERT INTO miniblog.article (id, title, content, external_link, section_code, author, tags, pos, status, created_at, updated_at) VALUES (574518281872880174, '问卷&量表领域建模（领域模型、词汇表、规则表）', '# 「问卷\\&amp;量表系统」领域建模



## 领域建模



## 词汇表

| **分类** | **中文** | **英文** | **简称** |
| --- | --- | --- | --- |
| 通用 | 提交 | submit | n/a |
|  | 计算 | calculate | n/a |
|  | 解析 | analyze | n/a |
|  | 存储 | save | n/a |
|  |  |  |  |
| 问卷 | 问卷 | questionnaire | n/a |
|  | 问题 | question | n/a |
|  | 选项 | option | n/a |
|  | 问题路径 | question routes | ques\\_routes |
|  | - 受控题目 |  |  |
|  | - 关联题目 |  |  |
|  | - 关联关系 |  |  |
|  | 校验规则 | validation rules | valid\\_rules |
|  | 算分规则 | calculation rules | calc\\_rules |
|  |  |  |  |
|  | 填写人 | writer | n/a |
|  |  |  |  |
| 答卷 | 答卷 | answer sheet | n/a |
|  | 答案 | answer | n/a |
|  |  |  |  |
|  |  |  |  |
| 量表 | 医学量表 | medical scale | med\\_scale |
|  | 因子 | factor |  |
|  | 解读规则 | interpret rules | interpret\\_rules |
|  | 解读报告 | interpretation report | interpret\\_report |
|  | 解读项 | interpretation item | interpret\\_item |
|  | 受试者 | testee | n/a |
|  |  |  |  |
|  |  |  |  |
|  |  |  |  |
|  |  |  |  |
|  |  |  |  |





## 领域规则表

<table><tbody>
<tr>
<td>

规则编号

</td>
<td>

模块

</td>
<td>

规则描述

</td>
<td>

举例

</td>
</tr>
<tr>
<td>

C001

</td>
<td>

维护量表库

</td>
<td>

医学量表由四分部组成：

- 基本信息（标题、简介）

- 问卷

    - 问题列表

- 因子

    - 因子列表

- 解读规则

    - 解读规则列表

</td>
<td>

新建医学量表《SNAP\\-IV》

</td>
</tr>
<tr>
<td>

C002

</td>
<td>

维护量表库

</td>
<td>

**问题**由五部分组成：

- 题目

- 提示

- 题型

    - 结构化题型

        - 单选

        - 多选

        - 下拉选择

        - 打分单选

        - 图片单选

        - 图片多选

    - 非结构化题型

        - 段落

        - 单行文本

        - 多行文本

        - 数字

        - 日期

- 问题路径（控制问题显隐）

    - 设当前问题为**受控问题**

    - 当前问题之前的结构化问题，可设为**关联问题**

    - 控制显隐规则：

        - 配置关联问题选择了 \\*\\*\\* 选项，则显示受控问题

        - 若一个受控问题有多个关联问题，则需要配置多个关联问题 同时满足 / 满足一个即可

- 校验规则（验证提交的答案）

    - 必填

    - 最少选择项数（多选类）

    - 最多选择项数（多选类）

    - 最少字数（文本类）

    - 最多字数（文本类）

    - 最小值（数字类）

    - 最大值（数字类）

- 结构化题型算分规则：

    - 算分规则由 **计算选取项** 和 **运算规则** 组成

    - 计算选取项为结构化题型的选项

    - 运算规则：

        - 选项分

        - 平均

        - 求和

        - 最大值

        - 最小值

</td>
<td>

设置《SNAP\\-IV》的 18 道问题

</td>
</tr>
<tr>
<td>

c003

</td>
<td>

维护量表库



</td>
<td>

**因子**由三部分组成：

- 因子名称

- 因子类型

    因子类型：

    - 一级因子

    - 多级因子

- 因子分计算规则

    - 计算规则由 **计算选取项 **和 **运算规则 **组成

    - 计算选取项：

        - 一级因子的选取项为问题

        - 二级因子的选取项为一级因子

    - 运算规则：

        - 平均

        - 求和

</td>
<td>

设置《SNAP\\-IV》的因子：

- 注意力

- 多动冲动

- 总分

</td>
</tr>
<tr>
<td>

C004

</td>
<td>

维护量表库

</td>
<td>

**解读规则**由两部分组成：

- 分数区间（固定为左闭右开）

- 分数段解读文案

</td>
<td>

设置《SNAP\\-IV》的解读规则：

- 总分

    - \\[0,18\\)

    > 孩子基本没有多动症表现，家长可以遵照医生建议，继续观察孩子情况。 给予您一些建议希望可以帮助家长创造良好亲子关系
    > 
    > 1、父母和孩子之间通过彼此的尊重、合作和理解改善亲子关系，使家庭充满关爱和友善
    > 
    > 2、建立家庭代币方案，把家庭规则细化，运用积分等代币方案帮助孩子学习遵守规则和服从指令。运用扣分来改变不良行为，并在家庭内形成制度。
    > 
    > 3、父母要注意情绪稳定，减少家庭生活中常见的冲突、争执以及动辄发怒的行为模式。
    > 
    > 

    - \\[18, 36\\)

    > 孩子有一些多动症的症状表现，可以就诊后，与医生沟通孩子在学校和生活中的行为表现，听取医生建议。分享您一些关于照顾多动症孩子的建议。
    > 
    > 1、改变心态。多动症就像一个陪伴孩子长大的坏朋友，总是喜欢捣乱，让这些孩子的每一步进步都更艰难。建立良好的行为需要一个过程，父母保持积极的心态，才能看到孩子每一天的微小改变。
    > 
    > 2、多渠道了解多动症以及教养技巧，便于家长理解孩子当前行为问题，多给予孩子耐心和包容，同时应用教养技巧，可以高效解决问题。
    > 
    > 3、遵医嘱治疗方案，观察孩子情况。
    > 
    > 

    - \\[36, 55\\)

    > 孩子有明显的多动症的症状表现，建议及时就诊，与医生沟通孩子在学校和生活中的行为表现，听取医生建议。为了缓解您的压力，保持身心健康，可以参考一下建议
    > 
    > 1、转变态度和观念。多动症的父母需要认识到；我的孩子除了要面对其他孩子一样的压力外，还在和一个很困难的发育性障碍作斗争，他很不容易，非常需要父母的帮助，我们要给予孩子更多的耐心去支持他应对学校和生活中所面临的困难
    > 
    > 2、尝试父母共同照顾孩子。每个人的精力有限，父母双方要共同商量如何分担照顾孩子的责任，互帮互助，彼此理解
    > 
    > 3、改变认知角度，父母不要盯着眼前的一次作业，一次成绩，也不要只看重孩子是否听话。健康的成长是身心的全面发展的过程，是能力、情绪管理、社交等多方面的发展。父母要相信自己孩子是有能力的，才能挖掘出孩子的闪光点，让他们有更加长远的发展
    > 
    > 

</td>
</tr>
<tr>
<td>

C005



</td>
<td>

开通医学量表服务

</td>
<td>

医生需要在量表库中选取、绑定量表。

</td>
<td>

为舒杰大夫开通医学量表服务

</td>
</tr>
<tr>
<td>

C006

</td>
<td>

开通医学量表服务

</td>
<td>

绑定量表后，生成测评二维码，二维码包含信息 ：

- 主治医生 ID

- 量表 code

</td>
<td>

为舒杰大夫绑定《SNAP\\-IV》量表

</td>
</tr>
<tr>
<td>

C007

</td>
<td>

开通医学量表服务

</td>
<td>

开通服务后：

- 患者可在患者端找到量表评估模块，查看\\&amp;填写量表

- 医生可在在线问诊场景下找到量表服务，给患者推送量表测评、让患者填写量表

</td>
<td>



</td>
</tr>
<tr>
<td>

C008

</td>
<td>

测评

</td>
<td>

原始答卷保存之后，可不依赖于问卷独立渲染

</td>
<td>

患者王小二填写《SNAP\\-IV》测评，生成原始答卷、解读报告

</td>
</tr>
<tr>
<td>

C009

</td>
<td>

测评



</td>
<td>

原始答卷保存内容：

- 答卷标题、对应的问卷编码

- 答案列表

    - 答案标题

    - 答案内容

    - 答案得分

</td>
<td>



</td>
</tr>
<tr>
<td>

C010

</td>
<td>

测评

</td>
<td>

解读报告保存内容：

- 解读报告标题

- 对应的答卷 id

- 解读项列表

    - 解读项标题

    - 解读项得分

    - 解读项内容

</td>
<td>



</td>
</tr>
<tr>
<td>

C011



</td>
<td>

门诊场景测评

</td>
<td>

测评二维码可打印出来，放置在医生门诊处，患者在医生门诊处直接扫码填写测评。

</td>
<td>



</td>
</tr>
<tr>
<td>

C012

</td>
<td>

在线咨询测评

</td>
<td>

在线咨询场景，医生可直接给患者推送测评邀请。

</td>
<td>



</td>
</tr>
<tr>
<td>

C013

</td>
<td>

在线咨询测评

</td>
<td>

在线问诊场景，测评结束后直接在诊室中推送测评结果。

</td>
<td>



</td>
</tr>
<tr>
<td>



</td>
<td>



</td>
<td>



</td>
<td>



</td>
</tr>
<tr>
<td>



</td>
<td>



</td>
<td>



</td>
<td>



</td>
</tr>
<tr>
<td>



</td>
<td>



</td>
<td>



</td>
<td>



</td>
</tr>
</tbody></table>



', 'https://vdbapmvz0i.feishu.cn/docx/Wx2xdcjIzolpsHxGUZTc75fCnwW', 'qs', 'clack', '领域建模', 3, 2, '2025-06-23 19:24:49', '2025-08-12 14:29:39');
INSERT INTO miniblog.article (id, title, content, external_link, section_code, author, tags, pos, status, created_at, updated_at) VALUES (574518322037535278, '系统架构总览（分层架构 + 模块职责）', '# 「问卷\\&amp;量表系统」软件架构设计

## 架构图



### 系统架构图



### 系统组件

| **序号** | **分类** | **组件** | **职责** | **接口形式** | **对外依赖** |
| --- | --- | --- | --- | --- | --- |
| 1 | 核心组件 | **qs\\-api\\-server**<br><br>**（核心领域服务）** | - 管理核心聚合根，实现聚合模块：<br><br>    - 问卷（Questionnaire）<br><br>    - 量表（MedicalScale）<br><br>    - 答卷（AnswerSheet）<br><br>    - 解读报告（InterpretReport）<br><br>- 定义参与角色：<br><br>    - Writer（填写人）<br><br>    - Testee（受试者）<br><br>    - Reader（阅读者）<br><br>- 提供对运营系统的 RESTful API（如问卷编辑、量表配置、答卷查看）<br><br>- 提供对其他服务的 gRPC 接口（如问卷查阅、答卷保存、报告读取） | - RESTful<br><br>- gRPC | - 统一用户服务（UserService）<br><br>- 统一权限服务（AuthService）<br><br>#### |
| 2 | **qs\\-collection\\-server**<br><br>**\\(问卷收集服务\\)** | - 实现功能模块：<br><br>    - 校验（Validation）<br><br>- 从 qs\\-api\\-server 拉取问卷，缓存至 RedisJSON<br><br>- 提交答卷后，向 Redis 发布“原始答卷保存”事件<br><br>- 提供对问卷收集系统（小程序）的 RESTful 接口<br><br>    - 查看问卷<br><br>    - 提交答卷<br><br>    - 查看原始问卷<br><br>    - 查看解读报告 | - 对外提供<br><br>    - RESTful<br><br>- 调用其他组件<br><br>    - gRPC | - qs\\-api\\-server（gRPC）<br><br>- Redis（缓存 \\+ Pub/Sub） |  |
| 3 | **qs\\-evaluation\\-server**<br><br>**（测评解读服务）** | - 实现功能模块：<br><br>    - 分数计算（Scoring）<br><br>    - 量表解析（Evaluation）<br><br>- 订阅“原始答卷保存”事件，完成<br><br>    - 加载答卷、问卷、量表信息<br><br>    - 执行 scoring 模块（得分计算）<br><br>    - 执行evaluation 模块（报告生成）<br><br>    - 生成并保存解读报告 | - 调用其他组件<br><br>    - gRPC | - qs\\-api\\-server（gRPC）<br><br>- Redis（订阅） |  |
| 4 | **qs\\-sdk\\-php**<br><br>**（PHP版SDK）** | 封装 qs\\-api\\-server 中部分功能，供其他业务系统调用，封装功能包含：<br><br>- 获取问卷列表<br><br>- 获取问卷详情<br><br>- 获取原始答卷列表<br><br>- 获取原始答卷详情<br><br>- 获取解读包含列表<br><br>- 获取解读报告详情 | - 调用其他组件<br><br>    - gRPC | - qs\\-api\\-server（gRPC） |  |
| 5 | 旁路组件 | **qs\\-collection\\-system（小程序端）** | - 接入「统一用户」服务<br><br>    - 用户注册\\&登录<br><br>    - 孩子信息登记<br><br>- 接入qs\\-collection\\-server服务<br><br>    - 展示问卷<br><br>    - 提交答卷<br><br>    - 展示原始答卷<br><br>    - 展示解读报告 | - 调用其他组件<br><br>    - RESTful | - qs\\-collection\\-server<br><br>- 统一用户系统 |
| 6 | **qs\\-operating\\-system（问卷\\&量表后台）** | - 接入「统一用户」服务<br><br>    - 登录鉴权<br><br>- 接入qs\\-api\\-server服务<br><br>    - 提供问卷、量表的管理 UI（创建、编辑、版本发布）<br><br>    - 查看答卷与解读报告 | - 调用其他组件<br><br>    - RESTful | - qs\\-api\\-server<br><br>- 统一用户系统 |  |



### 功能模块

<table><tbody>
<tr>
<td>

**序号**

</td>
<td>

**分类**

</td>
<td>

**模块名**

</td>
<td>

**职责**

</td>
<td>

**是否聚合根？**

</td>
<td>

**是否状态存储？**

</td>
</tr>
<tr>
<td>

1

</td>
<td rowspan="4">

聚合模块

</td>
<td>

questionnaire



</td>
<td>

问卷聚合建模：

- 包含：问卷、问题、选项

- 负责：

    - 问卷

    - 问题题型组织

    - 问题选项

</td>
<td>

✅ 是

</td>
<td>

✅ 是（Mongo）

</td>
</tr>
<tr>
<td>

2

</td>
<td>

medical\\-scale

</td>
<td>

量表聚合建模：

- 包含：医学量表、因子

- 负责：

    - 量表

    - 因子的配置

</td>
<td>

✅ 是

</td>
<td>

✅ 是（Mongo）

</td>
</tr>
<tr>
<td>

3

</td>
<td>

answer\\-sheet

</td>
<td>

答卷聚合建模：

- 包含：答卷、答案

- 负责：

    - 答卷

    - 答案题型组织

</td>
<td>

✅ 是

</td>
<td>

✅ 是（Mongo）

</td>
</tr>
<tr>
<td>

4

</td>
<td>

interpret\\-report



</td>
<td>

解读聚合建模：

- 包含：解读报告、解读项

- 负责：

    - 解读报告

    - 解读项



</td>
<td>

✅ 是

</td>
<td>

✅ 是（Mongo）

</td>
</tr>
<tr>
<td>

5

</td>
<td rowspan="3">

功能模块

</td>
<td>

validation

</td>
<td>

校验功能模块：

- 包含：校验规则、校验数据

- 负责：

    - 根据校验规则、校验数据，返回校验结果



</td>
<td>

❌ 否

</td>
<td>

❌ 无状态

</td>
</tr>
<tr>
<td>

6

</td>
<td>

scoring



</td>
<td>

计算功能模块：

- 包含：运算规则、运算数据

- 负责：

    - 根据运算规则、运算数据计算得分

</td>
<td>

❌ 否

</td>
<td>

❌ 无状态

</td>
</tr>
<tr>
<td>

7

</td>
<td>

evaluation

</td>
<td>

解析功能模块：

- 包含：解读规则、解读数据

- 负责：根据解读规则、解读数据，得出解读文案

</td>
<td>

❌ 否

</td>
<td>

❌ 无状态

</td>
</tr>
</tbody></table>



### 数据库存储

<table><tbody>
<tr>
<td>

数据库

</td>
<td>

功能说明

</td>
</tr>
<tr>
<td>

MySQL

</td>
<td>

持久化存储信息：

- 用户信息：User，Child，WxAccount等

- 问卷基础信息

</td>
</tr>
<tr>
<td>

MongoDB

</td>
<td>

持久化存储文档数据：

- 问卷文档

- 答卷文档

- 解读报告

</td>
</tr>
<tr>
<td>

Redis

</td>
<td>

缓存数据库：

- 通过 RedisJSON 缓存问卷信息

- 使用 Pub/Sub 实现 “原始答卷保存” 的发布订阅模型

</td>
</tr>
</tbody></table>







## 组件设计



### 核心组件 qs\\-api\\-server 设计









## 数据库设计

', 'https://vdbapmvz0i.feishu.cn/docx/Lzx9drS5eoksnJxyyL8cChqUn1g', 'qs', 'clack', '架构设计', 4, 2, '2025-06-23 19:25:58', '2025-08-12 14:29:39');
INSERT INTO miniblog.article (id, title, content, external_link, section_code, author, tags, pos, status, created_at, updated_at) VALUES (574518771465597486, '项目首页', '# 项目首页

### 一、项目基本信息

- **项目名称：** 互联网医院 \\-\\- 在线问诊服务

- **项目负责人：** 杨舒杰

- **项目周期：** 2021年4月 — 2024年9月

### 二、项目背景

- 方寸医生平台是ADHD领域领先的线上疾病管理服务平台，累计服务覆盖600多家医院、2000余名医生及近20万名患者。

- 平台已提供了用药记录、量表测评、药品复购、副反应管理等全面的诊后管理服务，患者可通过平台与医生助理沟通解决日常问题。

- 当前，患者治疗过程中如需咨询医生或调整治疗方案，只能到医院重新挂号复诊，存在挂号困难、时效性差、出行不便等问题。

### 三、项目目的

- **患者角度：**

    - 解决患者紧急或重要问题无法及时联系医生的问题。

    - 提供高效、便捷的线上复诊服务，替代传统的线下复诊方式。

- **医生角度：**

    - 从传统的一次性问诊模式转变为长期的、持续的患者疾病生命周期管理。

    - 帮助医生利用碎片时间获得额外收入。

### 四、项目范围与边界

- **项目范围：**

    - 用户注册及患者报到功能的开发与上线

    - 在线问诊功能模块的开发与上线

    - 患者端与医生端交互界面设计开发

    - 电子处方模块开发与上线

    - 支付与订单管理系统开发与部署

- **不包括内容：**

    - 初诊医疗行为（如诊断和初次处方开具）

    - 线下医院管理系统的对接与集成

### 五、项目预期（成功标准）

- **患者入驻平台：**

    - 患者首次就诊时，通过扫描医生门诊二维码快速完成用户注册及患者报到，完成患者入驻。

- **医生开通问诊服务：**

    - 支持图文、语音及视频多种问诊形式，医生可根据自身需求灵活选择并配置。

    - 支持医生灵活设置图文问诊对话轮次、语音及视频问诊的时长。

- **患者约诊服务：**

    - 患者能够便捷购买在线问诊服务，过程中能够收集患者主诉和核实患者用药信息。

    - 每日早上8:00，系统自动向医生或医生助理推送当天的预约患者信息，提醒进行接诊安排。

    - 医生或医生助理成功安排问诊时间后，系统立即通知患者问诊的具体时间及注意事项。

- **在线问诊实施流程：**

    - 问诊开始前5分钟，分别通知医生和患者进入诊室。

    - 诊室支持医生查看患者资料、主诉记录、用药记录和量表测评记录。

    - 诊室内，医生可实时发起量表测评，患者可在线填写。

    - 医生可在线开具电子处方。

- **问诊异常处理机制：**

    - **医生接诊失败**：患者下单后，若医生未及时设置问诊时间，则系统自动退款并提醒患者选择线下复诊。

    - **问诊迟到**：

        - 若患者迟到但仍在预约结束前进入诊室，则正常进行问诊；未在预约结束前到达，则问诊结束不退款。

        - 若医生迟到但在预约结束前进入诊室，则正常进行问诊；若预约结束前仍未到达，则重新安排问诊时间。



', 'https://vdbapmvz0i.feishu.cn/docx/FGLSdUjHYoSUZRxtr1Bc4vpXnzf', 'online_consultation', 'clack', '在线问诊', 1, 2, '2025-06-23 19:32:22', '2025-08-12 14:13:38');
INSERT INTO miniblog.article (id, title, content, external_link, section_code, author, tags, pos, status, created_at, updated_at) VALUES (574518790960722478, '「在线问诊」模块需求分析', '# 「在线问诊」模块需求分析

## **明确目标、确定范围**

| **项目** | **说明** |
| --- | --- |
| **目的** | 梳理医生与患者在线问诊流程，明确核心需求与功能边界 |
| **关注范围** | 医生开通问诊服务、患者预约问诊、问诊交互过程 |
| **不关注的范围** | 医生注册、患者注册\\&报到、量表测评、处方管理等 |



## **用户故事映射板**

**横向：用户活动 → 用户任务 → 用户故事**

开通问诊服务 \\-\\&gt; 约诊 \\-\\&gt; 分诊 \\-\\&gt; 问诊

<table><tbody>
<tr>
<td>

**用户活动**

</td>
<td>

**用户任务**

</td>
<td>

**用户故事**

</td>
</tr>
<tr>
<td>

开通问诊服务

</td>
<td>

- 设定问诊服务信息

- 发布问诊服务

</td>
<td>

作为医生，我希望开通、发布我的在线问诊服务，以便于患者可以预约我的在线咨询。

</td>
</tr>
<tr>
<td>

患者约诊

</td>
<td>

- 支付问诊费

- 填写问诊资料

- 提交问诊预约申请

</td>
<td>

作为患者，我希望可以在公众号中预约我的主治医生的在线问诊，以便于更新我的治疗方案。

</td>
</tr>
<tr>
<td>

医助分诊



</td>
<td>

- 医助沟通患者

- 收集患者资料，确定主诉

- 确定问诊时间

</td>
<td>

作为医生，我希望患者预约后先由医助与患者沟通、收集患者信息，并确定问诊时间，以减轻我的前期准备负担。

</td>
</tr>
<tr>
<td>

医生分诊

</td>
<td>

- 医生直接设定问诊时间

</td>
<td>

作为医生，我希望能直接确定问诊时间，以减少额外沟通环节。

</td>
</tr>
<tr>
<td>

医生问诊

</td>
<td>

- 问诊开始

- 过程沟通

- 问诊结束

</td>
<td>

作为医生，我希望问诊双方进入诊室后直接开始沟通，以确保问诊及时高效。

作为医生，我希望能够提前手动结束问诊，以灵活调整问诊时间。

作为医生，我希望问诊达到预约时长后自动结束，以提高工作效率。

</td>
</tr>
</tbody></table>



## 事件风暴

### 识别领域事件



### 识别命令



### 识别领域名词（领域概念）



### 领域规则表

<table><tbody>
<tr>
<td>

规则编号

</td>
<td>

模块

</td>
<td>

规则描述

</td>
<td>

举例

</td>
<td>

主要影响的功能

</td>
</tr>
<tr>
<td>

C001

</td>
<td>

开通问诊服务

</td>
<td>

可选的问诊方式：图文问诊、语音问诊、视频问诊

</td>
<td>

舒杰大夫开通了图文问诊功能、语音问诊功能：

- 图文问诊 50 元/次，每次 10 轮对话

- 语音问诊 100 元/次，每次 30 分诊

</td>
<td>

问诊功能

</td>
</tr>
<tr>
<td>

C002

</td>
<td>

约诊



</td>
<td>

患者填写的问诊资料内容：

- 身高、体重

- 当前服用的药品

- 近期药物副反应

- 本次问诊主诉

</td>
<td>

患者王小二来预约舒杰大夫的语音问诊，预约过程中填写了问诊资料：

- 身高： 112cm；体重：41kg

- 当前服用静灵口服液、多动宁胶囊

- 副反应：服药后孩子出现厌食的情况

- 主诉：孩子药快吃完了，多动症状有缓解，但是自从服药后孩子不爱吃饭了，出现厌食情况，是否需要调整用药？

</td>
<td>

收集问诊资料功能

</td>
</tr>
<tr>
<td>

C003

</td>
<td>



</td>
<td>

需要先付问诊费用，才能预约问诊

</td>
<td>

患者王小二支付问诊费 100 元

</td>
<td>

支付功能

</td>
</tr>
<tr>
<td>

C004

</td>
<td>



</td>
<td>

问诊预约后，患者等待分诊

</td>
<td>

支付问诊费后，系统提示已支付成功，很快就有医生助理来帮助我预约问诊。

</td>
<td>



</td>
</tr>
<tr>
<td>

C005

</td>
<td>

分诊



</td>
<td>

可选两种分诊方式：

- 医生自助分诊：

    - 医生根据自己的行程，自由安排问诊时间；

    - 系统将分诊结果\\(问诊时间\\)通知患者

- 医助分诊

    - 医生和医助私下约定，每周几、哪个时间段可进行在线问诊；

    - 医助查看医生排班表，寻找可接诊时间；

    - 医助发消息问医生，该时间是否可接诊，最终得到医生确定的准确时间

    - 系统将分诊结果\\(问诊时间\\)通知患者

</td>
<td>

舒杰大夫的图文问诊是“医生自助分诊”

舒杰大夫的语音问诊是“医助分诊”



</td>
<td>

分诊功能

</td>
</tr>
<tr>
<td>

C006

</td>
<td>



</td>
<td>

问诊资料收集：

- 医助人工收集

    - 收集方式：

        - 查看系统中的患者病历

        - 查看约诊时患者填写的问诊资料

        - 和患者打电话沟通

- AI 医助自动收集

    - 收集方式：

        - 调取系统中患者病历

        - 查看约诊时患者填写的问诊资料



</td>
<td>

医助李小燕接收到患者王小二的问诊预约申请，开始收集问诊资料：

- 查看系统中患者病历，发现患者王小二是 ADHD，年龄 10 岁

- 查看约诊时的问诊资料，发现患者身高身高112cm；体重 41kg，当前服用静灵口服液、多动宁胶囊，出现厌食的副反应

- 和患者打电话，沟通患者情况，并询问患者方便的问诊时间

</td>
<td>

问诊资料汇报功能

</td>
</tr>
<tr>
<td>

C007

</td>
<td>



</td>
<td>

问诊资料汇报：

- 汇报方式：医助人工汇报、AI 医助自动汇报

- 汇报内容：

    - 患者身高、体重

    - 患者疾病诊断

    - 用药信息

    - 副反应信息

    - 问诊主诉



</td>
<td>

医助李小燕开始向舒杰大夫汇报问诊资料：

- 患者 王小二

- 身高： 112cm；体重：41kg

- 用药：

    - 曾用药：择思达

    - 先用药：静灵口服液、多动宁胶囊

- 副反应：调整用药后出现厌食情况，每天晚上不想吃饭

- 主诉：孩子药快吃完了，多动症状有缓解，但是自从服药后孩子不爱吃饭了，出现厌食情况，是否需要调整用药？

</td>
<td>

问诊资料汇报功能

</td>
</tr>
<tr>
<td>



</td>
<td>



</td>
<td>

问诊资料汇报后，医助和医生沟通，确定问诊时间

</td>
<td>

医助李小燕给舒杰大夫发消息，询问医生是否有时间问诊，最后确定晚上 20:00 可以进行问诊。

</td>
<td>



</td>
</tr>
<tr>
<td>

C008

</td>
<td>

图文问诊

</td>
<td>

图文问诊的云诊室开放规则：分诊完毕即开放云诊室

</td>
<td>



</td>
<td>

图文问诊功能

</td>
</tr>
<tr>
<td>

C009

</td>
<td>



</td>
<td>

图文问诊的问诊开始判定规则：云诊室开放，即认为问诊开始

</td>
<td>



</td>
<td>

图文问诊功能

</td>
</tr>
<tr>
<td>

C010

</td>
<td>



</td>
<td>

图文问诊的结束的判定方式

- 到达最大对话轮次；

- 到达最大问诊时长

</td>
<td>



</td>
<td>

图文问诊功能

</td>
</tr>
<tr>
<td>

C011

</td>
<td>



</td>
<td>

图文问诊对话轮次计算规则：

- 患者发消息后，医生第一次回复即完成一个轮次；

- 医生多次回复同一条患者消息，不增加对话轮次。

</td>
<td>



</td>
<td>

图文问诊功能

</td>
</tr>
<tr>
<td>

C012

</td>
<td>



</td>
<td>

图文问诊结束后：

- 关闭患者端发消息功能；

- 保留医生端发消息功能。

</td>
<td>



</td>
<td>

图文问诊功能

</td>
</tr>
<tr>
<td>

C013

</td>
<td>



</td>
<td>

云诊室关闭后：

- 医生和患者都可以再次进入诊室，查看历史消息。

</td>
<td>



</td>
<td>

图文问诊功能

</td>
</tr>
<tr>
<td>

C014

</td>
<td>

语音/视频问诊

</td>
<td>

语音/视频问诊的云诊室开放规则：

- 预约时间前 5 分诊开放云诊室

</td>
<td>

患者王小二 和 舒杰大夫的语音问诊，约在晚上 20:00 开始；

19:55 \\- 系统开放云诊室，并分别向医生、患者推送消息，提醒二人前来问诊

</td>
<td>

语音/视频问诊功能

</td>
</tr>
<tr>
<td>

C015

</td>
<td>



</td>
<td>

语音/视频问诊开始的判定规则：

- \\[云诊室开放时间，问诊预约时间\\) \\- 医患双方同时在诊室，即算作问诊开始；

- \\[问诊预约时间， 问诊预约时间\\+最大问诊时长\\) \\- 到问诊预约时间即为问诊开始

</td>
<td>

19:56 \\- 患者王小二进入云诊室，等待问诊

19:58 \\- 舒杰大夫进入云诊室，开始问诊



问诊开始时间判定为: 19:58

</td>
<td>

语音/视频问诊功能

</td>
</tr>
<tr>
<td>

C016

</td>
<td>



</td>
<td>

语音/视频问诊结束的判定规则：

- 到达`问诊开始时间 \\+ 最大问诊时长`，即问诊结束；

- 问诊过程中，医生可通过功能手动加时长（应对医生迟到的情况）

</td>
<td>

问诊结束时间，预置为 20:28

</td>
<td>

语音/视频问诊功能

</td>
</tr>
<tr>
<td>

C017

</td>
<td>



</td>
<td>

语音/视频问诊结束后：

- 关闭语音/视频通话功能；

- 关闭患者端发消息功能；

- 保留医生端发消息功能。

</td>
<td>

20: 15 \\- 患者王小二 和 舒杰大夫沟通完毕，两人先后退出云诊室



20:28 \\- 系统关闭云诊室的语音通话功能，关闭患者端的发消息能力

</td>
<td>

语音/视频问诊功能

</td>
</tr>
<tr>
<td>

C018

</td>
<td>



</td>
<td>

语音/视频问诊重新预约规则：

- 医生爽约，可重新预约问诊

- 患者爽约，不可重新预约问诊

</td>
<td>

直至 20:30，舒杰大夫一直没有到诊室，问诊迟迟没有开始。

患者王小二联系医助李小燕，告知医生爽约。医助李小燕向患者致歉，承诺和医生沟通，尝试重新预约问诊。

第二天医助李小燕联系到舒杰大夫，舒杰大夫表明昨天晚上临时有事情忘记问诊，并同意重新预约今天晚上的问诊。

</td>
<td>

语音/视频问诊功能

</td>
</tr>
<tr>
<td>



</td>
<td>



</td>
<td>



</td>
<td>



</td>
<td>



</td>
</tr>
<tr>
<td>



</td>
<td>



</td>
<td>



</td>
<td>



</td>
<td>



</td>
</tr>
<tr>
<td>



</td>
<td>



</td>
<td>



</td>
<td>



</td>
<td>



</td>
</tr>
<tr>
<td>



</td>
<td>



</td>
<td>



</td>
<td>



</td>
<td>



</td>
</tr>
<tr>
<td>



</td>
<td>



</td>
<td>



</td>
<td>



</td>
<td>



</td>
</tr>
<tr>
<td>



</td>
<td>



</td>
<td>



</td>
<td>



</td>
<td>



</td>
</tr>
<tr>
<td>



</td>
<td>



</td>
<td>



</td>
<td>



</td>
<td>



</td>
</tr>
<tr>
<td>



</td>
<td>



</td>
<td>



</td>
<td>



</td>
<td>



</td>
</tr>
<tr>
<td>



</td>
<td>



</td>
<td>



</td>
<td>



</td>
<td>



</td>
</tr>
<tr>
<td>



</td>
<td>



</td>
<td>



</td>
<td>



</td>
<td>



</td>
</tr>
<tr>
<td>



</td>
<td>



</td>
<td>



</td>
<td>



</td>
<td>



</td>
</tr>
</tbody></table>

', 'https://vdbapmvz0i.feishu.cn/docx/CBLEdsWEyojzSjxMkTdcJ8qZnDe', 'online_consultation', 'clack', '在线问诊', 2, 2, '2025-06-23 19:33:04', '2025-08-12 14:13:38');
INSERT INTO miniblog.article (id, title, content, external_link, section_code, author, tags, pos, status, created_at, updated_at) VALUES (574518835739111982, '「在线问诊」模块领域建模', '# 「在线问诊」模块领域建模

### 建模 \\- 领域模型图



### 模型实现 \\-\\- 程序架构设计



### 模型实现 \\-\\- 数据库存储设计







', 'https://vdbapmvz0i.feishu.cn/docx/HKnLdekiKoOlpuxGxGdcdjCznpg', 'online_consultation', 'clack', '在线问诊', 3, 2, '2025-06-23 19:33:43', '2025-08-12 14:13:38');
INSERT INTO miniblog.article (id, title, content, external_link, section_code, author, tags, pos, status, created_at, updated_at) VALUES (574519017050485294, '「电子处方」模块需求分析', '# 「电子处方」模块需求分析

## **明确目标、确定范围**

| **项目** | **说明** |
| --- | --- |
| **目的** | 梳理智慧药房中开处方、审处方的业务流程 |
| **关注范围** | 开处方、审处方 |
| **不关注的范围** | 药品售卖、物流配送 |

## **用户故事映射板**

**横向：用户活动 → 用户任务 → 用户故事**

开通电子处方服务 \\-\\&gt; 开方 \\-\\&gt; 验方 \\-\\&gt; 审方

<table><tbody>
<tr>
<td>

**用户活动**

</td>
<td>

**用户任务**

</td>
<td>

**用户故事**

</td>
</tr>
<tr>
<td>

开通电子处方服务

</td>
<td>

- 设定处方审核规则

- 发布电子处方服务

</td>
<td>

作为医生，我希望可以开通电子处方服务，以便于可以在线上给患者开电子处方，方便患者购药。

</td>
</tr>
<tr>
<td colspan="3">



</td>
</tr>
<tr>
<td>

主治医师开方

</td>
<td>

- 选择药品

- 填写药品用法用量

- 开具电子处方

</td>
<td>

作为医生，我希望在线问诊场景，我可以主动给患者开具电子处方，以便于方便患者购药。

</td>
</tr>
<tr>
<td>

药师审方



</td>
<td>

- 收到电子处方审核提醒

- 审核电子处方

</td>
<td>

作为药师，我希望在收到医师开具的电子处方后，可以进行处方审核。



</td>
</tr>
<tr>
<td colspan="3">



</td>
</tr>
<tr>
<td>

患者提交用药申请



</td>
<td>

- 患者选购药品

- 患者提交用药申请

- 患者付款

</td>
<td>

作为患者，我希望在没有处方时，可以通过智慧药房提交用药申请，以便于进行线上购药。

</td>
</tr>
<tr>
<td>

平台医师开方



</td>
<td>

- 平台医生查看患者用药申请

- 填了药品用法用量

- 开具电子处方

</td>
<td>

作为平台医师，我希望看到患者的用药申请时，可以给患者开具电子处方，以便于可以让患者进行线上购买。

</td>
</tr>
<tr>
<td>

医生助理验方

</td>
<td>

- 收到电子处方核验提醒

- 审核电子处方

</td>
<td>

作为医生助理，我希望平台医生开具电子处方后，我可以根据患者主治医师的用药方案核验电子处方，以便于避免患者乱用药，产生医疗事故。

</td>
</tr>
<tr>
<td>

主治医师验方

</td>
<td>

- 收到电子处方核验提醒

- 审核电子处方

</td>
<td>

作为主治医生，我希望平台医生开具电子处方后，我可以核验平台医生开具的电子处方，以便于避免患者乱用药，产生医疗事故。

</td>
</tr>
<tr>
<td>

药师审方

</td>
<td>

- 查看平台医师开具的电子处方

- 审核电子处方

</td>
<td>

作为药师，我希望在收到医师开具的电子处方后，可以进行处方审核。

</td>
</tr>
</tbody></table>

## 事件风暴

### 识别领域事件



### 识别命令



### 识别领域名词（领域概念）



### 领域规则表

<table><tbody>
<tr>
<td>

规则编号

</td>
<td>

模块

</td>
<td>

规则描述

</td>
<td>

举例

</td>
<td>

主要影响的功能

</td>
</tr>
<tr>
<td>

C001

</td>
<td>

开通电子处方服务



</td>
<td>

电子处方服务分为三个流程：开方 \\-\\&gt; 验方 \\-\\&gt; 审方



- 两种“开方”方式：

    - 主治医师开方

    - 平台医师开方

- 三种“验方”方式：

    - 主治医师验方

    - 医生助理验方

    - AI 医助验方

- 一种“审方”方式

    - 平台药师审方

</td>
<td>

舒杰大夫开通电子处方服务：

- 支持主治医师/平台医生开方

- 选择医生助理验方模式

- 确定平台药师审方

</td>
<td>

开方、验方、审方

</td>
</tr>
<tr>
<td>

C002



</td>
<td>

开方

</td>
<td>

开方规则：

- 开通电子处方服务，即代表同时允许主治医师开方与平台医师开方两种开方方式

    - 主治医师开方的业务场景：在线咨询场景

    - 平台医师开方的业务场景：患者在智慧药房自行提交用药申请

</td>
<td>

患者王小二在医院初诊，舒杰大夫开了处方，服用择思达、小儿智力糖浆

初诊 1 个月后，药物用完，在平台上进行药品复购，选择了 3 盒择思达、4 瓶小儿智力糖浆。

平台医生为患者王小二开具电子处方

</td>
<td>

开方

</td>
</tr>
<tr>
<td>

c003

</td>
<td>

验方

</td>
<td>

验方规则：

- 主治医师开具的处方，不需要核验

- 平台医生开具的处方，需要核验

</td>
<td>

由于是平台医生开具的电子处方，所以需要验方

</td>
<td>

验方

</td>
</tr>
<tr>
<td>

c004

</td>
<td>

验方

</td>
<td>

验方人选取规则：

- 主治医生要求自己核验，则固定为主治医生验方

- 非主治医生验方，有用药风险的，转医生助理验方

- 非主治医生验方，没有用药风险的，转 AI 助理验方

</td>
<td>

因舒杰大夫选择医生助理验方模式，而患者王小二没有用药风险，所以转 AI 助理验方，核验通过。

</td>
<td>

验方

</td>
</tr>
<tr>
<td>

c005

</td>
<td>

验方

</td>
<td>

用药风险检测：

- 用药申请中包含未曾开具出的的药品

- 用药申请日期超过上次处方 60 天

</td>
<td>



</td>
<td>

验方

</td>
</tr>
<tr>
<td>

c006

</td>
<td>

验方

</td>
<td>

验方环节拒绝处方的处理流程:

- 验方人（主治医生/医生助理）拒绝平台医师开具的处方

- 验方人（主治医生/医生助理）填写拒绝理由

- 系统自动给患者退款

- 系统给患者推送拒绝理由，并建议患者进行复诊

</td>
<td>



</td>
<td>

验方

</td>
</tr>
<tr>
<td>

c007

</td>
<td>

审方

</td>
<td>

审方流程：

- 平台药师审方通过，则生成电子处方并留存

    - 给患者发发送“处方通过”通知

- 平台药师审方拒绝，则处方单开具失败

    - 若患者已支付药品订单，则给患者退款

</td>
<td>

平台药师审方，审核通过，给患者发送处方通过通知

</td>
<td>

审方、配送

</td>
</tr>
<tr>
<td>



</td>
<td>



</td>
<td>



</td>
<td>



</td>
<td>



</td>
</tr>
</tbody></table>



', 'https://vdbapmvz0i.feishu.cn/docx/E5WidJCNqoOsUdxytZEcf81vn9b', 'online_consultation', 'clack', '电子处方', 4, 2, '2025-06-23 19:34:24', '2025-08-12 14:13:38');
INSERT INTO miniblog.article (id, title, content, external_link, section_code, author, tags, pos, status, created_at, updated_at) VALUES (574521019050485296, '「电子处方」模块领域建模', '# 「电子处方」模块领域建模

### 建模 \\- 领域模型图







### 模型实现 \\-\\- 程序架构设计



### 模型实现 \\-\\- 数据库存储设计







', 'https://vdbapmvz0i.feishu.cn/docx/J9Wrd8hegoBtnuxwT57cbDcJnmc', 'online_consultation', 'clack', '电子处方', 5, 2, '2025-06-23 19:35:02', '2025-08-12 14:13:38');
INSERT INTO miniblog.article (id, title, content, external_link, section_code, author, tags, pos, status, created_at, updated_at) VALUES (575352612975555118, '设计原则 -- 单一职责原则', '# 设计原则 \\-\\- 单一职责原则

## 单一职责原则

单一职责原则，又称Single responsibility principle，SRP。



### 望文生义的理解

> 一个模块只干一件事。
> 
> 

“一个模块只干一件事”的确是重要的软件设计思想，但它其实是“高内聚、低耦合”的通俗解释，是从模块自身考虑怎么去组合的设计思想。



### 将变化纳入考量

Robert Martin 在《敏捷软件开发：原则、实践与模式》中，对单一职责原则的定义：

> 就一个类而言，应该仅有一个引起它变化的原因。
> 
> 



#### 职责是什么？

在SRP中，我们把职责定义为“变化的原因”。如果你能想到多于一个动机去改变一个类，那么这个类就具有多于一个的职责。



#### 为什么要分离职责？

软件设计是一门关注长期变化的学问，一个模块最理想的状态是不改变，其次是少改变，它可以成为一个模块设计好坏的衡量标准。

每一个职责都是变化的一个轴线。当需求变化时，该变化会反应为类的职责的变化。如果一个类承担了多于一个的职责，那么引起它变化的原因就有多个。

如果一个类承担的职责过多，就等于把这些职责耦合在了一起。一个职责的变化可能会削弱或抑制类完成其他职责的能力。



### 将变化的来源纳入考量

Robert Martin 在《架构整洁之道》中重新定义了单一职责原则：

> 任何一个软件模块，都应该只对某一类行为者负责。
> 
> 



#### 行为者是什么？

在现实环境中，软件系统为了满足“用户”和“所有者”的要求，必然要做出这样或那样的修改。而该系统的用户或者所有者，就是设计原则中所指出的“被修改的原因”。

因而单一职责原则又可以被描述为：任何一个软件模块，都应该只对一个用户或系统利益相关者负责。而这里的“用户”和“系统利益相关者”，其实是一个或多个有共同需求的人。

我们对这些有共同需求的人，统称为一类“行为者”。



---

## 设计案例：

### 项目管理的反例

开发一个项目管理的工具，需要一个用户类，我们可能设计出这样一个用户类：

注：看上去，这个类设计得还挺合理，有用户信息管理、有项目管理等等。



没过多久，新的需求来了，要求每个用户能够设置电话号码，所以，增加了一个新的方法：





过了几天，又来了新需求，要查看一个用户加入了多少项目：







就这样，左一个需求，右一个需求，几乎每个需求都要改到这个类。

那会导致什么结果呢？一方面，这个类会不断膨胀；另一方面，内部的实现会越来越复杂。



原因就在于它引起变动的需求太多了：

- 为什么要增加电话号码呢？因为这是用户管理的需求。

- 为什么要查看用户加入多少项目呢？这是项目管理的需求。

    

---



### 用户拆分 \\#d 将变化纳入考量

用户管理 和 项目管理是两种完全不同的需求，但它们都改动了同一个类，所以，这个 User 类就很难稳定下来。

解决这种问题，最好的办法就是把不同的需求引起的变动拆分开来。

针对这里的用户管理和项目管理两种不同需求，可以把这个 User 类拆成两个类：

- 用户管理类的需求放到 User 类里

- 项目管理类的需求放到 Member 类里



---





### 管理者的引入 \\#d 将变化的来源纳入考量

用户管理的需求，通常是人事部门提出的，它的行为者可能是 行政 / 人事；

而项目管理的需求，通常是业务部门提出的，它的行为者则是部门负责人、项目负责人。



Robert Martin 说，单一职责原则是基于康威定律的一个推论：一个软件系统的最佳结构高度依赖于使用这个软件的组织的内部结构。如果我们的软件结构不能够与组织结构对应，就会带来一系列麻烦。



> 康威定律：一个组织设计出的系统，其结构受限于其组织的沟通结构。
> 
> 



', 'https://vdbapmvz0i.feishu.cn/docx/DG5ndUXddo26zdxRQMXcn9wpnRb', 'design_pattern', 'clack', '单一职责,设计原则', 1, 2, '2025-07-14 12:14:41', '2025-08-12 14:13:12');
INSERT INTO miniblog.article (id, title, content, external_link, section_code, author, tags, pos, status, created_at, updated_at) VALUES (575353036734476846, 'Go 语言为什么不支持三元表达式 ？', '# Go 语言为什么不支持三元表达式 ？

在现有的编程历史上，三元表达式过多的被用于复杂逻辑运算，背离的三元表达式的设计初衷，导致代码可读性、可维护性下降，所以Go语言的开发者移除了三元表达式的设计，仅提供最简单的 if 语句来支持逻辑运算。

> 注：
> 
> 复杂逻辑运算有：
> 
> 1. 判断条件的计算过程复杂
> 
> 2. 返回的结果需要通过复杂计算获得
> 
> 3. 嵌套的逻辑运算
> 
> 





#### Go语言的开发者移除了三元表达式的原因：

1. 三元表达式容易被滥用，尤其是在逻辑较为复杂的情况下，导致代码可读性和可维护性下降。

2. 三元表达式并不一定能够带来更高的效率，因为它们需要进行额外的计算，并且在某些情况下可能会导致代码优化出现问题。

3. Go语言的设计哲学是简洁而清晰，避免不必要的语法和复杂性，因此移除了三元表达式等一些可能会增加语言复杂性的特性。

    

    

#### 简单三元表达式会让代码更简洁、更易读，而Go语言开发者提供了其他的语言特性来弥补移除三元表达式后失去的优点：

1. 简化的 if 语句：Go语言中的 if 语句可以在条件判断前加上一个语句，这个语句定义的变量只在 if 语句块内有效，这种语法结构可以避免在代码中出现冗余的变量。

2. 简化的 switch 语句：Go语言中的 switch 语句可以使用类型选择器，通过类型断言和类型判断来判断具体的分支，这种语法结构可以使 switch 语句更加灵活。

3. 函数返回值多值：Go语言中的函数可以返回多个值，这种语法结构可以减少代码中的中间变量，提高代码的简洁性。

', 'https://vdbapmvz0i.feishu.cn/docx/JwVMdiEO5odWfpxqwlvckO1Tnze', 'go_interesting', 'clack', '三元表达式', 3, 2, '2025-07-14 12:18:54', '2025-08-12 14:13:13');
INSERT INTO miniblog.article (id, title, content, external_link, section_code, author, tags, pos, status, created_at, updated_at) VALUES (575790201524204078, '六边形架构与模块化设计', '# 六边形架构与模块化设计

近几年谈到 DDD、整洁架构时，总免不了要讲到六边形架构设计。什么是六边形架构呢？它和 DDD 有什么联系？这种架构又暗含哪些设计原则？今天我们详细聊一聊六边形架构与模块化设计。



**六边形架构（Hexagonal Architecture）**有一个更具象化的名字：**端口与适配器模式（Ports and Adapters Architecture）**。它是由 Alistair Cockburn （敏捷宣言的签署者之一）提出的，希望创建一个不依赖于用户界面和数据库即可运行的应用，以便于应用可以在不依赖数据库或特定用户界面的情况下运行，进行**自动化回归测试**、**脱离数据库开发**，并且能轻松地与其他系统进行连接和交互。



### DDD 领域分层 与 六边形架构

在六边形架构的设计中，这个“不依赖用户界面和数据库即可运行的应用”是什么呢？换个思路问：在软件架构中忽略外部输入层与数据持久化层之后，最核心的是什么？是**领域对象**与**领域服务**。



六边形架构强调将应用程序的核心领域逻辑明确分离，构建一个不依赖任何外部接口或持久化技术即可独立运行的核心。这一核心恰恰对应于DDD分层架构中的领域层（Domain Layer）。领域层封装了全部业务逻辑与规则，成为系统真正的核心。



所有外部输入和输出，均通过明确定义的端口（Ports）暴露，并通过适配器（Adapters）实现具体的技术细节，这便是六边形架构的核心思想。







### 端口（Ports）与适配器（Adapters）

当我们将领域层成为软件架构的核心构建出 Appliaction 后，如何驱动这个应用呢？六边形架构给出的解决方案是通过端口与适配器。



让我们试想一下：

- 当事件从外界经过一个 端口（port）传入时，一个基于特定技术的 适配器（adapter）会将其转化成合适的过程调用或消息，然后转发给 应用（application），应用来做具体的业务处理；

- 在输出时，应用也会将信息通过一个端口（port）发往适配器（adapter），适配器再针对信息接收者的具体技术（人或自动化程序）将其转化成合适的输出信号；

- 应用在输入输出时，只和相应的适配器进行语义完整的交互，而并不知道、也不关心适配器另一端的具体技术是什么，对输入、输出设备一无所知，这真是一件幸事。



#### 用端口定义行为

端口是应用程序定义的接口，必须由外界实现，以便应用程序可以接收或发送信息，进行解耦。

我们将应用服务看为一个整体，端口则被分为两种：

- **入站端口（Inbound Port）**：定义了外界可调用的应用核心功能（例如业务操作接口）。

- **出站端口（Outbound Port）**：定义了应用程序核心需要调用的外部服务接口（例如数据库存储、消息队列发送）。



#### 用“适配器”处理输入输出

适配器是对应于端口而存在的，是连接应用程序核心和外部接口的桥梁。它负责将外部请求转换为应用程序核心可以理解的格式，并将核心的响应转换为外部接口可以接受的格式。这一层的目的是把业务功能“适配”到不同的输入输出技术。

适配器也分为两种：

- **入站适配器（Inbound Adapter）**：通常表现为对外暴露的 REST API、gRPC 服务接口等，调用入站端口处理外部请求。

- **出站适配器（Outbound Adapter）**：具体实现数据持久化、缓存访问、消息队列等服务，完成完整业务流程的外部交互。









### 六边形架构中所设计的设计思想



通过六边形架构，应用程序核心成为了架构的中心，具有清晰的边界和职责，可以独立于外部接口进行测试和演进。外部接口和适配器负责处理与外部系统的交互，使应用程序核心保持独立和可复用。



#### 架构设计的主要特点

- 高内聚和低耦合：应用程序核心独立于外部依赖，使得不同部分的修改不会对其他部分产生影响，提高了代码的可维护性。

- 可测试性：应用程序核心可以轻松地进行单元测试，因为它不依赖于具体的外部接口或技术细节。

- 可扩展性：通过添加新的适配器，可以很容易地与新的外部系统进行集成，而不会对应用程序核心产生影响。



#### 架构设计所遵循的设计原则

- 分离关注点：六边形架构将系统划分为不同的层次，每个层次都有其特定的职责和关注点。这种分离使得每个组件可以专注于自身的任务，降低了耦合性，提高了模块的可复用性和可测试性。

- 接口隔离原则：六边形架构强调基于接口编程，通过定义清晰的接口和协议来促进组件之间的通信。接口的使用让各层之间解耦，又便于扩展。

- 开闭原则：六边形架构将外部系统与领域核心相分离，通过不同的适配器去驱动应用程序的运行，做到了对适配器扩展的开发，对应用核心依赖外部系统的关闭，提供了系统的健壮性。

- 依赖注入：六边形架构鼓励使用依赖注入来管理组件之间的依赖关系。通过依赖注入，组件的依赖关系可以在运行时进行配置，而不是在编译时固定。这样可以实现组件之间的松耦合，并且方便进行替换和测试。





### 六边形架构与模块化设计

六边形架构天然支持模块化，通过端口与适配器清晰定义各模块边界，将系统划分为独立模块。每个适配器都是独立模块，通过接口实现清晰的模块边界。以下示例展示如何以模块化容器管理模块：

#### 容器化管理

```Go

// modulePool 模块池
var modulePool = make(map[string]assembler.Module)

// Container 主容器
// 组合所有业务模块和基础设施组件
type Container struct {
        // 基础设施
        mysqlDB *gorm.DB
        mongoDB *mongo.Database

        // 业务模块
        AuthModule            *assembler.AuthModule
        UserModule            *assembler.UserModule

        // 容器状态
        initialized bool
}

// NewContainer 创建容器
func NewContainer(mysqlDB *gorm.DB, mongoDB *mongo.Database) *Container {
        return &Container{
                mysqlDB:     mysqlDB,
                mongoDB:     mongoDB,
                initialized: false,
        }
}

// Initialize 初始化容器
func (c *Container) Initialize() error {
        if c.initialized {
                return nil
        }

        // 初始化用户模块
        if err := c.initUserModule(); err != nil {
                return fmt.Errorf("failed to initialize user module: %w", err)
        }

        // 初始化认证模块
        if err := c.initAuthModule(); err != nil {
                return fmt.Errorf("failed to initialize auth module: %w", err)
        }

        c.initialized = true
        fmt.Printf("🏗️  Container initialized with modules: user\\n")

        return nil
}

```



#### User 模块

```Go
// Module 用户模块
// 负责组装用户相关的所有组件
type UserModule struct {
        // repository 层
        UserRepo port.UserRepository

        // handler 层
        UserHandler *handler.UserHandler

        // service 层
        UserCreator         port.UserCreator
        UserQueryer         port.UserQueryer
        UserEditor          port.UserEditor
        UserActivator       port.UserActivator
        UserPasswordChanger port.PasswordChanger
}

// NewModule 创建用户模块
func NewUserModule() *UserModule {
        return &UserModule{}
}

// Initialize 初始化模块
func (m *UserModule) Initialize(params ...interface{}) error {
        db := params[0].(*gorm.DB)
        if db == nil {
                return errors.WithCode(code.ErrModuleInitializationFailed, "database connection is nil")
        }

        // 初始化 repository 层
        m.UserRepo = userInfra.NewRepository(db)

        // 初始化 service 层
        m.UserCreator = userApp.NewUserCreator(m.UserRepo)
        m.UserQueryer = userApp.NewUserQueryer(m.UserRepo)
        m.UserEditor = userApp.NewUserEditor(m.UserRepo)
        m.UserActivator = userApp.NewUserActivator(m.UserRepo)
        m.UserPasswordChanger = userApp.NewPasswordChanger(m.UserRepo)

        // 初始化 handler 层
        m.UserHandler = handler.NewUserHandler(
                m.UserCreator,
                m.UserQueryer,
                m.UserEditor,
                m.UserActivator,
                m.UserPasswordChanger,
        )

        return nil
}

// Cleanup 清理模块资源
func (m *UserModule) Cleanup() error {
        return nil
}

// CheckHealth 检查模块健康状态
func (m *UserModule) CheckHealth() error {
        return nil
}

// ModuleInfo 返回模块信息
func (m *UserModule) ModuleInfo() ModuleInfo {
        return ModuleInfo{
                Name:        "user",
                Version:     "1.0.0",
                Description: "用户管理模块",
        }
}

```



#### Auth 模块

```Go
// Module 认证模块
// 负责组装用户相关的所有组件
type AuthModule struct {
        // repository 层
        UserRepo port.UserRepository

        // service 层 - 使用接口类型而非具体类型
        Authenticator port.Authenticator
}

// NewModule 创建认证模块
func NewAuthModule() *AuthModule {
        return &AuthModule{}
}

// Initialize 初始化模块
func (m *AuthModule) Initialize(params ...interface{}) error {
        db := params[0].(*gorm.DB)
        if db == nil {
                return errors.WithCode(code.ErrModuleInitializationFailed, "database connection is nil")
        }

        // 初始化 repository 层
        m.UserRepo = userInfra.NewRepository(db)

        // 初始化 service 层
        m.Authenticator = authApp.NewAuthenticator(m.UserRepo)

        return nil
}

// CheckHealth 检查模块健康状态
func (m *AuthModule) CheckHealth() error {
        return nil
}

// Cleanup 清理模块资源
func (m *AuthModule) Cleanup() error {
        return nil
}

// ModuleInfo 返回模块信息
func (m *AuthModule) ModuleInfo() ModuleInfo {
        return ModuleInfo{
                Name:        "auth",
                Version:     "1.0.0",
                Description: "认证模块",
        }
}

```





通过这种模块化设计方式，可以清晰地管理系统内部的模块依赖与初始化顺序，提高代码的模块化程度和可维护性。

', 'https://vdbapmvz0i.feishu.cn/docx/OWd5dnf3NoHOibxkuEScSv2HnDd', 'architecture_base', 'clack', '架构设计,模块化', 2, 2, '2025-07-17 12:41:44', '2025-08-12 14:13:12');
INSERT INTO miniblog.article (id, title, content, external_link, section_code, author, tags, pos, status, created_at, updated_at) VALUES (575806912218542638, '“值传递”与“指针传递”到底该如何选择？', '# Golang 值传递 与 指针传递 到底该如何选择？

在 Go 语言开发中，经常需要面对函数或方法中参数、返回值与接收者的传递方式选择问题，即到底该使用值传递（Value）还是指针传递（Pointer）？这一选择不仅会影响代码的语义与可读性，还关系到程序性能和可能产生的副作用。



我们将先从三个维度进行分析，再针对函数参数\\&amp;返回值和方法接收者两种场景进行讨论。

---

## 三个关键维度的思考

### 1\\. 值类型与指针类型

- **值类型（Value Type）**

    - **原生类型**：如 `int`、`float64`、`bool` 等基本类型

    - **组合类型**：仅包含值类型字段的结构体和定长数组 `\\[N\\]T`

    - **特性**：传递或复制时完整拷贝数据，副本与原数据完全独立

- **指针类型（Pointer Type）**

    - **显式指针类型**：如 `\\*T`

    - **隐式指针类型**：如 `slice`、`map`、`chan`、`interface` 等

    - **特性**：传递或复制时仅复制 header 或指针，底层数据共享



### 2\\. 原始类型与非原始类型

《Go 语言实战》中提到`类型的本质` 的概念，将 go 语言类型分为 **原始类型** 和 **非原始类型**。

- **原始（Primitive）类型**

    - **本质**：值即数据本身，复制后产生独立副本

    - **举例**：

        - 基本数据类型（数值、字符串、布尔值）

        - 仅由基本数据类型组成的结构体

- **非原始（Non\\-primitive）类型**

    - **本质**：值是一个标头（header），含指向底层数据的指针，复制时共享底层数据

    - **举例**：

        - `slice`、`map`、`chan`、`interface` 和函数类型

        - 包含非原始类型字段的结构体



### 3\\. 无副作用与有副作用

- **无副作用（Side\\-effect Free）**

    - 仅仅读取字段或计算结果，不改变实例内部状态

- **有副作用（With Side\\-effects）**

    - 在方法或函数内部修改实例或其底层数据



---

## 二、函数参数 \\&amp; 返回值的传递方式

### 值传递与指针传递对比

| **维度** | **值传递（T）** | **指针传递（\\*T）** |
| --- | --- | --- |
| 拷贝方式 | 完整拷贝整个结构 | 仅拷贝指针（8字节） |
| 性能开销 | 随对象大小增加，可能较大 | 固定且较小（8字节） |
| 修改数据效果 | 只修改副本数据，不影响原数据 | 直接修改原数据，外部可见 |
| 推荐场景 | 小对象、只读或返回新值 | 大对象、需要修改或共享数据 |



### 案例分析

值传递可能引发数据分裂，指针传递确保数据一致。

```Go
type DataHolder struct {
    Items []int
}

// 值传递
func ProcessByValue(h DataHolder) {
    h.Items = append(h.Items, 1)
    // 若扩容，副本与原数据分裂
}

// 指针传递
func ProcessByPointer(h *DataHolder) {
    h.Items = append(h.Items, 1)
    // 无论扩容与否，原数据均更新
}
```



---

## 三、方法接收者的传递方式

### 值接收者与指针接收者对比

<table><tbody>
<tr>
<td>

**维度**

</td>
<td>

**值接收者（T）**

</td>
<td>

**指针接收者（\\*T）**

</td>
</tr>
<tr>
<td>

修改实例

</td>
<td>

仅修改副本，不影响原实例

</td>
<td>

直接修改原实例，修改外部可见

</td>
</tr>
<tr>
<td>

副作用清晰度

</td>
<td>

可能产生副本与原实例混淆

</td>
<td>

副作用明确，修改行为作用于原实例

</td>
</tr>
<tr>
<td>

推荐场景

</td>
<td>

纯只读操作，或返回修改后的新副本

</td>
<td>

涉及修改操作（如扩容、重建）

</td>
</tr>
</tbody></table>



### 案例分析

指针接收者更直观明确地修改了原始数据，值接收者易产生混淆。

```Go
type Container struct {
    Data   []int
    Extras map[string]int
}

// 值接收者
func (c Container) AppendValue(v int) {
    c.Data = append(c.Data, v)    // 扩容仅副本变化
    c.Extras["flag"] = v          // 修改共享数据
}

// 指针接收者
func (c *Container) SafeAppend(v int) {
    c.Data = append(c.Data, v)
    if c.Extras == nil {
        c.Extras = make(map[string]int)
    }
    c.Extras["flag"] = v
}
```



---



## 四、实践建议与总结



**函数参数 \\&amp; 返回值**

- 值类型、原始的数据、小对象、无副作用、只读或计算新值 → 值传递

- 指针类型、非原始的数据、大对象、有副作用、需要共享或修改数据 → 指针传递



**方法接收者**

- 原始的类型、只读、无副作用或返回修改后新值 → 值接收者

- 非原始的类型、需要明确修改原实例、含副作用操作 → 指针接收者



', 'https://vdbapmvz0i.feishu.cn/docx/FYv7d6861okcDUxjTH5cotLUnJb', 'go_interesting', 'clack', '值传递与指针传递', 4, 2, '2025-07-17 15:27:45', '2025-08-12 15:02:51');
INSERT INTO miniblog.article (id, title, content, external_link, section_code, author, tags, pos, status, created_at, updated_at) VALUES (576514688787952174, '设计原则 -- 开闭原则', '# 设计原则 \\-\\- 开闭原则

如果发生\\*\\*\\*改变怎么办？扩展性太差了？怎么这么一个小需求，却需要这么多改动？

在软件架构评审时有没有听到过类似这些评论？怎样的设计方案才是优雅、可扩展的？今天我们来聊一聊 SOLID 中的第二个原则：**开闭原则**。



## **定义：对扩展开发、对修改关闭 **



我们看一看 《设计模式》中对开闭原则的描述：



> **开闭原则（Open\\-Closed Principle, OCP）**
> 
> 
> 
> software entities \\(modules, classes, functions, etc\\.\\) should be open for extension , but closed for modification。
> 
> 



译成中文就是：**软件实体（模块、类、方法等）应该“对扩展开放、对修改关闭”**。

也就是说，在需求变化时，我们**应通过“扩展”已有代码，而不是“修改”已有代码**，来实现新功能。



## 开闭原则的本质：已“扩展性”应对“变化”



深入思考，开闭原则的本质是在强调软件设计的“扩展性”问题。 那么什么是“扩展性”呢？



**以软件开发模式的角度看：**

而在工业界，软件系统的开发已经渐渐由瀑布式转换为敏捷式，我们不可能在项目开始阶段就获知所有的变化，更贴合现实世界的做法是要拥抱变化、相应变化。

对应到软件系统中，**拥抱变化、相应变化的能力便是软件系统的“扩展性”**。



**以软件系统本身的角度看：**

如果一个软件（或一段代码）编写后只运行一次，用之即弃，那完全不需要考虑扩展性。

如果一个软件（或一段代码）在编写后需要持续运行，并需要随着业务需求的变化而持续迭代、支持，那么扩展性问题既需要被重视。

软件系统在满足现有功能的前提下，**可以低成本、低风险地支持新增需求的能力，便是软性系统的“扩展性”。**



### 对变化的思考：谁在变？如何隔离变化？如何支持扩展？  



通过上面的思考，我们其实可以看出开闭原则是**面向变化的设计哲学**，这时候再次向自己提问：是谁在变？如何隔离变化？如何支持扩展？



谁在变？多数情况下，**变化的是行为本身，不变的是执行行为的过程。**

举个例子，在一个清结算系统的支付模块中，变化的是支付方式（微信支付、支付宝支付），而不变的是支付流程；在一个用户系统的认证模块中，变化的是认证方式（OAuth 认证、JWT 认证），不变的是认证流程。



如何隔离变化，如何支持扩展？**将流程进行固化，而对行为者提供扩展**。

例如，在清结算系统的支付模块，需要固化的是**选择支付方式 → 发起支付 → 完成支付**；而在用户系统的认证模块中，需要固化的便是**接收凭证 → 验证身份 → 生成会话信息**。



### 开闭原则就是“只读”吗？开闭原则的粒度如何掌握？  



在读一些文章时发现，有些文章对开闭原则的描述为“与其修改模块的业务，不如实现一个新业务”。



我的认知中，还是需要的开闭原则的粒度进行控制的：对于业务模块，开闭原则指导模块不应该有流程方向的改变，而应该在行为实现侧提供扩展性；而对于模块中的**类、结构体**，为**类、结构体**增加新的字段，以便于支持新的能力，也是扩展性的体现。



### 开闭原则的另一面：过度设计



凡事有正也有反，在设计中过度支持变化，往往也是被称为“夸夸其谈通用性”的坏味道。

所有的设计都是有成本的：阅读成本、理解成本，有时为了不存在的变化为引入新的设计，往往造成系统的复杂度增加，团队成员的理解成本增加。

而变化向着预期外演化时，原来的设计方案反倒成了成本，阻碍了系统的迭代。



奥卡姆剃刀法则告诉我们：

> 如无必要，勿增实体。
> 
> 



在我以往的设计经验中，我常常遵循“刚刚好支持当前需求，并对变化只做一步推演与支持”。



## 开闭原则下的设计模式



### 策略模式（Strategy Pattern）

核心思想：

- 依赖抽象而非具体实现；

- 新功能通过实现接口来扩展，而不是改已有代码。



新增优惠策略，只需添加结构体并实现接口即可。

```Go
// 折扣策略
type DiscountStrategy interface {
    Calculate(price float64) float64
}

// VIP 策略
type VIPDiscount struct{}
func (d VIPDiscount) Calculate(p float64) float64 { return p * 0.8 }

// 订单
type Order struct {
    // 优惠策略
    Strategy DiscountStrategy
}

```



---

### 注册表模式（Registry Pattern）

适用于多策略、多插件场景。将扩展点注册进映射表中，实现松耦合，新增类型时无需改原有逻辑，避免使用 switch\\-case。



```Go
var registry = make(map[string]Handler)

func Register(name string, h Handler) {
    registry[name] = h
}

```

---

### 模板方法模式（Template Method）

定义算法骨架，变化留给子类，可插入新的 `Do\\(\\)` 行为，不改主流程。



```Go
// 抽象化的任务
type AbstractTask struct{}

// 任务执行
func (a *AbstractTask) Execute() {
    a.Prepare()
    a.Do()
    a.Cleanup()
}

```

---

### 职责链模式（Chain of Responsibility）

将处理逻辑链式组织，每个节点负责部分逻辑，扩展处理节点仅需添加新 handler，不影响链上其他节点。

```Go
// Handler 处理器
type Handler interface {
        Handle(ctx context.Context, data pubsub.AnswersheetSavedData) error
}

// HandlerChain 处理器链
type HandlerChain struct {
        handlers []Handler
}

// AddHandler 向处理器链中增加处理器
func (chain *HandlerChain) AddHandler(handler Handler) {
        chain.handlers = append(chain.handlers, handler)
}

// Handle 处理答卷已保存消息
func (chain *HandlerChain) Handle(ctx context.Context, data pubsub.AnswersheetSavedData) error {
        for _, handler := range chain.handlers {
                if err := handler.Handle(ctx, data); err != nil {
                        return err
                }
        }
        return nil
}


// A 处理器
type AHandler struct {}

// B 处理器
type BHandler struct {}


```

', 'https://vdbapmvz0i.feishu.cn/docx/CTNKdrVofodeNoxU6w9c3Ekmnvc', 'design_pattern', 'clack', '开闭原则', 2, 2, '2025-07-22 12:38:52', '2025-08-12 14:13:12');
INSERT INTO miniblog.article (id, title, content, external_link, section_code, author, tags, pos, status, created_at, updated_at) VALUES (578111354439741998, '生命周期（中）：编译器执行流程全解析', '# 深入理解 Go 编译器的执行流程：从源码到可执行文件

Go 语言以其简洁、高效和工程化著称，而它背后的编译器机制同样值得我们深入理解。

本文将全面梳理 Go 编译器的三大阶段：前端解析、中端优化、后端生成，结合 SSA、逃逸分析、闭包重写等关键机制，揭示从 `\\.go` 源码到二进制文件的完整路径。

---

## 一、Go 编译器三阶段结构总览

Go 编译器整体遵循现代编译器的三阶段架构：

1. **编译器前端（Front\\-End）**：理解源代码，构建结构化语义模型（AST、类型信息、符号表）

2. **中端优化器（Middle\\-End Optimizer）**：优化语义结构，构建 SSA 中间表示

3. **编译器后端（Back\\-End）**：生成目标平台汇编代码与可执行程序

接下来，我们将逐一详细拆解每个阶段。

---

## 二、编译器前端：理解源码、构建结构化语义

### ▶ 目的

将 Go 源代码解析为编译器可识别的数据结构：Token 流、抽象语法树（AST）、类型信息和符号表。



### ▶ 步骤分解

4. 词法分析（Lexical Analysis）

将源码文件的字符序列拆解为一个个 Token（词法单元），每个 Token 有类型和值，如：

```Go
var x = 1 + 2
```

生成的 Token 流大致为：

```Plain Text
[VAR] [IDENT:x] [=] [INT:1] [+] [INT:2]
```

5. 语法分析（Parsing）

将 Token 流转换为抽象语法树（AST），构造出程序的语法结构：

```Plain Text
VarDecl
├── Name: x
└── Value:
    └── BinaryExpr
        ├── Left: 1
        ├── Op: +
        └── Right: 2
```

6. 语义分析（Semantic Analysis）

在语法结构的基础上进行语义推导，包括：

- 标识符绑定（Name Resolution）：将 `x` 绑定到作用域内定义的变量

- 类型推导与检查：判断操作数是否类型匹配

- 常量折叠与替换：如 `const Pi = 3\\.14` 会被替换为字面量



**注意：Go 编译器在「语义分析」阶段，会对 ****`const`**** 进行求值（folding）并将常量引用在 AST 中替换为 字面量节点，从而实现编译期替换，不再参与运行时流程。**



### ▶ 最终产物

- 抽象语法树（AST）

- 类型信息（types\\.Info）

- 符号表（Symbol Table）



---

## 三、中端优化器：构建中间表示，优化语义结构

### ▶ 目的

对程序的结构进行优化，生成 SSA（Static Single Assignment）中间表示，以支持高效代码生成与优化。

### ▶ 步骤分解

7. 类型检查

确认所有表达式的类型是否合法，类型一致性是构建 SSA 的基础。



8. 变量捕获分析（闭包分析）

- 判断闭包中使用的变量是否是外部变量

- 决定是值拷贝、还是使用引用



9. 函数内联（Inlining）

- 将体积小、无副作用的函数内联至调用处，减少函数调用栈开销

- 通常与逃逸分析联动



10. 逃逸分析（Escape Analysis）

- 决定变量应分配在栈还是堆上

- 优化内存分配、减少 GC 压力



11. 闭包重写（Closure Rewriting）

Go 编译器根据闭包用途将其重写为更高效的形式：

- 若闭包定义后立即调用（如 IIFE），可转换为普通函数

- 若闭包延迟调用，则生成闭包对象并封装其引用环境



12. 控制流图（CFG）构建

为每个函数构造控制流图，反映代码执行路径（分支、循环、跳转）



13. SSA 构建（Static Single Assignment）

- 每个变量在 SSA 中只赋值一次

- 更便于执行优化如：死代码删除、常量传播、值合并等



### ▶ 最终产物

SSA 中间表示文件（IR）



---

## 四、编译器后端：生成目标机器代码与链接

### ▶ 目的

将 SSA 中间表示转换为目标平台汇编/机器码，并完成链接生成最终可执行程序。



### ▶ 步骤分解

14. 指令选择（Instruction Selection）

将 SSA 指令映射为具体平台（如 x86、ARM）的汇编代码



15. 寄存器分配（Register Allocation）

为变量分配物理寄存器或栈空间，构造函数栈帧



16. 汇编生成与链接

- 生成汇编 `\\.s` 或目标文件 `\\.o`

- 调用 Go 自带或外部链接器生成平台可执行文件（ELF/Mach\\-O/PE）



### ▶ 最终产物

最终平台可执行文件

---

## 五、流程图





---

## 六、总结与扩展

| **编译阶段** | **用途** | **产物** |
| --- | --- | --- |
| 前端 Front\\-End | 理解源码、构建 AST | AST \\+ 类型 \\+ 符号表 |
| 中端 Middle\\-End | 优化语义结构、生成 SSA | SSA IR |
| 后端 Back\\-End | 生成集聚码/执行文件 | 可执行文件 \\(ELF/Mach\\-O\\) |

Go 编译器的执行流程体现了其在**工程化、可移植性与优化能力**之间的平衡。

理解编译器从源码到机器码的转换机制，不仅能提升我们对语言本身的理解，也有助于我们编写更高效的代码。

', 'https://vdbapmvz0i.feishu.cn/docx/Iw2RdMLptox4VoxfDK0c4v6hnmg', 'go_lifecycle', 'clack', '编译器', 3, 2, '2025-08-02 13:00:19', '2025-08-12 14:13:12');
INSERT INTO miniblog.article (id, title, content, external_link, section_code, author, tags, pos, status, created_at, updated_at) VALUES (578232900051284526, '生命周期（下）：运行时调度与退出机制', '# Go 程序生命周期：运行时的执行流程全景解析

在上一文中我们完整梳理了 Go 编译器如何从源码生成可执行文件。

这一篇，我们将深入分析 Go 程序在编译完成后，从加载、执行到终止的运行时全过程，并结合 goroutine、defer、panic、shutdown 等机制逐步展开。

---

## 一、Go 程序运行期总览

Go 程序从二进制启动到退出，经历以下完整阶段：

```Plain Text
🟡 加载阶段（变量初始化 + init 函数）
🟢 执行阶段（main.main 执行 + goroutine 并发）
🔴 终止阶段（defer 执行、panic 处理、资源释放）
```

这些阶段并非单一函数执行顺序，而是由 Go runtime 驱动的运行时生命周期，具备强工程约束和系统抽象能力。

---

## 二、🟡 加载阶段：变量初始化与 init 执行



### A\\. 包初始化策略（深度优先 \\+ 包内顺序）

当程序启动时，Go runtime 会根据 `main` 包的依赖图，采用**深度优先遍历（DFS）**的方式依次初始化依赖包。

> 深度优先：先初始化被依赖的最底层包，逐层向外。
> 
> 



**每个包的初始化流程为：**

- 初始化所有包级变量（`var`），按代码出现顺序执行；

- 执行该包的所有 `init\\(\\)` 函数，按出现顺序依次执行；



注意：同一包内 多个文件的 init 函数，顺序由编译器收集 AST 时的顺序决定，通常遵循文件名排序。

```Go
// a.go
var A = initA()
func init() { fmt.Println("init A") }

// b.go
var B = initB()
func init() { fmt.Println("init B") }
```

这两个文件的 `var` 和 `init\\(\\)` 的执行顺序依赖包编译时文件排序，需谨慎。



### B\\. init 函数的设计用途

- **系统配置检查**：比如是否设置了必要的环境变量，如：

```Go
func init() {
    if os.Getenv("ENV") == "" {
        panic("ENV not set")
    }
}
```

- **注册机制（plugin/handler 注册）**：如数据库驱动注册、HTTP 路由注册：

```Go
func init() {
    http.HandleFunc("/health", healthHandler)
}
```

- **工厂函数注册**：比如 `image\\.RegisterFormat`，`sql\\.Register`。



### C\\. 加载阶段注意事项

- **`const`**** 是在编译期完成的，不在运行时执行；**

- **`init\\(\\)`**** 不能接受参数或返回值，不可被显式调用；**

- `init\\(\\)` 中的副作用逻辑应尽量精简，避免阻塞或执行外部请求；

- 循环 import 不会执行 init，会直接编译失败（import cycle not allowed）。



---

## 三、🟢 执行阶段：main 函数与 GPM 并发调度



### A\\. 主 goroutione：启动主goroutione 执行 main\\.main\\(\\)

完成所有依赖包的初始化后，Go runtime 会调用 `main\\.main\\(\\)` 函数，程序正式进入主逻辑阶段。

主函数的执行入口即为 **主 goroutine**（main goroutine），它是程序中第一个调度执行的用户协程。

```Go
func main() {
    fmt.Println("Program started")
    go worker()
}
```



### B\\. 用户级 goroutine：创建用户级 goroutine，并发执行业务功能

Go 支持通过 `go` 关键字轻松创建协程：

```Go
go func() {
    fmt.Println("Hello from goroutine")
}()
```

每一个 goroutine 是一个独立的执行单元，由 Go 的 runtime 调度器管理，而非操作系统直接调度线程。



### C\\. 案例：并发策略实现的搜索器

在主 goroutione 中拉取数据源，启用用户级 goroutine 并发的执行搜索功能。

```Go
package main

import (
    "log"
    "os"

    _ "github.com/yshujie/goinaction/searcher/matcher/sub"
)

// init 函数在 main 函数调用前执行
func init() {
    log.Println("in seatcher init")

    // 记录日志
    log.SetOutput(os.Stdout)
}

// main 函数，程序入口
func main() {
    log.Println("in searcher main")

    // preform the search for the specified term
    Search("president")
}

```

```Go
package main

import (
    "log"
    "sync"

    d "github.com/yshujie/goinaction/searcher/data"
    m "github.com/yshujie/goinaction/searcher/matcher"
)

// seatch 函数，执行搜索功能
func Search(seatchTerm string) {
    // 拉取数据源
    feeds, err := d.RetrieveFeeds()
    if err != nil {
        log.Fatal("retrieve feeds fail, error: ", err)
    }

    // 创建 waitGroup，设置根据 feeds 搜索进行等待
    var waitGroup sync.WaitGroup
    waitGroup.Add(len(feeds))

    // 遍历 feeds，选取对应的 matcher 进行搜索，将搜索结果存入 results 中
    results := make(chan *m.Result)
    for _, feed := range feeds {
        // 选择数据匹配器
        matcher := m.SelectMatcher(feed.Type)

        // 启用 goroutine 去执行搜索
        go func(matcher m.Matcher, feed *d.Feed) {
            m.Match(matcher, feed, seatchTerm, results)
            waitGroup.Done()
        }(matcher, feed)
    }

    // 启动搜索等待协程，搜索结束后关闭 results 通道
    go func() {
        // 等待 waitGroup 结束
        waitGroup.Wait()

        close(results)
    }()

    // 展示查询结构
    display(results)
}

// display 展示查询结构
func display(results chan *m.Result) {
    for result := range results {
        log.Printf("%s:\\n%s\\n\\n", result.Field, result.Content)
    }
}

```



---

## 四、🔴 终止阶段：defer 执行、panic 恢复、资源释放



### A\\. 深入理解 defer 的执行机制

Go 设计 `defer` 的初衷，是让**资源的申请与释放逻辑靠得更近**，提升代码可读性与健壮性。这体现了 Go 的工程设计理念：**鼓励写出安全、简洁、顺序清晰的代码**。



**传统做法：**

```Go
f, err := os.Open("file.txt")
if err != nil {
    return err
}
// ...使用 f ...
f.Close() // 离资源申请位置较远，容易遗漏
```

**使用 ****`defer`****:**

```Go
f, err := os.Open("file.txt")
if err != nil {
    return err
}
defer f.Close() // 资源释放写在申请之后，结构清晰

// ... 其他业务逻辑 ...
```



---

#### 被 `defer` 注册的函数，在**当前函数返回前执行**

`defer` 注册的函数，会入 defer 函数栈，在当前函数执行完毕，返回前再执行。

```Go
func main() {
    result := f()
    fmt.Println("f() returned:", result)
}

func f() int {
    fmt.Println("start f()")
    defer fmt.Println("defer in f()")
    fmt.Println("end f()")
    return 42
}

// 输出：
// start f()
// end f()
// defer in f()
// f() returned: 42
```



---

#### `defer 与 return 的执行顺序：`**`先执行 return 参数赋值，后执行 defer；`**



**先执行 return 参数赋值，后执行 defer 声明的函数**：`return x` 会先将 `x` 的值**复制给返回值**，然后再执行 `defer` 声明的函数。

```Go
func f() int {
    x := 5
    defer func() {
        x += 1
    }()

    return x
}

// 输出：5
```



**特例，带命名返回值时的 defer 修改**：命名返回值 `x` 是作用于整个函数体的变量，`defer` 修改的是这个变量，最终返回 `6`。

```Go
func f() (x int) {
    defer func() {
        x += 1
    }

    return 5
}

// 返回值为 6
```



---

#### 多个`defer`的执行顺序：**LIFO（后进先出）**

- 每次声明 `defer` 都会将函数入栈；

- 在函数返回前，按 LIFO 顺序，先进后出的执行；

```Go
func f() {
    defer fmt.Println("1")
    defer fmt.Println("2")
    defer fmt.Println("3")
}
// 输出：3 2 1
```

---

#### `defer` **在注册时就立即计算参数：**

**`defer`**** 在注册时就立即计算参数**，如：`fmt\\.Println\\(\\&\\#34;defer:\\&\\#34;, x\\)` 在 defer 注册时就把 `x=10` 捕捉住了，和后面的 `x=20` 无关。

```Go
func main() {
    x := 10
    // 在注册 defer 时，x 的值就被传递到函数内部了
    defer fmt.Println("defer:", x)
    
    // x 变量更新，不会影响上述 defer 中的 x 参数
    x = 20
    fmt.Println("x:", x)
}

// 输出：
// x: 20
// defer: 10
```



**而如果想捕捉最终值，使用 函数闭包：**

```Go
func main() {
    x := 10
    // 使用闭包函数，闭包函数的执行在 main 函数返回之前，此时 x 参数受后面代码的影响
    defer func() {
        fmt.Println("defer:", x)
    }()
    
    // x 重新复制，影响闭包函数内部的 x 变量
    x = 20
    fmt.Println("x:", x)
}

// 输出
// x: 20
// defer: 20
```



---

#### 遇到 `os\\.Exit\\(n\\)` 时程序立即退出，无法执行 `defer`

`os\\.Exit\\(n\\)` 会**立即终止程序进程，**不会执行任何 `defer` 注册的清理逻辑。

```Go
package main

func main() {
    defer fmt.Println("this defer will NOT be printed")

    fmt.Println("before os.Exit")
    os.Exit(1)
}

// 输出：
// before os.Exit
```



---

### B\\.`panic`/`recover`  与 `defer` 配合，捕捉异常

#### 核心说明：

- 一旦 `panic` 触发，Go 会从当前函数向上层函数展开“调用链终止”，并执行 **所有已经注册的 defer**；

- 在 defer 中使用 `recover\\(\\)` 可捕获 panic 并终止传播；

- 若没有 `recover\\(\\)`，panic 将继续向上传递，最终导致程序崩溃并打印堆栈信息；

- `recover\\(\\)` 只能在 **defer 函数中生效**，否则为 `nil`。



### ✅ 案例：使用 defer \\+ recover 捕捉 panic，防止程序崩溃



```Go
package main

func main() {
    fmt.Println("Program started")
    risky()
    fmt.Println("Program continued after recover")
}

func risky() {
    // 定义 defer 延迟执行函数
    defer func() {
        // 在 defer 中使用 recover(), 捕获 panic，终止向上传播
        if r := recover(); r != nil {
            fmt.Println("Recovered in defer:", r)
        }
    }()

    fmt.Println("About to panic...")
    panic("something went wrong in risky()")

    // 以下语句永远不会执行
    fmt.Println("This line will not run")
}

// 输出：
// Program started
// About to panic...
// Recovered in defer: something went wrong in risky()
// Program continued after recover
```



---

### C\\. 用户级 goroutine 的清理



#### 📌 为什么要清理用户级 goroutine？

一旦主 goroutine 所在的 `main\\(\\)` 函数 **返回**，整个 Go 程序的 **进程就会立刻退出**，**不会自动等待其他 goroutine** **执行完毕，所有用户级 goroutine 都会被强制终止**，**不会执行任何 defer，不会等待未完成的任务**。



#### 🧠 理解机制

Go 程序的生命周期由主函数 `main\\.main\\(\\)` 控制：

- `main\\(\\)` 是主 goroutine 的执行体；

- Go runtime 在 `main\\(\\)` 返回后，会调用 `runtime\\.exit\\(\\)` 直接终止整个程序；

- 所有正在运行、阻塞或延迟中的 goroutine（包括文件写入、网络请求、数据库提交）都会被立即终止；

- 不会等待 defer、recover 或 goroutine 正常退出。



#### ✅ 正确方式：阻塞主协程直到任务完成

**用 ****`sync\\.WaitGroup`**** 或 ****`context`**** 等机制，让主协程 “等一等”，待所有用户级 goroutine 执行完毕后，主 goroutine 再结束。**



#### ✅ 案例：context \\+ WaitGroup 管理 goroutine 生命周期

```Go
package main

func main() {
    ctx, cancel := context.WithCancel(context.Background())
    var wg sync.WaitGroup

    for i := 1; i <= 3; i++ {
        wg.Add(1)
        // 启动 goroutine，执行任务
        go worker(ctx, i, &wg)
    }

    time.Sleep(2 * time.Second) // 模拟运行一段时间
    fmt.Println("Sending shutdown signal to workers...")
    cancel() // 取消所有 goroutine

    wg.Wait() // 主 goroutine 等待所有用户级 goroutine 退出
    fmt.Println("All workers stopped. Exiting program.")
}

// 任务执行者
func worker(ctx context.Context, id int, wg *sync.WaitGroup) {
    // 注册 defer，执行完毕
    defer wg.Done()
    
    for {
        select {
        case <-ctx.Done():    // 接收到执行完毕信号
            fmt.Printf("Worker %d received shutdown signal.", id)
            return
        default:    // 其他信号
            fmt.Printf("Worker %d is working...", id)
            time.Sleep(500 * time.Millisecond)
        }
    }
}


// 输出：
// Worker 1 is working...
// Worker 2 is working...
// Worker 3 is working...
// ...
// Sending shutdown signal to workers...
// Worker 2 received shutdown signal.
// Worker 3 received shutdown signal.
// Worker 1 received shutdown signal.
// All workers stopped. Exiting program.
```



---

### D\\. 程序退出路径总结

| **方式** | **特点** |
| --- | --- |
| main\\(\\) 返回 | 正常退出，退出码 0 |
| panic\\(\\) 未处理 | 非正常退出，打印堆栈，返回非 0 |
| os\\.Exit\\(n\\) | 立即退出，跳过 defer、跳过 GC、无日志 |

---

## 五、运行时执行顺序概览

```Plain Text
🟡 加载阶段
- 深度优先加载所有包
- 每包执行 var 初始化 + init()

🟢 执行阶段
- 启动 main.main()
- 并发 goroutine 调度
- GPM 模型执行

🔴 终止阶段
- defer 栈式执行（LIFO）
- panic/recover 容错机制
- 手动退出（os.Exit）或优雅关闭
```



---



通过理解 Go 程序在运行期的详细执行流程——从加载依赖、初始化变量，到并发调度与终止回收——我们能够编写更可靠、更具可控性的程序。

', 'https://vdbapmvz0i.feishu.cn/docx/HJ2qdqC7Uoc2B2xYQ6LcJunPn3g', 'go_lifecycle', 'clack', '运行时', 2, 2, '2025-08-03 09:07:46', '2025-08-12 14:13:12');
INSERT INTO miniblog.article (id, title, content, external_link, section_code, author, tags, pos, status, created_at, updated_at) VALUES (578714209538290222, 'Go 字符串（上）：结构、编码与类型转换', '# 深入理解 Go 字符串：结构、编码与高效处理全景图

字符串，几乎是我们最常使用的数据类型。使用字符串数据类型时我常有这些疑问：

- C 语言字符串是以 `\\\\0` 结尾的字符，Go 语言的字符串类型是如何设计的？有什么不一样呢？又有哪些特点呢？

- Go 语言中 bit, byte, rune, string 到底有什么关联？ 为什么要这么设计？

- 我们经常使用的字符串遍历、拼接、截取、比较等等操作，内部是如何实现？又有哪些坑呢？



本文将从 Go 字符串的结构出发，结合 Unicode 与 UTF\\-8 编码规则，深入讲解字符串在内存中的布局、常用操作背后的机制，并从性能角度对三种拼接方案进行横向对比，帮助你写出更高效、更安全的字符串处理逻辑。



---



### 一、Go 语言字符串的本质

#### C 语言字符串 VS Go 语言字符串

通过对比的方式可以更好的理解，我们将 C 语言字符串与 Go 语言字符串来对比对比：

- **C 语言**其实没有提供字符串这种原始数据类型，而**是以字符串字面值或以 ****`\\\\0`**** 结尾的字符类型数组来呈现的**；

- **Go 语言**中设计了原始的字符串数据类型，**它是由 len\\(字节长度\\) 和 str \\(原始数据的指针\\) 所组成的标头，用于存储数据流、表示字符含义。**



C 语言中的字符串，就是字符串字面量 或 以 `\\\\0` 结尾的字符类型数组：

```C
# define GO_SLOGAN "less is more"
const char * s1 = "hello, gopher"
char s2[] = "I love go"
```



Go 语言中的字符串，通过 `stringStruct` 的原始数据指针，将数据存储在底层数据结构中：

```Go
// $GOROOT/src/runtime/string.go
type stringStruct struct {
    str unsafe.Pointer // 指向底层 UTF-8 字节数据
    len int            // 字节长度
}
```





#### Go 语言字符串变量如何在内存中存储数据？

在声明 string 类型变量后，Go 运行时会创建 stringStruct 实例来存储变量数据：

```Go
var s string = "hello"
```

****





#### “字节” 与 “字符”：从两个角度看 Go 语言字符



我们知道计算机只能存储二进制数据，所以无论英文、中文，还是其他语言文字，都需要进行编码后，以二进制的形式存储在计算机当中。



Go 语言所采用的编码方案是怎样的呢？

- Go 语言使用 **Unicode 字符集** 作为字符集基础，为所有语言字符分配全局唯一的编号，称为 **Unicode 码点（code point）**。；

- **Go 语言中的字符串类型，在底层使用 UTF\\-8 编码 存储 Unicode 码点，编码结果以 \\[\\]byte 字节序列 的形式存放在内存中**；

- 在网络传输或文件写入时，Go 会直接处理 **UTF\\-8 编码**后的字节序列，具有跨平台、兼容 ASCII 等优点；

- 在需要展示、遍历或处理字符串时，Go 会通过 **UTF\\-8 解码** 将底层字节序列还原为字符（rune）序列，这个解码过程是动态完成的，例如在 `for range` 遍历时自动触发。



> 注：
> 
> - Unicode 是「字符集规范」，不规定如何编码；编码交给 UTF\\-8、UTF\\-16、UTF\\-32 处理；
> 
> - UTF\\-8 编码解决的是 Unicode 码点值在计算机中如何存储和表示（位模式）的问题，UTF\\-8 编码使用的字节数量从 1 个到 4 个不等来表示 Unicode 码点：
> 
>     - 前 128 个与 ASCII 字符重合的码点（U\\+0000\\~U\\+007F）使用 1 个字节表示；
> 
>     - 带变音符号的拉丁文、希腊文、西里尔字母、阿拉伯文等使用 2 个字节来表示；
> 
>     - 东亚文字（包括汉字）使用 3 个字节表示；
> 
>     - 极少使用的语言的字符则使用 4 个字节表示。
> 
> 



总结一下：

- 以`字节`维度看字符串：

    - **字符串可以看作是一个字节数组 （\\[\\]byte），使用 UTF\\-8 编码方案 对 Unicode 字符集的码点进行编码，将编码后的数据按照字节维度进行存储、传输的。**

- 以`字符`维度看字符串：

    - **字符串可以看作是一个字符序列（\\[\\]rune），将底层数据流按照 UTF\\-8 方案逐一解码，解码后的每一个结果都是一个字符（Unicode 码点），将解码后的字符集按照字符维度展示、遍历。**



**string 是 UTF\\-8 编码后的只读 byte 切片（标头结构 \\+ 数据）**

**\\[\\]rune 是 Unicode 码点切片（每个元素是 int32）**

---



### 二、Go 语言字符串的特点

#### 特点一：Go 语言字符串是只读的、声明之后不再发生改变

Go 语言规定，字符串类型的值在其生命周期中是不可改变的。

也就是说，我们在声明了字符串变量后，无法通过这个变量去改变它对应的字符串的值，举个例子：

```Go
// 声明变量
var s string = "hello"

// 通过变量，去改变字符串的值
s[0] = "H" // ❌ 编译错误：cannot assign to s[0]
```



当然，这不代表无法改变字符串变量的值，我们可以通过重新给字符串变量赋值，来覆盖原来的值：

```Go
// 声明变量
var s string = "hello"

// 重新给变量赋值
s = "Hello"
```



#### 特点二：Go 语言的字符串，获取字符串长度的时间复杂度是 1

这个特点是相较于 C 语言而言的：

- 在 C 语言中，获取字符串长度时，需要遍历字符串中的每一个字符并计数，直至遇到 \\`\\\\0\\` 为止，时间复杂度为 n；

- 在 Go 语言中，由于字符串类型中记录了当前字符串的字节长度 \\`stringStruct\\.len\\`，所以获取字符串长度时只需要拿 \\`stringStruct\\.len\\` 的值就好了，时间复杂度为 1 。



#### 特点三：对非 ASCII 字符提供原生支持，消除了源码在不同环境下显示乱码的可能

Go 语言源文件默认采用的是 Unicode 字符集，Unicode 字符集是目前市面上最流行的字符集，它囊括了几乎所有主流非 ASCII 字符（包括中文字符）。

Go 字符串中的每个字符都是一个 Unicode 字符，并且这些 Unicode 字符是以 UTF\\-8 编码格式存储在内存当中的。

通过这种通用的字符集和编码方案，消除了源码在不同的环境下显示乱码的可能性。



---



### 三、与字符相关的数据类型

#### （1）`bit`, `byte`, `rune`,  `string` 对比

| **维度** | **`bit`****（比特）** | **`byte`****（字节）** | **`rune`****（字符）** | **`string`****（字符串）** |
| --- | --- | --- | --- | --- |
| **含义** | 最小信息单位（0 或 1） | 存储单位（8 bit） | Unicode 码点（字符） | 字节序列构成的文本 |
| **Go 中的类型** | 无专门类型（隐含） | `byte` 是 `uint8` 别名 | `rune` 是 `int32` 别名 | `string` 内建类型 |
| **占用空间** | 1 bit | 8 bit = 1 byte | 32 bit = 4 byte（逻辑） | len\\(s\\) bytes（取决于 UTF\\-8 编码） |
| **表示范围** | 0 或 1 | 0 \\~ 255 | Unicode: 0 \\~ 0x10FFFF | 任意长度的 UTF\\-8 编码字符序列 |
| **用于字符表达** | ❌ | ✅（ASCII） | ✅（所有 Unicode 字符） | ✅（字符组合，表示完整文本） |
| **与 Unicode 关系** | ❌ | ✅（用于 UTF\\-8 编码） | ✅（就是 Unicode 码点） | ✅（存储 UTF\\-8 编码后的 Unicode 字符） |
| **应用场景** | 逻辑控制、布尔判断 | 网络传输、文件存储、数组 | 字符遍历、文本分析、解码 | 文本处理、输出、传参 |
| **是否可组合** | ❌ | ✅（构成切片） | ✅（切片/数组） | ✅（切片可组合，拼接生成新字符串） |

**注意：**

- `bit` 只是逻辑单位，Go 没有直接的 `bit` 类型，但可以通过位运算操作某个 `byte` 或 `int` 的某一位；

- `byte` 是最基础的存储单位，很多 I/O 接口用 `\\[\\]byte`；

- `rune` 是逻辑字符单位，本质是 Unicode 码点，**和 UTF\\-8 的编码解码是强相关的**；

- `string` 是实际文本表达形式，本质是 UTF\\-8 编码的 `\\[\\]byte`，但只读，不可变。



#### （2）`\\[\\]byte` 和 `string` 的相互转换

字符串和字节切片的转换看起看很简单，但底层却可能设计内存分配和数据拷贝。底层原因在于：**字符串是不可变的，字节切片是可变的，**这就意味着：

- 每次将字节切片转换为字符串时，Go 运行时都会重新开辟一份内存空间，并将字节切片的数据拷贝到新的内存空间中去；

- 每次将字节切片转换为字符串时，也需要给新的字节切片创建新的内存空间，并将字符串数据复制到字节切片中去。



- **字符串转字节切片**

```Go
// 声明字符串
var s string = "hello"

// 将字符串强制转化为字节切片
b := []byte(s)

// 获取字节切片数据
fmt.Print("b[0]:", b[0])

// 输出：b[0]: 104
```

- **字节切片 转 字符串**

```Go
// 声明字节切片
var b []byte = []byte{\'h\', \'e\', \'l\', \'l\', \'o\'}

// 将字节切片强制转换为字符串
s := string(b)

// 获取字符串的值
fmt.Print("string is ", s)

// 输出：string is hello
```



**这种转换方式带来的问题：**

- 性能开销：内存分配和数据拷贝都是非常消耗性能的操作，频繁的转换会导致较大的性能开销；

- 内存占用：频繁的内存分配也可能导致内存碎片，可能导致程序内存占用过高；

- GC 压力：大量的临时对象会增加 GC 的负担，导致 GC 暂停时间变长，影响程序的响应速度。



**编译器的性能优化：零拷贝**

**零拷贝的核心思想是，如果编译器能确定转换后的结果不会被修改，或者只是临时使用，那么就可以让转换后的类型直接共享原始类型的底层字节数据，从而避免内存分配和数据拷贝。**



#### （3）`\\[\\]rune` 和 `string` 的相互转换

在处理字符串和字符切片的相互转换，需要注意：

- `string`：本质是 **UTF\\-8 编码的只读字节序列**；

- `\\[\\]rune`：是 **Unicode 码点（字符）的切片**，即字符视角的展开。



**字符串转字符切片（string → \\[\\]rune）**

字符串转字符切片时，实际调用的是 `utf8\\.DecodeRuneInString` 逐个解码：将 UTF\\-8 编码的字节序列解析为 `rune`（Unicode 码点）。

- 解码过程中每个字符都可能是 1\\~4 个字节，需要反复读取、判断字节前缀位，属于「不等长解码」；

- 最终会创建一个新的 `\\[\\]rune` 切片，占用额外内存。

**注意：该过程不仅需要遍历，还要进行变长判断与 rune 拷贝，性能低于直接操作 ****`\\[\\]byte`****。**

```Go
// 声明字符串
var s string = "hello 世界"

// 字符串转字符切片
r := []rune(s)

// 输出字节切片
fmt.Print("rune is ", r)

// 输出：rune is [104 101 108 108 111 32 19990 30028]
```



**字节切片转字符串（\\[\\]rune → string）**

字节切片转字符串时，本质上是遍历 `rune` 切片，将每个 Unicode 码点重新编码为 UTF\\-8 字节，拼接这些字节生成新的字符串（只读的 `string` 类型）

```Go
// 声明字节切片
var r []rune = []rune{\'h\', \'e\', \'l\', \'l\', \'o\', \' \', \'世\', \'界\'}

// 字节切片强制转换为字符串
s := string(r)

// 输出字符串
fmt.Print("string is ", s)

// 输出：string is hello 世界
```



#### （4）string 与 \\[\\]rune、\\[\\]byte 之间的转换关系图

```Go
string
       /     \\
 []byte     []rune
```

- string → \\[\\]byte：字节拷贝

- string → \\[\\]rune：UTF\\-8 解码，构建 int32 切片

- \\[\\]rune → string：逐个编码，构建只读 UTF\\-8 字节序列

---



### 四、字符串的常见操作：

#### （1）字符串遍历

##### **i\\. 使用 for 循环遍历字节序列**

使用 **`for i := 0; i \\&lt; len\\(s\\); i\\+\\+`**：是按 **字节序列（byte）** 遍历，每次访问 `s\\[i\\]`，得到一个 `byte`。

- 纯粹的 **按字节访问**，每次访问 `s\\[i\\]`，得到一个 `byte` 类型

- 不关心 UTF\\-8 结构，只是逐字节读，速度快，但容易截断字符



```Go
s := "Hello 世界"

// 字节遍历
for i := 0; i < len(s); i++ {
    fmt.Printf("byte at %d: %x\\n", i, s[i])
}

// 输出：
// byte at 0: 48
// byte at 1: 65
// byte at 2: 6c
// byte at 3: 6c
// byte at 4: 6f
// byte at 5: 20
// byte at 6: e4
// byte at 7: b8
// byte at 8: 96
// byte at 9: e7
// byte at 10: 95
// byte at 11: 8c
```



##### **ii\\. 使用 for range 循环变量字符序列**

使用 **`for i, r := range s`**：是按 **字符序列（rune）** 遍历，Go 会自动 **按 UTF\\-8 解码字节流**，每次给你一个完整的字符（rune）。

- 内部使用 `utf8\\.DecodeRuneInString\\(s\\[i:\\]\\)` 来 **解码下一个 UTF\\-8 编码字符**

- 自动计算当前字符占了多少字节（1\\~4）

- `i` 是当前字符在原字符串中的字节偏移量

- `r` 是当前字符的 Unicode 码点（rune）



```Go
s := "Hello 世界"

// 字符遍历
for i, r := range s {
        fmt.Printf("rune at %d: %c (U+%04X)\\n", i, r, r)
}

// 输出：
// rune at 0: H (U+0048)
// rune at 1: e (U+0065)
// rune at 2: l (U+006C)
// rune at 3: l (U+006C)
// rune at 4: o (U+006F)
// rune at 5:   (U+0020)
// rune at 6: 世 (U+4E16)
// rune at 9: 界 (U+754C)
```





#### （2）字符串比较

Go 字符串类型支持各种比较关系操作符，包括 = =、\\!= 、\\&gt;=、\\&lt;=、\\&gt; 和 \\&lt;。

在字符串的比较上，Go 采用字典序的比较策略，分别从每个字符串的起始处，开始逐个字节地对两个字符串类型变量进行比较。

当两个字符串之间出现了第一个不相同的元素，比较就结束了，这两个元素的比较结果就会做为串最终的比较结果。如果出现两个字符串长度不同的情况，长度比较小的字符串会用空元素补齐，空元素比其他非空元素都小。



#### （3）字符串拼接

##### **i\\. 低效的字符串拼接方案： 使用 \\+ 或 \\+= 运算符**

字符串拼接最直接的方式是使用 \\+ 或 \\+= 运算符，但是，**在循环或需要拼接大量字符串片段的场景下，使用 \\+ 会非常低效，其本质原因还是字符串是不可变的。**

每次执行 result = result \\+ fragment，Go 运行时都需要：

- 分配一块新的内存，大小为 len\\(result\\) \\+ len\\(fragment\\)

- 将 result 的内容拷贝到新内存

- 将 fragment 的内容拷贝到新内存

- 让 result 指向这块新内存

- 旧 result 的内存成为垃圾，等待回收。

```Go
// 低速方式合并字符串
func strMergeLowSpeed(str ...string) string {
    fmt.Println("use low speed merge function")
    result := ""
    for _, s := range str {
        result += s
    }

    return result
}
```



##### **ii\\. 高效字符串拼接方案：strings\\.Join\\(\\)**

Go 提供了内置包 `strings` 中的 `Join\\(\\)` 函数，它将字符串切片 `elems` 中的所有元素，用指定分隔符 `sep` 拼接成一个新字符串。

```Go
func Join(elems []string, sep string) string
```



**使用场景：**

- 已经拥有一个 **`\\[\\]string`**** 切片**，且不需要频繁追加时；

- 尤其适合生成 CSV、路径、带分隔符的输出，如：

    - `\\&\\#34;a,b,c\\&\\#34;`

    - `\\&\\#34;dir1/dir2/dir3\\&\\#34;`

    - `\\&\\#34;hello world good morning\\&\\#34;`



**strings\\.Join 的性能分析**

- **底层已做内存预分配优化**，避免了频繁扩容和数据拷贝；

- 整体性能比手动用 `\\+` 或 `\\+=` 拼接 `N` 次要好很多；

- 不如 `strings\\.Builder` 灵活，但在处理现有切片时更高效、更简洁。



```Go
// 高效拼接字符串的方式 3：strings.Join()
func strMergeWithJoin(strs []string, sep string) string {
    fmt.Println("use strings.Join() to merge strings")
    return strings.Join(strs, sep)
}
```





##### **iii\\. 高效的字符串拼接方案：strings\\.Builder**

strings\\.Builder 类型是专门为高效构建字符串设计的。它内部维护一个可变的字节缓冲区（\\[\\]byte），在拼接过程中一直向字节缓冲区中追加数据，而最后通过 String\\(\\) 方法，将缓冲区中的数据转换为字符串进行输出。

**strings\\.Builder 的优势：**

- WriteString 方法直接将字符串的字节追加到内部缓冲区，避免创建大量临时字符串。

- 内部缓冲区会按需扩容，但扩容策略通常比 \\+ 运算符导致的频繁分配更高效。

- 可以通过 Grow 方法预先分配缓冲区大小，进一步减少扩容次数。

- 最后调用 String\\(\\) 方法时，它会返回一个指向内部缓冲区字节数据（或其副本，取决于实现细节和优化）的新字符串。

```Go
// 告诉方式合并字符串
func strMergeHighSpeed(str ...string) string {
    fmt.Println("use high speed merge function")
    // 字符串构造器
    var builder strings.Builder

    // 预分配 builder 缓冲区长度
    builder.Grow(10)

    for _, s := range str {
        builder.WriteString(s)
    }

    return builder.String()
}
```



##### Iiii\\. 三种字符串拼接方式全面对比总结

<table><tbody>
<tr>
<td>

拼接方式

</td>
<td>

底层原理

</td>
<td>

性能

</td>
<td>

特点

</td>
<td>

适用场景

</td>
</tr>
<tr>
<td>

`\\+=` / `\\+`

</td>
<td>

每次拼接都会分配新内存，复制旧字符串和新增部分，**创建临时对象多**

</td>
<td>

❌ 最差

</td>
<td>

- 每次 `s = s \\+ part` 都会新建内存块

- 会频繁触发内存分配和垃圾回收（GC 压力大）；

- 字符串越长，性能劣化越明显。

</td>
<td>

拼接 2\\~3 个短字符串

</td>
</tr>
<tr>
<td>

`strings\\.Join\\(\\[\\]T\\)`

</td>
<td>

底层统计总长度，**预分配内存一次性拼接**，无中间对象

</td>
<td>

✅ 较好

</td>
<td>

- 一次性计算所有子串总长度；

- 预分配最终结果空间；

- 拷贝各子串到结果中，仅拷贝一次。

</td>
<td>

- 已有切片要拼接

- 有固定分隔符的场景



</td>
</tr>
<tr>
<td>

`strings\\.Builder`

</td>
<td>

内部维护 `\\[\\]byte` 缓冲区，**追加操作不频繁分配内存**，支持动态增长

</td>
<td>

✅✅ 最优

</td>
<td>

- 高性能拼接方式；

- 内部维护 `\\[\\]byte` 缓冲区，避免频繁创建字符串；

- 可 `Grow\\(\\)` 预分配空间，进一步提升效率。

</td>
<td>

- 高性能需求

- 循环中不断追加内容

- 大量字符串拼接        

</td>
</tr>
</tbody></table>



---



字符串是 Go 语言中最常用的数据类型之一，深入理解其底层结构与行为机制，不仅能帮助我们写出更健壮的代码，也能在性能优化、字符处理、编码兼容性等方面少走很多弯路。

希望这篇文章能为你提供实用的认知体系，掌握从“看起来简单”的 string 到“理解背后的复杂”的核心路径。



', 'https://vdbapmvz0i.feishu.cn/docx/J9PgdGtHnoOaZnxEIEgcsqrZnlf', 'go_base', 'clack', '字符串', 1, 2, '2025-08-06 16:49:09', '2025-08-12 15:45:51');
INSERT INTO miniblog.article (id, title, content, external_link, section_code, author, tags, pos, status, created_at, updated_at) VALUES (579442688638595630, '数组与切片（上）：底层原理、性能差异与扩容机制', '# 深入理解 Go 数组与切片：底层原理、性能差异与扩容机制全解析

“如何处理数据序列”是每种编程语言都需要认真思考的事情。有些语言按照数据特性提供了多种专用类型，例如 Java 中的 `String`、`List`、`Set`、`Map` 等；而有些语言则将顺序和映射封装在统一的类型中，例如 PHP 的 `Array` ，Python 中的 `dict` 既能表示有序列表，也能表示关联数组。”



Go 语言是如何设计的呢？Go 语言不走 PHP `Array` 的“一把梭”，也不完全照搬 Java 的“接口家族”。它坚持**简单、显式、职责单一**的设计哲学，使用 Array、Slice、Map 三种数据类型，分别处理 定长数组、不定长数组视图、键值映射三种数据序列。



这篇文章我们一起对比着看一看 Array 和 Slice 两种数据类型。



---



### 类型的本质

#### Array：服务于底层的定长数组

`数组`是一种具有**固定长度**，**且存储相同类型元素**的数据序列。而 **Go 语言****`数组`****的本质，其实就是一段连续的内存块**，这段连续的内存块存储固定长度、类型相同 的元素。



例如，使用 `var arr \\[N\\]T` 声明数组，内存空间如下图所示：



**内存友好式的设计：**

我们知道 Go 语言的生命周期中包含编译期、运行时，尽早地确定内存空间的分配，则更有利于程序提升执行效率，减少内存浪费。`数组`要求在声明时便确定长度、元素类型，便可以让程序在编译期即可确定数组变量所占用的内存空间：

```Plain Text
数组变量的内存空间 = 单个元素的内存大小 * 元素个数
```



而数组变量在生命周期过程内不会更改数组长度，这也就说明不需要考虑数组变量的内存扩容、缩减问题，这样一来`数组`这种数据类型的职责便更加单一，就是为了存储数据。



**快速的访问方式：**

使用`数组` 存储数据，更重要的原因其**按索引 O\\(1\\) 访问速度。**因为元素在内存中连续存放，`arr\\[i\\]` 实际是 **起始地址 \\+ i × 元素大小** 的指针偏移计算。所以在数组中按照索引查询元素时速度非常快。

---



#### Slice：开发者友好的数组的视图

**`Slice`****（切片）的本质，其实是****`数组`****的视图，是****`数组`****的访问窗口。**

通过对`数组`的分析我们发现，`数组`这种数据类型使用起来很不方便：我们需要提前或者数组的元素个数；更重要的是声明之后长度便不能发生改变。

有没有办法既维护`数组` 的独立性，又满足开发者对变长数组的现实需求呢？那就给`数组` 开个可移动的访问窗口吧！这便是`Slice`（切片）数据类型。



**Slice 的底层实现：**

Go 语言`切片`在运行时其实是一个三元组结构，它在 Go 运行时中的表示如下：

```Go
type slice struct {
    array unsafe.Pointer
    len   int
    cap   int
}
```

- array: 是指向底层数组的指针；

- len: 是切片的长度，即切片中当前元素的个数；

- cap: 是底层数组的长度，也是切片的最大容量，cap 值永远大于等于 len 值。



### 声明/创建方式

#### 数组的声明方式

- 仅声明、不初始化：Go 运行时会默认给数组元素赋予**类型零值**

```Go
var arr [6]int
```

- 声明且初始化

```Go
var arr [6]int{1, 2, 3, 4, 5, 6}
```

- 省略数组长度的语法糖：Go 编译器会自动识别元素个数

```Go
var arr [...]int{1, 2, 3, 4, 5, 6}
```



#### 切片的创建方式

- **`make`**** 创建法**：使用 make 创建切片

```Go
var s = make([]int, 6, 10)
```

- **三索引切片法** 

    - **基于已有的数组创建新的切片：array\\[low : high : max\\]**

        ```Go
        var arr = [10]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
        var s1 = arr[3:7:9]
        ```

    - **基于已有的切片创建新的切片：slice\\[low: high: max\\] **

        ```Go
        var arr = [10]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
        var sl1 = arr[3:7:9]
        
        var sl2 = s1[1:3:6]
        ```

    - **三索引切片规则（**无论 `a` 是数组还是切片）：

        - **len** = `high \\- low`

        - **cap** = `max \\- low`

        - **取值范围**：

            - `0 \\&lt;= low \\&lt;= high \\&lt;= max \\&lt;= len\\(底层数组\\)`

            - `high` 和 `max` 都是**右开区间**，即 `a\\[low\\]` 包含，`a\\[high\\]` 不包含。

        - **max 限制**：

            - `max` 不能超过**底层数组**的长度（不是当前切片的长度）。



---



### 数组的特性

#### 数组类型判断

回顾数组的定义，数组有两个关键属性：**元素类型、数组长度。**而数组的类型判断也是根据这两个关系属性确定的：

- 如果两个数组，它们的数组元素类型相同，数组长度也一样，则可认为两个数组的类型是相同的；

- 若数组的元素类型 或 数组长度任意属性不同，则数组类型不一样。



举例说明：

```Go
// 声明并初始化数组 a1，数组长度为 3，数组元素为 int
a1 := [3]int{1, 2, 3}

// 声明并初始化数组 a2，数组长度为 3，数组元素为 int
a2 := [...]int{1, 2, 3}

// 声明并初始化数组 a3，数组长度为 5，数组元素为 int
a3 := [5]int{1, 2, 3, 4, 5}

// 声明并初始化数组 a1，数组长度为 3，数组元素为 string
a4 := [3]string{"a", "b", "c"}

// 声明 foo 函数，函数参数是长度为 3，元素类型为 int 的数组
func foo(arr [3]int) {}

foo(a1) // 正确
foo(a2) // 正确
foo(a3) // 错误：[5]int 与 函数foo参数的类型 [3]int 不是同一数组类型
foo(a4)//  错误：[3]string 与函数foo参数的类型 [3]int 不是同一数组类型
```



#### 数组的 `==` 比较

Go 语言规范里规定：

- 只有**长度相同、元素类型可比较**的数组才允许用 `==` 或 `\\!=`

- 比较规则是**从索引 0 到末尾**，依次比较每个元素是否相等

- 只要遇到一个元素不相等，就提前返回 `false`（短路）

举例：

```Go

a := [3]int{1, 2, 3}
b := [3]int{1, 2, 3}
c := [3]int{1, 2, 4}

fmt.Println(a == b) // true  → 逐个元素比较
fmt.Println(a == c) // false → 比较到索引 2 就返回 false
```

编译器会把 `a == b` 展开成类似：

```Go
(a[0] == b[0]) && (a[1] == b[1]) && (a[2] == b[2])
```

**性能注意：**

- 大数组比较的时间复杂度是 **O\\(n\\)**，如果数组很大，频繁比较会有性能成本。

- 对于大批量数据对比，可能用 `bytes\\.Equal`（配合 `unsafe` 转换）会更快，但要考虑内存对齐和类型安全。



#### 变量赋值、函数参数 \\&amp; 返回值

Go 语言的数组数据类型的本质是原始的，也就是说数组这种数据类型，其代表的就是其原始数据。所以**`数组`****数据类型的变量，在变量赋值、函数传参、传返回值时都是值传递。**



- **变量赋值：在变量赋值后，新变量的修改不会影响原变量**

```Go
// 声明数组类型变量 a1
a1 := [...]int{1, 2, 3}

// 将 a1 赋值给 a2，此时会将 a1 的数据 copy 一份给 a2
a2 = a1

// 更新 a2 的元素，不会影响 a1 的元素
a2[0] = 100

fmt.Printf("a1: %v \\n", a1) // 输出：a1: [1, 2, 3]
fmt.Printf("a2: %v \\n", a2) // 输出：a2: [100, 2, 3]
```



- **函数传参、传返回值：值传递，在参数、返回值在函数局部作用域内有效，对函数外不产生影响**

```Go
// 声明数组类型变量 a1
a1 := [...]int{1, 2, 3}

// 声明 foo() 函数
func foo (a [3]int) {
    a[0] = 100
    
    fmt.Printf("a: %v \\n")
}

// 调用 foo 函数，并将 a1 作为参数传入
foo(a1)
fmt.Printf("a1: %v \\n", a1)


// 输出：
// a: [100, 2, 3]
// a1: [1, 2, 3]
```



---



### 切片的特性



#### nil 切片 vs 空切片

什么是 nil 切片？什么是空切片呢？我们使用代码进行解释：

```Go
// sl1 为 nil 切片，零值是 nil
var sl1 = []int 

// sl2 为空切片，长度为 0，非 nil
var sl2 []int{}    
```

- **nil 切片**：Go 零值，尚未分配任何底层数组，常用来表示“还没有任何数据”，类似于数据库的 NULL

- **空切片**：已分配了零长度底层数组，表示“已经初始化，只是暂时没有元素”，类似于一个空集合 `\\[\\]`



##### **nil 切片 与 空切片的对比**

| **特性** | **nil 切片** | **空切片 \\(****`\\[\\]T\\{\\}`****\\)** |
| --- | --- | --- |
| **`len\\(\\)`** | 0 | 0 |
| **`cap\\(\\)`** | 0 | 0 |
| **与 ****`nil`**** 比较** | `true` | `false` |
| **内存分配** | 不分配底层数组 | 分配了一个零长度的底层数组 |
| **`append\\(\\)`**** 行为** | 会自动分配底层数组 | 会在已有的零长度底层数组上扩容或分配新数组 |
| **典型用途** | 表示\\*\\*“不存在”\\*\\* 或未初始化状态 | 表示已初始化但\\*\\*“为空”\\*\\* 的集合 |



##### nil 切片 和 空切片 与 nil 进行对比

```Go
var sl1 []int        // nil 切片
sl2 := []int{}       // 空切片

fmt.Println(len(sl1), cap(sl1), sl1 == nil) // 0 0 true
fmt.Println(len(sl2), cap(sl2), sl2 == nil) // 0 0 false
```



#### 变量赋值与参数传递

回顾切片的本质，我们发现切片其实只是数组的描述符，是一个标头。换句话讲**切片是引用数据类型，它自己保存的是描述信息，而不直接存储数据。**

```Go
type sliceHeader struct {
    data *T  // 指向底层数组的指针
    len  int // 当前切片的长度
    cap  int // 底层数组的容量
}
```



##### **赋值与参数传递**

将一个切片赋值给另一个切片，或者作为参数传递给函数时：

- Go 会**复制这个描述符**（data 指针、len、cap 都被复制）。

- 因为 `data` 字段指向的是同一段底层数组，所以两个切片变量共享这块数组。



##### **共享底层数组的影响**

- 如果对其中一个切片的元素进行修改（且未触发扩容），所有共享这块底层数组的切片都会看到变化：

```Go
a := []int{1, 2, 3}
b := a
b[1] = 99
fmt.Println(a) // [1 99 3]
```

- 如果触发了**扩容**（`append` 超过 cap），Go 会为新切片分配新的底层数组，这时就**与原切片“脱钩”了。**

    > 注：**详见扩容后新切片与原切片“脱钩”（链接：**[数组\\&amp;切片](https://vdbapmvz0i.feishu.cn/docx/EziFdMSKEoOuSqxTg4TcD9LEnhh#share-EWpEd6DlaoBNrbxCdQhcqbevni0)）
    > 
    > 



#### 自动扩容

在 Go 中，我们通常把切片当作“变长数组”来使用，而这种“变长”能力，是通过 **更新切片底层数组的指针** 实现的。



##### **扩容触发条件**

- **只有通过 Go 预定义的 append 函数向切片追加元素的过程中，才会触发切片实例的自动扩容**；

- 普通下标读写不会触发扩容：`s\\[i\\] = v`

- 如果访问的下标超出 `len\\(s\\)`，会触发 **运行时 panic**（越界访问）。



##### **扩容策略（Go 1\\.21 及之前版本）**

- **容量 \\&lt; 1024 元素**：扩容后容量 = `cap \\* 2`

- **容量 ≥ 1024 元素**：扩容后容量 = `cap \\* 1\\.25`（四舍五入为整数）

> Go 1\\.18 起，引入了更智能的增长策略，但整体趋势一致。
> 
> 





##### 扩容带来的副作用：

- **扩容后新切片与原切片“脱钩”**

    - 扩容会**分配新底层数组**，并将原切片内容复制到新数组中，这意味着：

        - 扩容后的新切片与原切片**不再共享**底层数组（脱钩）。

        - 对新切片的修改不会影响原切片。

```Go
package main

import "fmt"

func main() {
    s1 := []int{1, 2, 3， 4， 5}  // cap=3
    modifySlice(s1)
    fmt.Println("Outside:", s1)
}

func modifySlice(s []int) {
    s[0] = 9             // 修改第 1 个元素
    s = append(s, 4)     // 触发切片扩容，函数内切片的底层数组与原切片底层数组“脱钩”
    s[0] = 8             // 再次修改第 1 个元素
    fmt.Println("Inside:", s)
}


// 输出：
// Inside: [8 2 3 4]
// Outside: [9 2 3]
```

- 扩容带来额外的性能开销（内存分配\\+性能开销）

    - 扩容时会创建新的底层数组，并将原底层数组中的数据 copy 至新底层数组中，这意味着：

        - 若底层数组的数据量较大，数组数据 copy 可能带来额外的性能开销

        - 旧的底层数组未被及时清理，也可能带来内存浪费的问题







#### 预分配容量

既然自动扩容有性能开销（内存分配 \\+ 数据拷贝），那么如果我们在创建切片时就能预估到它最终大概需要多大容量，就可以提前分配，从而避免或减少后续 append 触发的扩容次数。



##### 使用带容量参数的 make 函数：

```Go
sl := make([]T, length, capacity)
```



如果你知道一个切片最终会存储约 1000 个元素：

```Go
// 方式一：无预分配容量
var sl1 []int
for i := 0; i < 1000; i++ {
    sl1 = append(sl1, i) // 可能触发多次扩容
}

// 方式二：预分配容量
sl2 := make([]int, 0, 1000) // 长度为0，容量为1000
for i := 0; i < 1000; i++ {
    sl2 = append(sl2, i) // 基本不会触发扩容 (除非1000次append中途有其他操作改变了容量)
}
```



#### for range 陷阱

切片与 for range 一起使用的方法我们再熟悉不过了，但如果 for range 过程中向切片内 append 元素，会发生什么呢？

```Go
package main

import "fmt"

func main() {
    a := make([]int, 5, 8)
    cnt := 0
    for i := range a {
        cnt++
        if i == 1 {
            a = append(a, 6, 7, 8)
        }
    }
    fmt.Println("cnt=", cnt) 
}
```



是 8 吗？在 i 为 1 时，代码又向切片 a 附加了 3 个新元素，使得切片的长度变为了 8。于是 for range 迭代 8 次，cnt 计数到 8 ？



经代码运行，我们看到最终 cnt 的值其实是 5。为什么会这样呢？

```Go
// fmt.Println("cnt=", cnt) 输出：cnt= 5
```



- 当我们使用 for range 去迭代切片变量 a 时，实际上 for range 后面的 a 是切片变量 a 的副本（以下以 a’ 代替），就像将一个切片变量以参数的形式传给一个函数一样，这是一个值拷贝的过程；

- 在 for range 循环过程中，切片 a 的副本 a’ 始终未变更过，它的长度始终为 5，因此 for range 一共就迭代了 5 次，所以 cnt 为 5；

- 而循环体中通过 append 追加的元素实际上是追加到了原切片 a 上了。即便 a 和 a’ 仍然共享底层数组，但由于 a’ 的长度是 5，for range 就只能迭代 5 次。



---



### 总结时刻

<table><tbody>
<tr>
<td>

特性维度

</td>
<td>

数组 \\(Array\\)

</td>
<td>

切片 \\(Slice\\)

</td>
</tr>
<tr>
<td>

核心差异

</td>
<td>

定长，大小是类型的一部分

`\\[5\\]int` ≠ `\\[10\\]int`

</td>
<td>

变长，引用底层数组的一部分，大小不是类型核心部分



</td>
</tr>
<tr>
<td>

内存布局

</td>
<td>

连续内存，大小固定

</td>
<td>

描述符（SliceHeader）\\+ 底层数组（可能共享）

</td>
</tr>
<tr>
<td>

灵活性

</td>
<td>

低，长度不可变

</td>
<td>

高，长度可变，容量可自动扩展（通过 `append`）

</td>
</tr>
<tr>
<td>

性能

</td>
<td>

访问快（直接索引），内存局部性好；

传参/赋值开销大（全量拷贝）

</td>
<td>

访问稍慢（间接访问）；

传参/赋值开销小（拷贝描述符）；

`append` 可能有扩容开销

</td>
</tr>
<tr>
<td>

安全性

</td>
<td>

编译期/运行时边界检查

</td>
<td>

运行时边界检查（`len`）；

共享底层数组可能引入复杂性

</td>
</tr>
<tr>
<td>

内置操作

</td>
<td>

少

</td>
<td>

丰富（如 `append`, `copy`）

</td>
</tr>
<tr>
<td>

零值

</td>
<td>

元素均为零值

</td>
<td>

`nil`（Data 指针为 0x0，即 nil，Len=0，Cap=0）

</td>
</tr>
</tbody></table>

- 数组：

    - 胜在性能稳定、内存布局简单、类型强约束带固定长度；

    - 劣在不够灵活、传参拷贝代价高。

    - 适用于大小固定且对性能有极致要求的场景，或作为其他数据结构的底层存储。

- 切片：

    - 胜在灵活、方便、传参代价低；

    - 劣在性能有波动（扩容）、内存管理相对复杂、存在一些使用陷阱。

    - 在 Go 中处理序列数据的首选和惯用方式。

', 'https://vdbapmvz0i.feishu.cn/docx/EziFdMSKEoOuSqxTg4TcD9LEnhh', 'go_base', 'clack', '数组,切片', 3, 2, '2025-08-11 17:25:56', '2025-08-12 15:00:31');
INSERT INTO miniblog.article (id, title, content, external_link, section_code, author, tags, pos, status, created_at, updated_at) VALUES (579555062699799086, '内存分配器：make 和 new 的本质与区别', '# 内存分配器：make VS new 的本质与区别

在 Go 语言中，我们几乎每天都会用到 `make` 和 `new` 来创建对象，在使用时我经常会有如下疑问：

- `make` 和 `new` 有什么区别呢？

- `make` 和 `new` 在内存分配时是不是有什么不同的操作？

- 为什么 Go 语言要搞出两种方式来创建对象？



我们带着这些疑问进入本篇文章，一起分析分析 `make` 和 `new` 的本质、内存操作、返回值、使用范围。



---



### `make` 和 `new` 的本质：



**`make`**** 和 ****`new`**** 都是 Go 语言中内置的分配内存空间的函数，不过****`make`**** 是专门的“集合类型初始化器”，而 ****`new`**** 是通用的“零值分配器”：**

- `make\\(\\.\\.\\.\\)`：只用于 `slice/map/chan`，把其 **header \\+ 底层结构**建好，返回 **值**（非指针），可立即使用；

- `new\\(T\\)`：只做“**零值初始化**”并返回 `\\*T`，不负责把 **引用类型字段**（map/slice/chan）的内部结构建好；是否分配到堆上由逃逸分析决定，不等价于“必在堆上”。

| **维度** | **`make`** | **`new`** |
| --- | --- | --- |
| **使用对象** | 只能用于内建的三种引用类型：<br><br>- `slice`<br><br>- `map`<br><br>- `chan` | 可用于任何类型，包括：<br><br>- 基本类型<br><br>- 自定义 struct<br><br>- 数组<br><br>- 等等 |
| **初始化行为** | - 为 **slice、map、chan** 分配内存空间<br><br>- 完成**底层结构初始化**<br><br>    - 切片的底层数组<br><br>    - map 的哈希表<br><br>    - chan 的环形队列 | - 为 **任意类型** `T` 分配一块内存<br><br>- **将该内存空间置为零值（zero value）** |
| **返回值** | **值本身（非指针）** | **类型的指针（****`\\*T`****）** |
| **零值状态** | 返回的值可直接使用，不为 `nil` | 指针指向的值是零值（可能内部引用字段是 `nil`），需要手动初始化 |



---



### 分配和初始化细节（编译器 \\&amp; runtime 视角）：

#### `make` 的分配\\&amp;初始化细节：

- **编译器限制**：只能作用于 `slice`、`map`、`chan` 三类引用类型。

- **分配动作**：

    - 创建引用类型的 **header**（切片头、map 头、chan 控制块）

    - 为底层存储（数组、哈希表、缓冲区）分配空间

    - 绑定 header 和底层存储

- **结果**：

    - **返回的就是已经可用的值（非指针），****`len`****、****`cap`****、内部状态已设置好**

```Go
s := make([]int, 3) // 创建切片，len=3, cap=3, 元素全是 0
m := make(map[string]int) // 创建 空map, 可直接赋值
c := make(chan int, 5) // 创建 chan，缓冲区容量5
```



#### `new` 的分配\\&amp;初始化细节：

- **编译器行为**：创建一个类型 `T` 的零值空间，并返回 `\\*T`

- **分配动作**：

    - 分配一块内存（可能在栈或堆上，取决于逃逸分析）

    - 用类型零值填充

- **结果**：

    - **返回 ****`\\*T`****，其中内容全是零值（引用类型字段是 ****`nil`****）**

```Go
// p 是切片的指针，p != nil，但 *p == nil，不能直接用 append
p := new([]int)

// q 是数组的指针，指向零值数组
q := new([3]int)

// r 是结构体指针，&{0}
r := new(struct{ x int }) 
```



---



### `make` 和 `new` 的内存布局对比：



#### 创建切片：

- `make`分配并初始化 slice header 和底层数组，设置好 `len`/`cap`，可直接使用。

- `new` 仅分配零值 header（`ptr=nil, len=0, cap=0`），**底层数组未初始化**；但可通过 `append` 自动触发分配。



**注意：虽然通过 ****`new`**** 创建的切片没有完成初始化，但其实可以直接使用 append\\(\\) 追加元素**





#### 使用 make 和 new 创建 map：

- `make` 分配并初始化 `hmap` 结构和 buckets，可直接读写。

- `new` 仅分配零值 `hmap` 指针，未建 buckets；**写入会 panic，读 nil map 返回零值**



**注意：虽然通过 ****`new`**** 创建的 map 不可直接写入，会报 panic；读取 nil map 则返回类型零值**



#### 使用 make 和 new 创建 chan：

- `make` 分配并初始化 `hchan` 结构和缓冲区，可立即收发数据；

- `new` 仅分配零值 `hchan` 指针，**未建缓冲区**；**收发操作会永久阻塞**（`close` 会 panic）



---



### 适用场景建议

- **用 ****`make`**：创建并立即可用的 `slice`、`map`、`chan`

    ```Go
    package main
    
    import "fmt"
    
    func main() {
        // 使用 make 创建切片，len=3, cap=6
        s := make([]int, 3, 6)
        fmt.Println("slice:", s, "len:", len(s), "cap:", cap(s))
    
        // 使用 make 创建 map，初始容量为 3
        m := make(map[string]int, 3)
        m["a"] = 1
        m["b"] = 2
        fmt.Println("map:", m)
    
        // 使用 make 创建有缓冲的 chan，容量为 2
        ch := make(chan string, 2)
        ch <- "hello"
        ch <- "world"
        fmt.Println("chan:", <-ch, <-ch)
    }
    
    // 输出：
    // slice: [0 0 0] len: 3 cap: 6
    // map: map[a:1 b:2]
    // chan: hello world
    ```

- **用 ****`new`**：

    - 创建零值指针，常见于需要传递指针给函数/方法的场景

    - 与工厂函数配合，作为基础内存分配手段

    ```Go
    type T struct {
        N    int
        Data map[string]int
    }
    
    func NewT(n int) *T {
        return &T{
            N:    n,
            Data: make(map[string]int, n),
        }
    }
    ```

', 'https://vdbapmvz0i.feishu.cn/docx/CavFdrIwioCTKZxPlAucsvSgnTc', 'go_interesting', 'clack', 'make', 4, 2, '2025-08-12 12:02:16', '2025-08-12 15:02:39');
INSERT INTO miniblog.article (id, title, content, external_link, section_code, author, tags, pos, status, created_at, updated_at) VALUES (579569026913546798, '字符串（下）：字符串的常见操作', '# Go 字符串（下）：字符串的常见操作

## 字符串遍历

### **使用 for 循环遍历字节序列**

使用 **`for i := 0; i \\&lt; len\\(s\\); i\\+\\+`**：是按 **字节序列（byte）** 遍历，每次访问 `s\\[i\\]`，得到一个 `byte`。

- 纯粹的 **按字节访问**，每次访问 `s\\[i\\]`，得到一个 `byte` 类型

- 不关心 UTF\\-8 结构，只是逐字节读，速度快，但容易截断字符



```Go
s := "Hello 世界"

// 字节遍历
for i := 0; i < len(s); i++ {
    fmt.Printf("byte at %d: %x\\n", i, s[i])
}

// 输出：
// byte at 0: 48
// byte at 1: 65
// byte at 2: 6c
// byte at 3: 6c
// byte at 4: 6f
// byte at 5: 20
// byte at 6: e4
// byte at 7: b8
// byte at 8: 96
// byte at 9: e7
// byte at 10: 95
// byte at 11: 8c
```



### **使用 for range 循环变量字符序列**

使用 **`for i, r := range s`**：是按 **字符序列（rune）** 遍历，Go 会自动 **按 UTF\\-8 解码字节流**，每次给你一个完整的字符（rune）。

- 内部使用 `utf8\\.DecodeRuneInString\\(s\\[i:\\]\\)` 来 **解码下一个 UTF\\-8 编码字符**

- 自动计算当前字符占了多少字节（1\\~4）

- `i` 是当前字符在原字符串中的字节偏移量

- `r` 是当前字符的 Unicode 码点（rune）



```Go
s := "Hello 世界"

// 字符遍历
for i, r := range s {
        fmt.Printf("rune at %d: %c (U+%04X)\\n", i, r, r)
}

// 输出：
// rune at 0: H (U+0048)
// rune at 1: e (U+0065)
// rune at 2: l (U+006C)
// rune at 3: l (U+006C)
// rune at 4: o (U+006F)
// rune at 5:   (U+0020)
// rune at 6: 世 (U+4E16)
// rune at 9: 界 (U+754C)
```



---



## 字符串比较

Go 字符串类型支持各种比较关系操作符，包括 = =、\\!= 、\\&gt;=、\\&lt;=、\\&gt; 和 \\&lt;。

在字符串的比较上，Go 采用字典序的比较策略，分别从每个字符串的起始处，开始逐个字节地对两个字符串类型变量进行比较。

当两个字符串之间出现了第一个不相同的元素，比较就结束了，这两个元素的比较结果就会被做为串最终的比较结果。如果出现两个字符串长度不同的情况，长度比较小的字符串会用空元素补齐，空元素比其他非空元素都小。



---



## 字符串拼接

### **低效的字符串拼接方案： 使用 \\+ 或 \\+= 运算符**

字符串拼接最直接的方式是使用 \\+ 或 \\+= 运算符，但是，**在循环或需要拼接大量字符串片段的场景下，使用 \\+ 会非常低效，其本质原因还是字符串是不可变的。**

每次执行 result = result \\+ fragment，Go 运行时都需要：

- 分配一块新的内存，大小为 len\\(result\\) \\+ len\\(fragment\\)

- 将 result 的内容拷贝到新内存

- 将 fragment 的内容拷贝到新内存

- 让 result 指向这块新内存

- 旧 result 的内存成为垃圾，等待回收。

```Go
// 低速方式合并字符串
func strMergeLowSpeed(str ...string) string {
    fmt.Println("use low speed merge function")
    result := ""
    for _, s := range str {
        result += s
    }

    return result
}
```



### **高效字符串拼接方案：strings\\.Join\\(\\)**

Go 提供了内置包 `strings` 中的 `Join\\(\\)` 函数，它将字符串切片 `elems` 中的所有元素，用指定分隔符 `sep` 拼接成一个新字符串。

```Go
func Join(elems []string, sep string) string
```



**使用场景：**

- 已经拥有一个 **`\\[\\]string`**** 切片**，且不需要频繁追加时；

- 尤其适合生成 CSV、路径、带分隔符的输出，如：

    - `\\&\\#34;a,b,c\\&\\#34;`

    - `\\&\\#34;dir1/dir2/dir3\\&\\#34;`

    - `\\&\\#34;hello world good morning\\&\\#34;`



**strings\\.Join 的性能分析**

- **底层已做内存预分配优化**，避免了频繁扩容和数据拷贝；

- 整体性能比手动用 `\\+` 或 `\\+=` 拼接 `N` 次要好很多；

- 不如 `strings\\.Builder` 灵活，但在处理现有切片时更高效、更简洁。



```Go
// 高效拼接字符串的方式 3：strings.Join()
func strMergeWithJoin(strs []string, sep string) string {
    fmt.Println("use strings.Join() to merge strings")
    return strings.Join(strs, sep)
}
```





### **高效的字符串拼接方案：strings\\.Builder**

strings\\.Builder 类型是专门为高效构建字符串设计的。它内部维护一个可变的字节缓冲区（\\[\\]byte），在拼接过程中一直向字节缓冲区中追加数据，而最后通过 String\\(\\) 方法，将缓冲区中的数据转换为字符串进行输出。

**strings\\.Builder 的优势：**

- WriteString 方法直接将字符串的字节追加到内部缓冲区，避免创建大量临时字符串。

- 内部缓冲区会按需扩容，但扩容策略通常比 \\+ 运算符导致的频繁分配更高效。

- 可以通过 Grow 方法预先分配缓冲区大小，进一步减少扩容次数。

- 最后调用 String\\(\\) 方法时，它会返回一个指向内部缓冲区字节数据（或其副本，取决于实现细节和优化）的新字符串。

```Go
// 告诉方式合并字符串
func strMergeHighSpeed(str ...string) string {
    fmt.Println("use high speed merge function")
    // 字符串构造器
    var builder strings.Builder

    // 预分配 builder 缓冲区长度
    builder.Grow(10)

    for _, s := range str {
        builder.WriteString(s)
    }

    return builder.String()
}
```



### 三种字符串拼接方式全面对比总结

| 拼接方式 | 底层原理 | 性能 | 特点 | 适用场景 |
| --- | --- | --- | --- | --- |
| `\\+=` / `\\+` | 每次拼接都会分配新内存，复制旧字符串和新增部分，**创建临时对象多** | ❌ 最差 | - 每次 `s = s \\+ part` 都会新建内存块<br><br>- 会频繁触发内存分配和垃圾回收（GC 压力大）；<br><br>- 字符串越长，性能劣化越明显。 | 拼接 2\\~3 个短字符串 |
| `strings\\.Join\\(\\[\\]T\\)` | 底层统计总长度，**预分配内存一次性拼接**，无中间对象 | ✅ 较好 | - 一次性计算所有子串总长度；<br><br>- 预分配最终结果空间；<br><br>- 拷贝各子串到结果中，仅拷贝一次。 | - 已有切片要拼接<br><br>- 有固定分隔符的场景 |
| `strings\\.Builder` | 内部维护 `\\[\\]byte` 缓冲区，**追加操作不频繁分配内存**，支持动态增长 | ✅✅ 最优 | - 高性能拼接方式；<br><br>- 内部维护 `\\[\\]byte` 缓冲区，避免频繁创建字符串；<br><br>- 可 `Grow\\(\\)` 预分配空间，进一步提升效率。 | - 高性能需求<br><br>- 循环中不断追加内容<br><br>- 大量字符串拼接 |



---



## 字符串切分

### 使用 `strings\\.Split\\(\\)`：**按指定分隔符切分**

- 会完全切分整个字符串；

- 如果分隔符不存在，返回的就是包含原字符串的切片；

- 如果分隔符在首尾或有多个连续分隔符，也会出现空字符串：

```Go
// 声明字符串
s := "Go,Python,Java"
s2 := ",A,,B,"

// 将字符串按照 "," 进行切分，返回字符串切片
parts := strings.Split(s, ",")
parts2 := strings.Split(s2, ",")

// 输出切分后的字符串切片
fmt.Println(parts) 
fmt.Println(parts2) 

// 输出: [Go Python Java]
// 输出: ["", "A", "", "B", ""]
```



### 使用 `strings\\.SplitN\\(\\)`：**限制切分次数**

```Go
// 声明字符串
s := "Go,Python,Java,C"

// 将字符串按照 "," 进行切分，最大切分 2 份，返回字符串切片
parts := strings.SplitN(s, ",", 2)

// 输出切分后的字符串切片
fmt.Println(parts) 

// 输出: ["Go" "Python,Java,C"]
```



### 使用 strings\\.Fields\\(\\)：按空白字符切分

```Go
// 声明字符串
s := "Go   Python\\tJava\\nRust"

// 按空白字符切分
parts := strings.Fields(s)

// 输出切分后的字符串切片
fmt.Println(parts) 

// 输出: [Go Python Java Rust]
```

**注意： strings\\.Fields\\(\\) 会自动忽略多个连续空白（space、tab、newline 等），适合处理自然语言或日志行。**



### 使用 `strings\\.SplitAfter\\(\\)`：**保留分隔符**

```Go
// 声明字符串
s := "1-2-3-4"

// 将字符串按照 "-" 进行切分，保留分隔符，返回字符串切片
parts := strings.SplitAfter(s, "-")

// 输出切分后的字符串切片
fmt.Println(parts)

// 输出: ["1-" "2-" "3-" "4"]
```

**注意：分隔符会被保留在每段的尾部，常用于需要追踪原始格式的位置解析。**



---



## 获取字符串长度

### 使用 len\\(\\) 函数，获取字节长度

- `len\\(\\)` 是一个内建函数，返回 `string` 类型底层 UTF\\-8 编码后的**字节数**；

- 所以 `len\\(\\&\\#34;Hello 世界\\&\\#34;\\) == 11`：

    - `\\&\\#34;Hello\\&\\#34;` 是 5 个 ASCII 字符，各占 1 字节；

    - `\\&\\#34;世界\\&\\#34;` 各占 3 字节，共 6 字节；

    - 总计：5 \\+ 6 = 11 字节。

```Go
s := "Hello 世界"
fmt.Println(len(s)) // 输出：11
```

**注意：该函数时间复杂度为 O\\(1\\)，因为 ****`stringStruct`**** 的 ****`len`**** 字段中直接保存了字节长度。**





### 使用 utf8\\.RuneCountInString\\(string\\)，获取字符长度

- `utf8\\.RuneCountInString\\(\\)` 会遍历字符串，**对 UTF\\-8 字节流进行解码**，统计其中的 `rune`（字符）数量；

- 在 `\\&\\#34;Hello 世界\\&\\#34;` 中，ASCII 字符占 1 rune，中文字符各占 1 rune，共 7 个字符。

```Go
import "unicode/utf8"

s := "Hello 世界"
fmt.Println(utf8.RuneCountInString(s)) // 输出：7
```

**注意：该函数的时间复杂度为 O\\(n\\)，因为它必须逐字节解码。**



', 'https://vdbapmvz0i.feishu.cn/docx/FpRXdsLV2o6orUxpVHicAdyJnRg', 'go_base', 'clack', '字符串', 2, 2, '2025-08-12 14:21:00', '2025-08-12 14:22:04');
INSERT INTO miniblog.article (id, title, content, external_link, section_code, author, tags, pos, status, created_at, updated_at) VALUES (579600881696125486, 'Go 散列表（上）：Map 的实现原理与扩容机制', '# Go 散列表（上）：Map 的实现原理与扩容机制

在前文《[Go 数组与切片（上）：底层原理、性能差异与扩容机制](https://vdbapmvz0i.feishu.cn/docx/EziFdMSKEoOuSqxTg4TcD9LEnhh)》中，我们分析了 Go 中定长数组和切片的底层原理与扩容机制。数组和切片解决了 **按索引存取** 的需求，而当我们需要 **按 Key 组织和查找数据** 时，Go 提供了另一种核心集合类型 —— **Map**（底层基于散列表实现）。



本文先从散列表这种数据结构讲起，再深入到 Go Map 的实现细节：结构设计、基本操作、冲突处理与扩容策略。

---

### 从「散列表」数据结构说起

#### 散列表的本质

散列表（Hash Table）本质上是对数组的扩展：
散列表利用数组 **按下标 O\\(1\\) 访问** 的特性，通过 **散列函数（Hash Function）** 将任意 Key 转换为数组下标，从而实现高效的插入、查找与删除。

```Go
index = hash(key) % arrayLength
```

#### 散列函数（Hash Function）

散列函数的作用是将 Key 映射为整数下标。

理想散列函数应具备：

- **非负性**：`hash\\(key\\) \\&gt;= 0`

- **一致性**：`key1 == key2` ⇒ `hash\\(key1\\) == hash\\(key2\\)`

- **均匀分布**：不同 Key 计算结果尽可能分散，减少冲突



> 实际上第 3 条很难完全满足，即使是 MD5、SHA、CRC 这样的算法也无法避免不同 Key 产生相同的散列值。
> 
> 



#### 散列冲突（Hash Collision）

当两个不同的 Key 经过散列函数计算得到相同的下标时，就发生了 **散列冲突**。


常见的解决方法：

- **开放寻址法（Open Addressing）**

发生散列冲突时，重新探测下一个空闲位置（线性探测、二次探测、双重散列等）。

- **链表法（Separate Chaining）**

数组的每个槽位称为 **桶（bucket）**，每个桶挂一条链表（或更复杂的结构，如红黑树）。

发生散列冲突时，冲突的元素被插入到同一个桶的链表中。



#### 装载因子（Load Factor）

装载因子反映了散列表的“拥挤程度”：

```Plain Text
装载因子 = 元素个数 / 桶的数量
```

- 装载因子越高，冲突越多，性能下降

- 为保持 O\\(1\\) 性能，通常在装载因子超过阈值时进行扩容（rehash）



---



### Go 语言的散列表：Map 的实现原理



在 Go 语言中，Go 运行时使用一张哈希表来实现抽象的 map 类型。



#### `map` 的内存模型

```Go
// src/runtime/map.go

type hmap struct {
    count         int // 元素个数，调用 len(map) 时返回此值
    flags         uint8     // 当前 map 所处的状态
    B             uint8     // buckets 的对数 ㏒_2
    noverflow     uint16    // overflow bucket 的大约数量
    hash0         uint32    // hash 函数的种子值，计算哈希值时会传入哈希函数
    buckets       unsafe.Pointer    // 指向 buckets 数组
    oldbuckets    unsafe.Pointer    // 扩容时旧的 buckets 数组
    nevacuate     uintptr           // 扩容进度计数器，小于当前地址的 buckets 已完成迁移
    extra         *maxpextra        // 可选字段，指向 overflow buckets 的指针
}
```

- 真正用来存储键值对数据的是桶，也就是 bucket

- 当某个 bucket（比如 buckets\\[0\\]\\) 的 8 个空槽 slot）都填满了，且 map 尚未达到扩容的条件的情况下，运行时会建立 overflow bucket，将数据存放在 overflow bucket 中

- 当 map 到达扩容条件（比如 装载因子 \\&gt;= 0\\.75），会触发 map 的扩容，创建新的 buckets 存储数据，而之前的 bucktes 挂载到 oldbuckets 上，并开始逐步转移数据



**map 类型在 Go 运行时层实现的示意图：**



#### `bucket` 的内存模型



**真正用来存储键值对数据的是桶，也就是 bucket**。

每个 bucket 中存储的是 Hash 值低 bit 位数值相同的元素，**默认的元素个数为 BUCKETSIZE（值为 8）**。



从上图中我们可以看到，每个 bucket 由三部分组成，从上到下分别是 tophash 区域、key 存储区域和 value 存储区域：

```Plain Text
[bucket]
 ├── tophash[8]  // 每个槽位 1 字节，高 8 位哈希标记
 ├── keys[8]     // 每个槽位一个 key，类型连续存放
 └── values[8]   // 每个槽位一个 value，类型连续存放
```



- `bucket` 选择

当我们向 map 插入一条数据，或者是从 map 按 key 查询数据的时候，运行时都会使用哈希函数对 key 做哈希运算，并获得一个哈希值（hashcode）。

这个 hashcode 非常关键，运行时会把 hashcode“一分为二”来看待，其中低位区的值用于选定 bucket，高位区的值用于在某个 bucket 中确定 key 的位置。







- `tophash` 区域

    - 存储：哈希值的高 8 位标记，类型是 `uint8`

    - 用途：tophash 区域其实是用来快速定位 key 位置的，避免了逐个 key 进行比较这种代价较大的操作

- `key` 存储区域

    - 存储：`key` 区域存储的是 map 的 key

    - 用途：在扫描 tophash 后可能选出多个 keys**，**此时取出 `keys\\[i\\]` 做**真正的相等比较**（== 或等价函数）

- `value` 存储区域

    - 存储：`value` 区域存储的是 key 对应的 value

    - 用途：是 map 这个\\&lt;Key\\-Value\\&gt; 结构中 value 的真实存放位置



**注：Go 运行时采用了把 key 和 value 分开存储的方式，而不是采用一个 kv 接着一个 kv 的 kv 紧邻方式存储，这带来的其实是算法上的复杂性，但却减少了因内存对齐带来的内存浪费。**



#### 快速定位：两级筛选 \\+ 少量精确比较

Map 的高性能查找依赖于 **低位选桶 \\+ 高位筛槽** 的两级定位策略，其中 **tophash** 机制在快速过滤候选 Key 上起着核心作用。



假设我们要查找 `map\\[key\\]`，查找流程是：

1. **计算哈希值**

    ```Go
    hash := hashfunc(key, hmap.hash0)
    ```

2. **低位选桶：只用低 B 位定位到桶数组中的某个 bucket。**

    ```Go
    bidx := hash & (1<<B - 1)
    ```

3. **高位筛槽（tophash 过滤）**

    - 提取 `top := hash \\&gt;\\&gt; \\(64\\-8\\)`（取高 8 位）；

    - 扫描该 bucket 的 `tophash\\[0\\.\\.7\\]`；

    - 找到所有 `tophash\\[i\\] == top` 的槽位。

4. **精确比较 Key**

    - 仅对筛选出的少数槽位，取 `keys\\[i\\]` 进行 `==` 比较；

    - 匹配则返回 `values\\[i\\]`。

5. **溢出桶遍历**

    - 如果没找到且该 bucket 有 overflow，则继续步骤 3\\~4。



这种“**低位选桶 \\+ 高位筛槽**”的两级索引，通常能把需要做“真正 Key 比较”的次数压到 0\\~2 次量级，字符串/切片等昂贵比较几乎不怎么发生。



---



### Map 的扩容机制

像 Slice 一样，map 也是变成的数据集合，Go 运行时会随着 map 内数据量的增加而自动扩容内存空间。



#### 为什么会扩容容量呢？

回顾 map 的本质：

> 散列表利用数组 **按下标 O\\(1\\) 访问** 的特性，通过 **散列函数（Hash Function）** 将任意 Key 转换为数组下标，从而实现高效的插入、查找与删除。
> 
> 



但随着 map 内插入的元素越来越多，不同的 key 发生哈希碰撞的可能性也越来越大，这时 bucket 中的 8 个 cell 会随之塞满，而 map 的查找、插入、删除 key 的效率也越来越低。



所以扩容的目的就是：

- **解决“存储容量不足”的问题**
当 map 中的元素数量增加，冲突概率上升，bucket 中的 8 个槽位（cell）可能被填满。冲突多会导致查找/插入效率下降。

- **负载均衡**
扩容让 key 能更均匀地分布在 bucket 中，从而保持 O\\(1\\) 级别的平均访问性能。



#### 什么时机会发生自动扩充？

##### **条件一：装载因子（Load Factor）超过阈值**

- **装载因子公式**：

    ```Plain Text
    loadFactor = 元素总数 / bucket 数量
    ```

- **Go 源码阈值**：`loadFactor \\&gt; 6\\.5`

- **扩容策略**：桶数量翻倍（B 增加 1），容量变成原来的 2 倍。



##### **条件二：overflow bucket 数量过多**

- 即使 loadFactor 没到 6\\.5，也可能扩容：

    - 频繁插入/删除导致产生大量 overflow bucket

    - hash 冲突集中，导致很多 key 挤在 overflow bucket 里

- **扩容策略**：等量扩容（B 不变，桶数量不变），但会重新分配并整理 bucket，将数据重新分布，消除多余 overflow。



> **注：装载因子（Load Factor） 的理论极限是 8**
> 
> 
> 
> - Go 运行时规定 **每个 bucket 固定存 8 个槽位（key/value 对），**这个值是常量： const bucketCnt = 8
> 
> - 假设当前有 `N` 个 bucket，那么：最大可存元素数 = N \\* 8
> 
> - 装载因子公式：loadFactor = 元素总数 / bucket数
> 
> - 把“最大可存元素数”代入公式：最大 loadFactor = \\(N \\* 8\\) / N = 8
> 
> 
> 
> **关键点**：即使扩容增加 bucket 数量，分子和分母同时按比例增长，所以理论最大值一直是 8。
> 
> 



#### 扩容策略

##### 翻倍扩容（B 增加 1，桶数 ×2）

- **触发条件**

    - `loadFactor \\&gt; 6\\.5`

        - 意味着元素数太多，平均每个 bucket 快塞满了

        - 冲突概率高，需要 **更多的桶** 来降低负载因子

- **扩容效果**

    - 桶数翻倍（`B\\+\\+`）

    - 理论容量翻倍

    - 冲突率显著下降



##### 等量扩容（B 不变，桶数不变）

- **触发条件**

    - `overflow bucket` 过多（即使 loadFactor 没超 6\\.5）

- **触发场景**

    - 频繁插入、删除

    - hash 冲突集中

    - 元素总数不多，但溢出桶链太长

- **扩容效果**

    - 桶数量不变（`B` 不变）

    - 重新分配新的 buckets，把老数据重新 hash 分布

    - 主要目标是 **清理多余的 overflow bucket**

- **场景举例**

    - 插入和删除交替进行

    - 冲突 key 集中在少数几个 bucket 里



#### 扩容流程

Go 的 map 扩容是**渐进式搬迁（incremental rehashing）**，不会一次性搬完全部数据，而是分摊到后续的写操作中。

1. **创建新 buckets**

    - 如果是翻倍扩容，桶数变成原来的 2 倍。

    - 如果是等量扩容，桶数不变。

2. **旧桶挂到 oldbuckets**

    - hmap\\.oldbuckets = 原 buckets

    - hmap\\.buckets = 新 buckets（空）

3. **新数据直接写到新 buckets**

    - 新插入的 key/value 不再进入旧桶。

4. **搬迁老数据**

    - 每次执行插入、更新、删除时，都会触发一次“搬迁检查”。

    - **nevacuate 记录搬迁进度**：表示已经搬迁到的新桶索引。

    - 如果当前 bucket 还没搬迁，就会把它的 8 个槽位（及 overflow）整体搬到新 buckets。

5. **搬多少？**

    - 搬迁粒度是**以 bucket 为单位**（一次搬一个旧桶及其 overflow）。

    - 这样可以在高并发环境下避免一次性搬迁的巨大延迟。

', 'https://vdbapmvz0i.feishu.cn/docx/BAuydieOYoHqWexqsBMcHw3HnFb', 'go_base', 'clack', '哈希表', 4, 2, '2025-08-12 19:37:27', '2025-08-12 19:37:30');
INSERT INTO miniblog.article (id, title, content, external_link, section_code, author, tags, pos, status, created_at, updated_at) VALUES (579606132864070190, 'Go 散列表（中）：Map 基本操作、常见陷阱', '# Go 散列表（中）：Map 操作、陷阱 和 并发

在 《[Go 散列表（上）：Map 的实现原理与扩容机制](https://vdbapmvz0i.feishu.cn/docx/BAuydieOYoHqWexqsBMcHw3HnFb)》 中我们详细分析了 Go 语言散列表的实现原理和扩容机制，这一篇我们具体到 map 的使用层面上，分析分析 map 的操作、陷阱 和 并发。



### 基本操作



#### 创建 Map：make vs 字面量

##### 声明一个 map 变量：

```Go
var m map[KeyType]ValueType
```

注意：

- KeyType 必须是可比较（comparable）的类型，支持 == 和 \\!=

    - KeyType 可以是 int、string、指针、 struct（所有字段都可比较）等

    - KeyType 不能是 slice、func、map 

- ValueType 可以是任意类型



##### 使用 make 函数

make 是创建空 map 或需要动态添加元素时的常用选择。

```Go
// 创建一个空的 map
m1 := make(map[string]string)


// 创建时预估容量 (后面会讲为何重要)
m2 := make(map[string]string, 100) // 预分配大约100个元素的空间
```



##### 使用字面量（Literal）

如果创建时就知道初始内容，使用字面量创建并初始化 map 的方式更简洁。

```Go
// 创建并初始化
m3 := map[string]string{
    "red":  "#ad1337",
    "Orange": "#e95a22",
}


// 创建一个空的 map (等效于 make)
m4 := map[string]string{}
```



---

#### 核心操作



##### 增 / 改（Set）

使用赋值 m\\[key\\] = value。键存在则更新，不存在则添加。

```Go
m := make(map[string]int)
m["one"] = 1 // 增
m["one"] = 11 // 改
```



##### 删（Delete）

使用内置 delete\\(m, key\\) 函数。如果 key 不存在，该操作无效果，不会报错。

```Go
delete(m, "one")
delete(m, "not_exist") // 安全，无操作
```



##### 查（Get）

- **索引方式 value := m\\[key\\]**

    **通过索引方式，如果 key 不存在，会返回 ValueType 的零值**

    ```Go
    m := map[string]int{"a": 1, "b": 2, "c": 3}
    
    fmt.Printf("key a, value: %v \\n", m["a"]) // 输出 key a, value: 1
    fmt.Printf("key d, value: %v \\n", m["d"]) // key 不存在也不报错，输出：key d, value: 0
    ```

- **\\&\\#34;comma ok\\&\\#34; 方式**

    **使用 \\&\\#34;comma ok\\&\\#34; 方式查找 key，通过第二个参数 ok 的结果判断 key 是否存在**

    ```Go
    m := map[string]int{"a": 1, "b": 2, "c": 3}
    
    value, ok := m["a"]
    if ok {
        fmt.Println("Key \'a\' exists, value:", value)
    } else {
        fmt.Println("Key \'a\' does not exist")
    }
    ```



##### 

---



### 常见的陷阱



#### nil map 和空 map 有何区别？误用为何会导致 panic？

- **nil map 是通过只声明、未赋值的方式创建出来的**

    ```Go
    var m map[string]int
    ```

- **空 map，是通过 make 方式创建出来的**

    ```Go
    m := make(map[string]int)
    ```



**注意：**

- **nil map 的值为 nil，不能进行写操作（包括赋值和 delete），否则会 panic**

- **nil map 可以进行读操作（len、range和查找）是安全的，不会 panic**

- **空  map  的值不是\\`nil\\`，但其长度为  0，可以安全进行读写操作。**



```Go
// 声明了 map，但为初始化，此时是 nil map
var m map[int]int
// m[1] = 1 // 若直接对 nil map 进行写操作，会 panic

// 可以对 nil map 进行读操作，包括：查找、range、len
println(m[1])
for k, v := range m {
    _ = k
    _ = v
}
println(len(m)) // 0



// 空 map (`make(map[K]V)` 或 `map[K]V{}`)
// 空  map  的值不是`nil`，但其长度为  0，可以安全进行读写操作。

// 通过 make 创建 空 map
var m = make(map[int]int)

// 安全，可以对空 map 进行写操作
m[1] = 1    

// 安全，对空 map 写入值后，继续进行读操作
println(m[1]) // 1
for k, v := range m {
    _ = k
    _ = v
}
println(len(m)) //1 
```



#### 为什么不能直接获取 map 中元素的地址？修改 map 中的结构体字段为何会报错？

map 的元素是不可寻址的（not addressable），这意味着我们不能直接获取 map 元素的地址，也不能直接修改 map 元素的值（如果 value 是结构体类型）。

```Go
m := map[string]int{"a": 1}
// p := &m["a"] // 编译错误: cannot take address of m["a"]


type Point struct{ X, Y int }
points := map[string]Point{"origin": {0, 0}}
// points["origin"].X = 10 // 编译错误: cannot assign to struct field points["origin"].X in map
```



**这是因为 map 在扩容（rehash）时，内部元素的位置可能会改变。如果允许获取元素地址，那么扩容后这个地址就会失效，变成悬空指针，非常危险。Go 语言从设计上禁止了这种操作。**



那么如何修改 map 中结构体的值呢？ 有两种常见的方案：

- 取出副本 \\-\\&gt; 修改副本 \\-\\&gt; 存回 map

    ```Go
    // 取出的是 Point 值的副本
    p := points["origin"] 
    
    // 修改副本
    p.X = 10             
    
    // 将修改后的副本存回 map
    points["origin"] = p   
    ```

- 让 Value 成为指针类型

    ```Go
    pointsPtr := map[string]*Point{"origin": {0, 0}} // 值是指针 *Point
    pointsPtr["origin"].X = 10                      // 合法！修改指针指向的 Point 结构体
    ```





#### 不能使用 `==` 做 map 之间的比较

map 类型本身是不可比较的（除了与 nil 比较），这是因为 map 的内部实现中包含了指针，而指针的比较是基于指针地址的。即使两个 map 的键值对完全相同，它们的指针也可能不同。此外，浮点数作为值时，比较也存在精度问题。

```Go
m1 := map[string]int{"a": 1}
m2 := map[string]int{"a": 1}
// fmt.Println(m1 == m2) // 编译错误: invalid operation: m1 == m2 (map can only be compared to nil)
```



**那如何判断两个 map 是否逻辑相等呢？**

我们可以自定义函数来遍历比较每个键值对，比如下面的 mapEqual 函数：

```Go
func mapEqual(m1, m2 map[string]int) bool {
    if len(m1) != len(m2) { // 检查两个map的键值对数量是否相等
        return false
    }
    for k, v1 := range m1 {
        if v2, ok := m2[k]; !ok || v1 != v2 { // 检查 key 存在性和 value 相等性
            return false
        }
    }
    return true
}
```



#### map 的遍历顺序是随机的

Go 支持使用 for range 遍历 map，**但是 map 的遍历顺序是随机的！**

每次运行 for range，你得到的键值对顺序可能都不同。这是 Go 团队故意设计的，目的是防止开发者依赖任何隐式的迭代顺序。

```Go
m := map[string]int{"a": 1, "b": 2, "c": 3}

for key, value := range m {
    fmt.Println(key, ":", value)
}
```



如果需要按特定顺序（如按键排序）遍历，标准做法是：

- 提取所有键到一个切片

- 对切片进行排序

- 遍历排序后的切片，用键从 map 中取值

```Go
import "sort"
// ... (m 定义同上)
keys := make([]string, 0, len(m))
for k := range m {
    keys = append(keys, k)
}
sort.Strings(keys) // 排序 keys


for _, k := range keys {
    fmt.Println(k, ":", m[k]) // 按 key 排序输出
}
```



', 'https://vdbapmvz0i.feishu.cn/docx/ICt5dcXSFoKSXZxcoxOcfCUtnoh', 'go_base', 'clack', '哈希表', 5, 2, '2025-08-12 20:29:37', '2025-08-12 20:32:15');
INSERT INTO miniblog.article (id, title, content, external_link, section_code, author, tags, pos, status, created_at, updated_at) VALUES (579706979635704366, 'Go 散列表（下）：Map 与 线程安全', '# Go 散列表（下）：Map 与 线程安全

在使用 Go 的散列表时，有一个十分重要的内容： 在并发环境下使用 map！



我们常遇到如下问题：

- map 是线程安全的吗？如何实现线程安全的 map？

- 多个线程读写 map 会怎样？会导致程序崩溃吗？

- 如何安全地在 goroutine 间共享 map？

- map 手动加锁 和 Sync\\.map 有什么区别？

---



### 谈谈线程安全

**线程安全（thread\\-safe）指：在并发环境下（任意交错的执行时序），一个组件/函数/数据结构在不需要调用方额外同步**的前提下，仍能**符合其规范**地工作。这里的“符合”，既包括**结果正确性**，也包括**内存可见性**与（若声明）**操作原子性**。



#### 判定标准（三板斧）

- **正确性（Safety/不变式）**
 并发下不变式永远成立（余额不为负、条目不重、索引不越界）。不是“只要不宕机就行”。

- **原子性/线性化（若宣称则必须做到）**

    - 单个操作看起来“一次完成”。

    - 注意“复合操作”通常**不自动原子**（先读后写、两个结构间转移），需要额外同步或提供事务式 API。

- **可见性（happens\\-before）**

    - 写入对并发读者可见；通过**锁/原子/通道**建立内存同步边界。



---



### Map 是线程安全的吗？

**Go 的原生 map 类型不是并发安全的！**这意味着：

- 多个 goroutine 同时读一个 map 是安全的

- 只要有一个 goroutine 在写（增、删、改），同时有其他 goroutine 在读或写，就极有可能导致 panic 或数据损坏



---



### 那如何在并发环境中使用 map？



#### 使用 sync\\.Mutex（互斥锁）

这是最简单直接的方式。在每次访问（读或写）map 前加锁，访问结束后解锁。保证同一时间只有一个 goroutine 能操作 map。

不过这个方案的缺点是锁的粒度太大，即使是读操作也要竞争锁，性能在读多写少场景下不高。

```Go
import "sync"


type SafeMap struct {
    mu sync.Mutex
    m  map[string]int
}


func NewSafeMap() *SafeMap {
    return &SafeMap{m: make(map[string]int)}
}


func (sm *SafeMap) Set(key string, value int) {
    sm.mu.Lock()
    defer sm.mu.Unlock()
    sm.m[key] = value
}


func (sm *SafeMap) Get(key string) (int, bool) {
    sm.mu.Lock()
    defer sm.mu.Unlock()
    val, ok := sm.m[key]
    return val, ok
}
```



#### 使用 sync\\.RWMutex（读写锁）

允许多个读操作并发进行，但写操作需要独占。适用于读多写少的场景。

该方案提高了读操作的并发性，但不足也有，那就是实现比使用 Mutex 略复杂，写操作仍然是阻塞的。

```Go
type SafeMap struct {
    sync.RWMutex
    m map[string]int
}


func (sm *SafeMap) Set(key string, value int) {
    sm.Lock() // 写锁
    defer sm.Unlock()
    sm.m[key] = value
}


func (sm *SafeMap) Get(key string) (int, bool) {
    sm.RLock() // 读锁
    defer sm.RUnlock()
    value, ok := sm.m[key]
    return value, ok
}
```



#### 使用 sync\\.Map \\(Go 1\\.9\\+\\)

Go 1\\.9 标准库提供了内置并发安全的 map，可以安全地被多个 goroutine 并发使用，无需额外的加锁或协调。

```Go
import "sync"


var sm sync.Map // 直接声明即可使用


// 存储
sm.Store("key1", 100)


// 读取
if value, ok := sm.Load("key1"); ok {
    fmt.Println("Loaded value:", value.(int)) // 注意类型断言
}


// 读取或存储 (如果key不存在则存储并返回新值)
actual, loaded := sm.LoadOrStore("key2", 200)
fmt.Println("LoadOrStore:", actual.(int), "Loaded?", loaded)


// 删除
sm.Delete("key1")


// 遍历 (注意 Range 的函数签名)
sm.Range(func(key, value interface{}) bool {
    fmt.Println("Range:", key.(string), value.(int))
    return true // 返回 true 继续遍历, false 停止
})
```



#### Actor/所有权（串行化）

单 goroutine 独占 map，其他 goroutine 通过 channel 发请求。**从根上消灭数据竞争**，换取一点延迟。

```Go
type req[K comparable, V any] struct{ op byte; k K; v V; ret chan V; ok chan bool }
```

', 'https://vdbapmvz0i.feishu.cn/docx/Xg1udfThZoDWDMxyV3PcPrYan9c', 'go_base', 'clack', '哈希表', 6, 2, '2025-08-13 13:11:26', '2025-08-13 13:11:29');
INSERT INTO miniblog.article (id, title, content, external_link, section_code, author, tags, pos, status, created_at, updated_at) VALUES (580902458532835886, 'Go 并发（上）：进程、线程、协程', '# Go 并发（上）：进程、线程、协程

我们说 Go 语言是站在巨人（C 语言）肩膀上生长起来的新一代的编程语言，而 Go 语言原始的支持并发，便是 Go 语言的一大特性。



Go 语言设计者敏锐地把握住 CPU 向多核方向发展，所以在设计 Go 语言之初便将面向多核、原生支持并发作为了 Go 语言的设计目标之一，面向并发也成了 Go 的设计哲学之一。



这一篇开始我们进入 Go 语言的并发编程，从进程与线程、并发与并行开始理解并发编程，再详细地聊一聊 Go 语言在并发编程上的设计与实现。



---

## 进程与线程

### 硬件基础：CPU

在计算机中，中央处理器（CPU）是完成计算、执行指令的核心。CPU 会按照程序中指定的执行路径完成所有的算术和逻辑运算。此外还会根据程序的需要从内存中获取指令和数据。 





在计算机中，存在 CPU 的**计算资源稀缺性**的**，**例如：

- **CPU 核心数有限**：一颗 8 核 16 线程的 CPU，同一时刻物理上最多能执行 16 个线程，但操作系统中可能有数千个线程在等待调度

- **CPU 时钟频率有限**：单核的算力由频率 \\+ IPC（每周期指令数）决定，但频率受功耗和工艺限制（摩尔定律放缓，主频基本停在 3\\-5GHz），再想提速，只能靠增加核心、优化指令并行，但也不可能无限增加；

- **指令流水线有限**：CPU 内部虽然有流水线、乱序执行、分支预测，但能并行的指令条数是有限的。



在 CPU 运行过程中，宏观上可以分为两个场景：算数/逻辑运算、数据 I/O。而 CPU 的运算速度又远远超过 I/O 速度，程序在等待** I/O **时常常**造成 CPU 空转，**这就造成了**计算资源的浪费。**



**为了最大化利用 CPU 的计算资源**，操作系统抽象出**进程和线程的概念，**并通过**调度机制**，实现让多个任务在有限的 CPU 核心上**“**看起来同时运行**”**的效果。



### 操作系统抽象：进程与线程



类似浏览器这样的程序在操作系统上运行时，操作系统会提供一种假象，好像系统上只有这个程序在运行，这个程序好像独占的使用处理器、主存、I/O 设备，处理器看上去好像一条一条地、不间断地执行这个程序的指令。这些假象就是通过“进程”这个概念实现的。

**进程（Process）**

- **定义**：**程序运行的实例，拥有独立的虚拟地址空间**。

- **职责**：**充当应用运行的容器**，提供内存、文件句柄、网络端口等资源。

- **特点：**

    - 每个进程拥有独立的内存空间（用户空间 \\+ 内核空间映射）

    - 每个进程拥有独立的 PCB（进程控制块），存储 PID、寄存器上下文、运行状态等。





尽管我们认为一个进程只有单一的控制流，但在现代操作系统中，一个进程实际上是由多个被称为“线程”的执行单元所组成。每个线程都运行在进程的上下文中，并共享同样的代码和全局数据。

**线程（Thread）**

- **定义**：**进程内的一个执行流，是被 CPU 调度的基本单位**。

- **职责**：负责在 CPU 上运行指令序列。

- **特点：**

    - 同一进程的多个线程共享内存、文件句柄、堆；

    - 每个线程拥有自己的 TID、栈、程序计数器（PC）、寄存器上下文。



**总的来说，进程是资源分配的最小单位，线程是CPU 调度的最小单位。**



如下图所示：进程中维护了应用程序运行时的内存地址空间、文件和设备句柄，以及多个线程，操作系统的调度器决定哪个线程会获得给定的 CPU 运行时间：





### **线程的上下文切换：**



在计算机中 CPU 的内核资源是有限的，而线程数通常更多，为了平衡每个线程能够被 CPU 处理的时间，并最大化利用 CPU 资源，操作系统需要在适当的时间通过定时器中断（Timer Interrupt）正在 CPU 上运行的线程，执行上下文切换（Context Switch）。



**发生线程上下文切换时，**需要保存线程中的寄存器、线程栈指针、线程状态等信息；而若是发生跨进程的线程切换，还需要进行虚拟内存地址空间的切换。



**切换方式的不同造成了切换成本差异：同一进程中的线程上下文切换，**保存/恢复寄存器、PC，开销相对小；**不同进程的上下文切换，**除了寄存器，还要切换内存空间，导致 **TLB 缓存失效**，成本高。







---



## 并发\\&amp;并行



在 Go 语言的程序设计中，有两个非常重要但容易被误解的概念，那便是并发与并行：

- 并发（Concurrency）

    - 是指在**单核 CPU** 上，通过**上下文切换**，让多个任务**在同一个时间段内**“**看起来同时执行**”；

    - **并发是逻辑上的同时执行，其本质是 CPU 中上下文切换；**

- 并行（Parallelism）：

    - 是在 **多核 CPU** 上，多个任务在物理上**真正同时执行**；

    - **并行是物理意义上的同时执行，其本质是多核 CPU。**



初学者可能会有 “并发 = 并行”误解，但其实：

- 并发并不意味着并行，操作系统可以通过上下文切换的形式，在单核 CPU 上并发的执行多个程序或任务；

- 而只有有多个物理的 CPU 核心时，才有机会让多个程序并行运行





---



## 协程：Go 语言实现的轻量级线程



### 协程的概念：

在传统的编程语言中（类似 C、C\\+\\+、Java），通常直接使用 OS 线程来实现并发编程，但 Go 语言却抽象出“协程”的概念，并由 runtime 实现了协程的调度。



首先来看一看协程的概念：

- **协程（goroutine）**被称为 Go 语言中“**轻量级线程**”，是 Go 语言的并发处理模型，**是 Go 语言并发的执行体**；

- 协程的本质，是由 **Go runtime 调度的用户级线程（User\\-level Thread, ULT）**，**是代码执行的最小逻辑单元。**


### **为什么不使用线程处理并发？**

相较于线程，协程拥有如下优势：

#### **占用资源小：**

- **线程**默认**栈空间 2MB**，数量有限（**几千到几万**）；

- **协程**初始**栈空间 2KB**，可按需**自动扩缩容**，单机可支撑**百万级**。

#### **创建和消耗成本低：**

- 线程的创建和销毁，要通过操作系统来实现，是内核级的，成本高；

- 协程由 Go 运行时进行管理，是用户级的，创建和消耗的成本很低。

#### **切换成本低：**

- **线程上下文切换由内核完成**，涉及寄存器保存 \\+ TLB 失效 \\+ 内核态切换，**成本高**；

- **协程切换由 Go runtime 自行调度，**只需保存用户态少量寄存器，**成本低**。



**总得来说，Go 语言协程（goroutine）的优势在于把 OS 线程当作“资源”，由 runtime 抽象出更轻量的调度模型，而避免了 OS 线程创建、消耗、切换成本过高的缺点。**



### **Go 程序的生命周期：主协程与子协程**



#### **程序启动，创建主协程：**

go 程序启动时，runtime 会创建 **主协程运行 main\\.main 函数。**在此期间所有**普通的函数调用，都是在主协程中顺序执行的**，且每次函数调用都需要等待函数返回值，再继续执行。



#### **Go 语句创建子协程：**

在程序中使用** go 语句**，**runtime 会创建一个新的子协程来执行当前函数**，**主协程不需要等待此函数返回，立即向下执行。**

子协程是一个独立的执行单元，而多个子协程之间的执行顺序是不可预测的，不要因子协程的创建顺序而臆测子协程的执行顺序，这是由 Go 语言调度器所决定的。



#### **主协程返回 = 进程退出**

**主协程终止后**，所有由 go 语句创建的 **子协程也会强制结束**，无论该 goroutine 上的函数是否执行完毕。





#### searcher 应用的案例：

这个程序分成多个不同步骤，在多个不同的goroutine里运行：

- 程序从主 goroutine 开始，开启搜索任务

- 创建执行搜索的 goroutine，真实的完成搜索行为

- 创建跟踪结果的goroutine，等待搜索结束后，关闭 results 通道

- 最后回到主goroutine，结束当前进程





```Go
package main

import (
    "log"
    "os"

    _ "github.com/yshujie/goinaction/searcher/matcher/sub"
)

// init 函数在 main 函数调用前执行
func init() {
    log.Println("in seatcher init")

    // 记录日志
    log.SetOutput(os.Stdout)
}

// main 函数，程序入口
func main() {
    log.Println("in searcher main")

    // 🌟 **主 goroutine 中，开启执行搜索的任务**
    Search("president")
}

// seatch 函数，执行搜索功能
func Search(seatchTerm string) {
    // 拉取数据源
    feeds, err := d.RetrieveFeeds()
    if err != nil {
        log.Fatal("retrieve feeds fail, error: ", err)
    }

    // 创建 waitGroup，设置根据 feeds 搜索进行等待
    var waitGroup sync.WaitGroup
    waitGroup.Add(len(feeds))

    // 遍历 feeds，选取对应的 matcher 进行搜索，将搜索结果存入 results 中
    results := make(chan *m.Result)
    for _, feed := range feeds {
        // 选择数据匹配器
        matcher := m.SelectMatcher(feed.Type)

        // 🌟 **启动执行搜索的子 goroutine**
        go func(matcher m.Matcher, feed *d.Feed) {
            m.Match(matcher, feed, seatchTerm, results)
            waitGroup.Done()
        }(matcher, feed)
    }

    // **🌟 启动跟踪结果的 goroutine**
    // 启动搜索等待协程，搜索结束后关闭 results 通道
    go func() {
        // 等待 waitGroup 结束
        waitGroup.Wait()

        close(results)
    }()

    // 展示查询结构
    display(results)
}

// display 展示查询结构
func display(results chan *m.Result) {
    for result := range results {
        log.Printf("%s:\\n%s\\n\\n", result.Field, result.Content)
    }
}

```







### **协程的基本使用：**

#### **启动：go 语句**

- 协程的启动非常简单，只需要在普通的函数调用前增加 go 关键字，这个函数便会在新创建的子协程上运行；

```Go
// 声明 f() 函数
func f()

// 启动子协程，执行 f() 函数
go f()
```

#### **执行：并发执行**

- 由 go 语句启动的子协程，是独立的逻辑执行单元；

- 子协程与主协程并发运行。

#### **关闭：函数 return **

- 协程关闭的本质是：函数 return，栈被回收，goroutine 结束；

- 如果需要“主动退出”，必须用 **信号机制**（如 context\\.Done\\(\\)、chan）来通知。

#### **返回值：**

- goroutine 启动函数没有直接返回值；

- 如果需要获取结果，一般用 chan 或 sync 传递。





### 协程治理三板斧（收尾与关停套路）

#### **WaitGroup**：阻塞主协程，等子协程“数清楚再走”。

- **反例：主协程运行完毕后会直接结束，不会等待任何子协程，而所有的子协程也被强行终止。**

```Go
package main
import (
    "fmt"
    "time"
)
func main() {
    fmt.Println("in main.main")

    // 启动子协程，打印数字
    go printNum(0, 10)

    // ❌ 直接返回，进程退出，worker 可能来不及输出/清理
    fmt.Println("main.main is end")
}

func printNum(start, end int) {
    if start <= end {
        return
    }

    for i := start; i <= end; i++ {
        fmt.Println("num: ", i)
        time.Sleep(200 * time.Millisecond)
    }
}
```

- **正例：使用 WaitGroup，主协程等待子协程运行接收后再终止。**

```Go
package main
import (
    "fmt"
    "time"
)
func main() {
    fmt.Println("in main.main")
    
    // 声明协程计数器
    var wg sync.WaitGroup

    // 协程计数器 +1
    wg.Add(1)

    // 启动子协程，打印数字
    go printNum(0, 10, &wg)

    // ✅ 主协程进入阻塞状态，等待子协程处理完毕
    wg.Wait()

    fmt.Println("main.main is end")
}

func printNum(start, end int, wg *sync.WaitGroup) {
    // 函数返回时，协程计数器 -1
    defer wg.Down()

    if start <= end {
        return
    }

    for i := start; i <= end; i++ {
        fmt.Println("num: ", i)
        time.Sleep(200 * time.Millisecond)
    }
}
```





#### **Context**：统一的取消/超时通道，`ctx\\.Done\\(\\)` 抢占优先级高

**要点**：

- `WithTimeout/WithCancel` 产生的 `ctx` 在取消时会关闭 `Done\\(\\)`（广播），所有监听的 goroutine 能即刻退出；

- `WaitGroup` 做最终收敛，避免主协程早退。

```Go
package main

import (
    "context"
    "fmt"
    "sync"
    "time"
)

func main() {
    ctx, cancel := context.WithTimeout(context.Background(), 1200*time.Millisecond)
    defer cancel()

    var wg sync.WaitGroup
    wg.Add(1)
    go func() {
        defer wg.Done()
        i := 0
        for {
            select {
            case <-ctx.Done():                 // ✅ 任何可能阻塞点前先看 Done
                fmt.Println("worker: stop:", ctx.Err())
                return
            default:
                time.Sleep(200 * time.Millisecond) // 业务代码
                fmt.Println("worker:", i)
                i++
            }
        }
    }()

    wg.Wait()                                  // ✅ 数人头，主协程“等一等”
    fmt.Println("main: exit")
}
```



#### **停机广播**（`close\\(stop\\)` \\+ `select`）：

- 多 sender / 多 receiver 时，**不要**随意 `close\\(dataCh\\)`，由“协调者”统一广播停机，再**等发送端退出**后再关数据通道，保证 `range` 自然收尾。

- **原则：多 sender 的通道关停，使用“停机广播”。**

- **反例：多 sender 误关 dataCh，导致 panic: send on closed channel**

```Go
package main
import (
    "fmt"
    "sync"
)
func main() {
    // 创建数据通道
    dataCh := make(chan int, 1)
    
    // 创建协程计数器
    var wg sync.WaitGroup
    
    // 两个发送者
    for id := 1; id <= 2; id++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            for v := 0; v < 2; v++ {
                if v == 1 && id == 1 {
                    close(dataCh) // ❌ 非唯一 sender 关闭数据通道 → 数据竞争 + panic
                }
                dataCh <- v // ← 可能发送到已关闭通道，panic
            }
        }(id)
    }
    
    // 一个接收者
    go func() {
        for v := range dataCh {
            fmt.Println("recv:", v)
        }
    }()
    wg.Wait()
}
```



- **正例：stop 广播 \\+ 协调者统一关闭 dataCh**

```Go
package main
import (
    "fmt"
    "sync"
    "time"
)
func main() {
    dataCh := make(chan int, 8)   // 数据通道（只允许“协调者”关闭）
    stop := make(chan struct{})   // 停机广播（只关闭，不写入）

    var wgSend, wgRecv sync.WaitGroup

    // N 个 sender：发送路径必须监听 <-stop，保证满缓冲时也能被抢占
    for id := 1; id <= 2; id++ {
        wgSend.Add(1)
        go func(id int) {
            defer wgSend.Done()
            v := 0
            for {
                select {
                case <-stop:
                    fmt.Printf("[S%d] stop\\n", id)
                    return
                case dataCh <- v:
                    v++
                    time.Sleep(50 * time.Millisecond)
                }
            }
        }(id)
    }

    // M 个 receiver：range 自然收尾
    for i := 0; i < 1; i++ {
        wgRecv.Add(1)
        go func() {
            defer wgRecv.Done()
            for v := range dataCh {
                _ = v
            }
        }()
    }

    // 协调者：稍后发出停机广播 → 等 sender 退出 → 统一 close(dataCh)
    go func() {
        time.Sleep(300 * time.Millisecond)
        close(stop)        // ✅ 广播停机
        wgSend.Wait()      // 等所有 sender 退尽
        close(dataCh)      // ✅ 统一关闭数据通道，触发 receiver 收尾
    }()

    wgRecv.Wait()
    fmt.Println("main: exit")
}
```





## 小结（工程落地要点）

- 先把“退出路径”想清楚：**主协程何时退出**、**子协程如何被取消并收尾**。

- 单 sender → “谁发送谁关闭”；多 sender → “停机广播 \\+ 协调者统一 close\\(dataCh\\)”。

- `select` 中让 `ctx\\.Done\\(\\)/stop` **可抢占**发送/接收路径，避免满缓冲时的**卡死/泄漏**。

- 以 **WaitGroup** 做最终“数人头”的收尾保障。

', 'https://vdbapmvz0i.feishu.cn/docx/QQXSdRaxWoM6oTxlbQlcJ86Ln5f', 'go_base', 'clack', '并发编程,协程,并发&并行', 7, 2, '2025-08-21 19:07:27', '2025-08-21 19:07:30');
INSERT INTO miniblog.article (id, title, content, external_link, section_code, author, tags, pos, status, created_at, updated_at) VALUES (581163679936950830, 'Go 并发（中）：协程间的通信机制', '# Go 并发（中）：协程间的通信机制

在 《[Go 并发（上）：进程、线程、协程](https://vdbapmvz0i.feishu.cn/docx/QQXSdRaxWoM6oTxlbQlcJ86Ln5f)》中，我们从宏观的并发模型切入，回答了一个核心问题：**“Go 为什么要有 goroutine？”** —— 轻量级、可大规模调度的执行体，是 Go 并发的根基。有了成千上万的 goroutine，只是并发的起点，真正的难题在于： **goroutine 之间如何协作？**



并发执行体（协程或线程）往往需要对**同一份数据**进行读写和控制，这也是并发编程中最复杂、最容易出 bug 的部分。业界的解决思路主要有两条：

- **共享内存（Shared Memory）：**多个执行体直接读写公共变量，靠锁（Lock）、条件变量（Cond）、原子操作（Atomic）来保证一致性；

- **消息传递（Message Passing）：**每个执行体维护自己的私有数据，通过“消息”交换来实现数据共享。



Java、C\\+\\+ 等传统语言大多使用“共享内存”的方式，这类方式的优点是贴近硬件模型、性能高，但缺点也十分明显：锁的粒度设计复杂、容易死锁 和 竞态、代码难以维护。



Go 语言设计者选择了另一条道路：“消息传递”，通过语言级抽象 —— **`channel`****与 ****`select`**** **组成了 Go 并发的通信机制，实现了 **CSP**（Communicating Sequential Processes）模型 在工程上的落地。



这背后正是 Go 的并发哲学：

> **不要通过共享内存来通信，而要通过通信来共享内存。**
> 
> 



---



## CSP 模型



**CSP \\-\\- 通信顺序进程（Communicating Sequential Processes）**，最早出现于计算机科学家 Tony Hoare（Quicksort 算法作者，图灵奖获得者）  在 1978 年发表的论文中。



最初，论文中提出的 CSP 版本在本质上不是一种进程演算，而是一种并发编程语言：这种编程语言定义了用于**过程（process）**间 **通信（communicatiton）**的 **输入**、**输出语句**，而 **process 需要输入驱动，并产生输出，供其他 process 消费**。



一个符合 CSP 模型的并发程序应该是一组通过输入、输出原语连接起来的 process 的集合，如下图所示：





- **process 独立性**：每个 process 都只关注输入和输出，不共享内部状态；

- **输入/输出原语：**提供同步/异步通信的能力；

- **组合性**：复杂系统 = 多个简单 process \\+ channel 组合而成。



是不是感觉很熟悉？Go 语言正是对 CSP 模型的一种工程化实现：

- **`goroutine`** 对应 CSP 中的 process；

- **`channel`** 对应 CSP 中的输入/输出原语；

- **`select`** 提供多路选择，丰富了原始 CSP 的表达力。



**换句话说：Go 语言选择了“消息传递 \\+ CSP 模型”的道路，避免了共享内存的复杂性，让并发协作的语义更加简洁和直观。**



---



## `channel` 的设计与机制



**当一些数据需要在 ****`goroutine`**** 之间共享时，在 ****`goroutine`**** 之间架起了一个管道，并提供确保同步交换数据的机制，这便是 ****`channel`**** （通道）。**



### 基本使用

#### 创建 `channel`

- **创建无缓冲通道**

    ```Go
    ch := make(chan T)
    ```

- **创建有缓冲通道**

    ```Go
    ch := make(chan T, 10)
    ```



Go 语言提供了 `make` 函数来创建 `channel`，通过创建时的参数我们可以观察到：

- **`channel`**** 拥有类型：**

    - `channel`的类型是**元素类型，****`channel`**** 类型确定后，向通道内写入的元素必须是该类型**

- **`channel`**** 拥有容量：**

    - 使用 `len\\(\\)` 获取的是 `channel` **长度**，是此时此刻通道内的元素个数，没有什么实际意义；

    - 使用 `cap\\(\\)` 获取的是 `channel` **容量**，获取的是有缓冲通道的容量大小，有实际的意义。



#### `channel` 通讯

Go 语言 提供了`\\&lt;\\-` 操作符，用于向 `channel` 内发送消息 或 接收消息。

- **发送：**

向通道发送一个值时，`\\&lt;\\-` 运算符的左侧是消息要发送进入的 `channel`，右侧是要发送的消息，如下面代码所示：

```Go
// 创建无缓冲通道 
ch := make(chan int)

// 向通道内发送消息
ch <- 10
```



- **接收：**

从通道里接收一个值时，将 `\\&lt;\\-` 运算符放置在接收消息 `channel` 通道的左侧，如下面代码所示：

```Go
// 创建 int 类型通道
ch := make(chan int)

// 接收消息
<-ch
```



在实际开发中，有如下几种接收的形式：

1. 单次接收，只接收事件、丢弃消息内容

```Go
<-ch
```

2. 单次接收，接收信息并保存，供之后使用

```Go
x := <-ch
```

3. “comma, ok”单次接收，接收信息并判断 channel 是否关闭

```Go
x, ok := <-ch
if !ok {
    fmt.Print("channel 已关闭")
}
```

4. for 循环（无限读取）

```Go
for {
    x, ok := <-ch
   // 通道关闭时退出
    if !ok {
        break
    }
    
    fmt.Println(x)
}
```

5. for range \\(持续读取，直到通道关闭\\)

```Go
for x := range ch {
    fmt.Println(x)
}
```





#### `channel` 的单向约束

我们看到在创建 `channel` 时，通道是没有方向限制的，不过在将 `channel` 作为函数参数、返回值时，可以增加通道的单项约束。



而增加单项约束的原因是：一般来说一个 `goroutine` 在大多数情况下只会读取或者写入通道，为了表达这种语义并防止通道被误用，Go语言的类型系统提供了单方向的通道类型。



- **单向写通道：****` ch chan\\&lt;\\-T`**** **

```Go
// 生产者
func producer(start, end int, out chan<-int) {
    if start > end {
        return
    }

    // 循环写入
    for i := start; i <= end; i++ {
        out <- i
    }
}
```



- **单向读通道：****`ch \\&lt;\\-chan T`**

```Go
// 消费者
func consumer(in chan<-int) {
    // 读通道内容，并打印
    for i := range in {
        fmt.Println(i)
    }
}
```



### 无缓冲 \\&amp; 有缓冲



#### **无缓冲通道**

**无缓冲通道最大的特性是****：会导致输入和接收的 goroutine 同步化，所以无缓冲通道也被称为同步通道；**



**无缓冲通道发送端和接收端必须成对匹配，才能继续运行：**

- 若先有发送端：无缓冲通道的发送端会进入阻塞状态，直至通道中的信息被接收端执行接收操作，完成值传输，两个 goroutine 都可以继续执行；

- 若先有接收端：无缓冲通道的接收端会进入阻塞状态，直至通道中有信息被发送过来，接收端 goroutine 会被唤醒。





**使用无缓冲的通道在goroutine之间同步**





**无缓冲通道使用案例：**

- [令牌传递案例：交替打印数字和字母](https://vdbapmvz0i.feishu.cn/docx/Ugu5dm2LdoyuX3xR9TPcWcT6n8f#share-PVQ2db3VbokumlxaJ02cpxgunnc)



#### **有缓冲通道**

有缓冲通道在内部维护了一个 FIFO 队列，这保证了在消息被接收前，能够存储一个或多个值。



**有缓冲通道最大的特点是：****会导致输入和接收的 goroutine 异步执行，实现发送者与接受者的解耦。**



**有缓冲的同步机制：**

- 对于发送端：队列未满即可持续放入；若队列已满，则发送端进入阻塞状态；

- 对于接收端：队列非空即可持续取出；若队列空了，则接收端进入阻塞状态。





**使用有缓冲的通道在goroutine之间同步数据**







**有缓冲通道使用案例：**

- [**单槽令牌案例：给 10 个协程，如何打印出升序的数字**](https://vdbapmvz0i.feishu.cn/docx/Ugu5dm2LdoyuX3xR9TPcWcT6n8f#share-B08wdvPhuoCeWtxkQ7dcv6vGnEc)

- [**解耦生产端和消费端案例：测量网络连接状态**](https://vdbapmvz0i.feishu.cn/docx/Ugu5dm2LdoyuX3xR9TPcWcT6n8f#share-TeIddPLOtouXUqx3hEvczZInnRb)



### 关闭通道

#### 关闭通道的语义

Go 语言提供 `close\\(\\)` 函数用于关闭通道，**调用 ****`close\\(ch\\)`**** 等于告知通道两端“没有更多数据了”。**

```Go
// 创建 int 类型通道
ch := make(chan int)

// 使用 close 函数关闭通道
close(ch)
```



#### **通道的关闭过程都发生了什么？**



在 `channel` 关闭时，Go runtime 会做三件事：

- **唤醒所有阻塞的接收者** → 读到零值 \\+ `ok=false`。

- **唤醒所有阻塞的发送者** → 直接触发 `panic`。

- **禁止后续写入/关闭** → 重复 close 或写入已关闭通道必 panic。



在 Go runtime 里，`channel` 是一个 **指针类型**，底层对应一个 `hchan` 结构体（在 `src/runtime/chan\\.go` 里定义）：



`hchan` 结构体中：

- **sendq： **存储了**阻塞的发送者队列**

- **recvq ： **存储了**阻塞的接收者队列**



当执行 `close\\(\\)` 函数关闭通道时，Go 运行时的操作是：

- 对于 **sendq**（发送者队列）：

    - 唤醒所有阻塞的发送者 ；

    - 每个发送者在自己的发送点 `panic`。

- 对于 **recvq**（接收者队列）：

    - 唤醒所有阻塞的接收者；

    - 将消息缓冲区先正常排空；

    - 随后接收零值\\+`ok=false`。



#### 通道关停时的 panic

在 Go 中，panic 的场景主要有两个：

- **重复关闭通道，会导致 panic**

    ```Go
    ch := make(chan int)
    close(ch)
    close(ch) // ❌ panic: close of closed channel
    ```

- **向已关闭的通道发送数据，会导致 panic**

    ```Go
    ch := make(chan int)
    close(ch)
    ch <- 1 // ❌ panic: send on closed channel
    ```





#### **如何优雅的关停通道呢？**

##### **关停原则：**

- **原则一：若 sender 唯一，谁发送，谁关闭 ！**

- **原则二：接收端不要直接关闭数据通道，否则可能导致其他 sender panic。**

- **原则三：若有多个 sender ，不要直接关闭数据通道，改用“关停广播”。**



##### **三种关停方式：**

我们详细分析，我们知道通道有发送端、接收端，而根据 sender 和 receiver 的个数不同，可分为如下四种情况：

| **发送者数** | **接收者数** | 推荐策略 | 关闭对象 | 说明 |
| --- | --- | --- | --- | --- |
| **1** | **1** | **方式一：发送端主动关闭** | `close\\(ch\\)` | 最直接、最安全 |
| **1** | **M** | **方式一：发送端主动关闭** | `close\\(ch\\)` | 多消费者用 `range ch` 自然退出 |
| **N** | **1** | **方式二：接收端广播退出** | `close\\(stop\\)` | 数据通道 **不**关闭；所有 sender 监听 `\\<\\-stop` |
| **N** | **M** | **方式三：第三方仲裁关停** | `close\\(stop\\)` → 等 sender 退尽 → `close\\(ch\\)` | 统一协调，常见于服务治理 |



###### **方式一：发送端主动关闭（1:1 / 1:M）**

- **适用：唯一 sender。**

- **要点**：写完数据后 `close\\(ch\\)`；所有 receiver 用 `for range` 自然收尾。

```Go
// sender（唯一）
go func() {
    defer close(ch)          // 谁发谁关
    for _, v := range src {
        ch <- v
    }
}()

// receivers（一个或多个）
for v := range ch {          // 读到尽头自动退出
    handle(v)
}
```

###### **方式二：接收端广播退出**（N:1）

- **适用：多个 sender，唯一 receiver 决定停止时机。**

- **要点：**

    - 新增 `stop` 广播通道；

    - receiver `close\\(stop\\)`；

    - sender 在发送路径 `select` 同时监听 `\\&lt;\\-stop`，**不关闭**数据通道 `ch`。

```Go
// 创建 stop 广播通道；
stop := make(chan struct{})

// senders（多个，绝不关闭 ch）
go func(id int) {
    for v := range produce() {
        select {
        case <-stop:        // 👂 **接收关停广播**
            return
        case ch <- v:
        }
    }
}(i)

// receiver（唯一，触发关停）
for v := range ch {
    if shouldStop(v) {
        close(stop)          // 📢 **发布关停广播**
        break
    }
    handle(v)
}
// 可选：快速排空缓冲
for {
    select {
    case v := <-ch:
        handle(v)
    default:
        break
    }
}

```



###### **方式三：第三方仲裁关停**（N:M）

- **适用：多个 sender \\+ 多个 receiver，需要统一协调。**

- **要点**：

    - 仲裁者（arbiter）在收到首个 `stopReq` 后 `close\\(stop\\)`；

    - 等待 sender 退出后**统一** `close\\(ch\\)`，让 receivers 用 `range ch` 自然收尾。

```Go
ch := make(chan int)              // 数据通道
stop := make(chan struct{})       // 广播：只关闭
stopReq := make(chan struct{}, 1) // 关停申请：容量1只收第一个

// senders：发送路径必须监听 stop（避免满缓冲时卡死）
go func() {
    for {
        select {
        case <-stop:    // 👂 **接收关停广播**
            return
        case ch <- v:
            v++
        }
    }
}()

// receivers：任一满足条件即可非阻塞上报一次
go func() {
    seen := 0
    for v := range ch {
        seen++
        
        // 本地关停条件
        if seen == K {            
            select { 
            case stopReq <- struct{}{}:     // 📢 **发布关停广播**
            default:     // 避免多次触发
            }
        }
        handle(v)
    }
}()

**// 👩‍⚖️ ****仲裁者**
// arbiter：收首个请求 → 广播 stop → 等 sender 退尽 → 统一关闭 ch
go func() {
    <-stopReq            // 👂 **接收第一个关停请求**
    
    close(stop)          // **📢 发布关停广播**
    
    wgSenders.Wait()    // ⌛️ **等待所有发送端退出**    
    
    close(ch)            // ✅ **统一关闭数据通道**
}()

```



---



## 多路复用：select



分析完 `channel`，我们已经知道 Go 语言通过 `goroutine` \\+ `channel` 实现了 CPS 并发模型：`goroutine` 是并发的执行体，`channel` 负责 `goroutine` 之间通信。



若一个 `goroutine` 同时处理多个消息该怎么办呢？

`select` 机制便是 Go 语言提供的解决方案：**当 ****`goroutine`**** 等待多种事件**（数据到达、可发送、超时、取消）时，用 **`select`**** 机制表达“谁先就绪我就处理”**，避免手写阻塞判断与竞态。



`select` 是面向**多通道操作**的**原子选择器：**当**一个或多个分支就绪**时，从中**随机公平**挑一个执行。



### 基本使用

### `select` 的语法

```Go
ch1 := make(chan int)
ch2 := make(chan int)
ch3 := make(chan int)

select {
case <-ch1:                // 读：ch1 可读或已关闭且读空 → 就绪
    fmt.Println("ch1 ready")

case v, ok := <-ch2:       // 读：两值接收；关闭且读空 → v 为零值，ok=false
    if !ok { fmt.Println("ch2 closed"); break }
    fmt.Println("ch2 got:", v)

case ch3 <- 1:             // 写：仅当“不会阻塞”时就绪（有接收者或缓冲未满）
    fmt.Println("sent 1 to ch3")

default:                   // 无分支就绪时的立即路径（非阻塞 select）
    fmt.Println("no cases ready")
}
```





### `select` 的特性

#### 就绪规则

- **接收分支：****`case v \\&lt;\\- ch:`**** **

    - 语义：接收 `ch` 通道内的消息，并接收具体的消息内容

    - 关注点：接收到消息的事件 和 具体的消息内容

    - **就绪规则：有元素 → 就绪，返回该元素**

- **发送分支：****`case ch \\&lt;\\- v`**

    - **语义：向 ****`ch`**** 通道内发送一条消息，是真的执行发送行为，不是监听发送事件！**

    - **关注点：关注的是发送消息这个事件**

    - **就绪规则：仅在通道不阻塞时就绪（有接受者 或 缓冲未满）**

- **控制分支 ：****`case \\&lt;\\- stop:`**

    - 语义：接收 `ch` 通道内的消息

    - 关注点：关注的是接收到消息这个事件，不关心具体的消息内容

    - **就绪规则：一旦 ****`stop`**** 被 ****`close`**** → 永远就绪（典型关停广播）。**



#### 选择策略

- **策略一**：只有一个 case 就绪 → 选择此条；

- **策略二：**有多个分支同时就绪 → **随机且尽量公平**选一条；**没有语义上的优先级；**

- **策略三：**所有分支不就绪

    - **无 ****`default`** → `select` 自身阻塞（阻塞式选择）；

    - **有 ****`default`** → 立刻走 `default`（非阻塞选择）。



#### 阻塞/非阻塞

- **阻塞式的 select**

    如果 `select` 中没有任何的通道准备好，那么当前 `select` 所在的 `goroutine` 会永远陷入等待，直到有一个case中的通道准备好为止。

    ```Go
    ch := make(chan int, 1)
    
    select {
        case <-ch:
            fmt.Println("random case 01")
        case <-ch:
            fmt.Println("random case 02")
    }
    ```



- **非阻塞式 select**

    为了避免 `select` 所在的 `goroutine` 永远阻塞的问题，有时会增加 `default` 分支。`default` 分支的作用是当所有的通道都陷入堵塞时，正常执行default分支。

    ```Go
    ch := make(chan int, 1)
    
    select {
        case <-ch:
            fmt.Println("random case 01")
        case <-ch:
            fmt.Println("random case 02")
        default:
            fmt.Println("in default")
    }
    ```

￼

#### `for \\+ select` 组合

`select` 是单次多通道选择器，很多时候，我们不希望 `select` 执行完一个分支就退出，而是循环往复执行 `select` 中的内容，因此需要将 `for`与 `select` 进行组合：**`for \\+ select`**** 组合，便是典型用于持续轮询多个事件**。



`for\\+select` 的注意事项：

- **避免空转**：若期望阻塞等待，不要写 `default`；或使用 `time\\.Sleep` / `Ticker` 限速。

- **动态启停**：用 `nil` 使某些分支临时失活，降低分支数量与复杂度。



**空转案例：**

`for \\{\\}` 是死循环，每次运行到 `select` 选择器都会直接选择 `default` 分支，程序会出现一直打印 \\&\\#34;in default\\&\\#34; 的情况。

```Go
ch := make(chan int, 1)

for {
    select {
        case <-ch:
            fmt.Println("random case 01")
        case <-ch:
            fmt.Println("random case 02")
        default:
            fmt.Println("in default")
    }
}
```



**动态启停案例：**

**核心思想：**

- **接收方向：**

    - **操作：把“当前有效输入通道”赋给一个局部变量 ****`in`****，需要暂停时令 ****`in = nil`****；**

    - **目的：****`select \\{ case v := \\&lt;\\-in: \\.\\.\\. \\}`**** 这条分支就被彻底屏蔽**（不会被选择、也不会忙等）。

- **发送方向：**

    - **操作：当“暂时没有要发的数据”时，把 ****`outCh`**** 置为 ****`nil`****；**

    - **目的：令 ****`select \\{ case outCh \\&lt;\\- pending: \\.\\.\\. \\}`**** 分支临时失活**，避免一堆 if/flag。

```Go
// go run .
package main

// 命令：暂停/恢复
type ctrlCmd int

const (
    pause ctrlCmd = iota + 1
    resume
)

func main() {
    jobs := make(chan int)
    ctrl := make(chan ctrlCmd)
    out  := make(chan string)

    // 生产一些任务
    go func() {
        defer close(jobs)
        for i := 0; i < 12; i++ {
            jobs <- i
            time.Sleep(100 * time.Millisecond)
        }
    }()

    // 工作者：演示用 nil 暂停接收、按需启用发送
    go worker(jobs, ctrl, out)

    // 动态控制：0.5s 暂停，1.1s 恢复
    go func() {
        time.Sleep(500 * time.Millisecond)
        ctrl <- pause
        time.Sleep(600 * time.Millisecond)
        ctrl <- resume
    }()

    // 汇出结果
    for s := range out {
        fmt.Println(time.Now().Format("15:04:05.000"), s)
    }
}

func worker(jobs <-chan int, ctrl <-chan ctrlCmd, out chan<- string) {
    defer close(out)

    var (
        in         <-chan int = jobs  // 有效输入（暂停时置为 nil）
        outCh     chan<- string       // 有待发送时赋值为 out，否则为 nil
        pending    string             // 待发送数据
        jobsClosed bool               // 记录 jobs 是否已经关闭
    )

    for {
        // 若没有输入可读、也没有待发送，就可以正常退出
        if jobsClosed && outCh == nil {
            return
        }

        select {
        // 动态启停：用 nil 屏蔽 in 分支
        case cmd := <-ctrl:
            switch cmd {
            case pause:
                    in = nil                // ← 暂停：接收分支失活
            case resume:
                    in = jobs               // ← 恢复：接收分支复活
            }

        // 只在 in 非 nil 时才可能走到这里
        case v, ok := <-in:
            if !ok {
                    in = nil               // 通道关闭：永远不再接收
                    jobsClosed = true
                    continue
            }
            // 模拟处理
            time.Sleep(80 * time.Millisecond)
            pending = fmt.Sprintf("processed %d", v)
            outCh = out                // ← 有数据待发：激活发送分支

        // 只有 outCh 非 nil 才能进入这里
        case outCh <- pending:
                outCh = nil                // 发完即关闭该分支，避免空转
        }
    }
}

```







## 四个工程化模板



### 超时等待（用 `time\\.NewTimer/Reset`，避免反复 `time\\.After`）

- **要解决的问题：**
等待某个事件（或从通道接收数据），需要在超时时间内给出结果；循环等待时避免 goroutine 泄漏。

- **解决方案**
使用可复用的 `time\\.Timer`：首次 `NewTimer`，循环内 `Reset` 与安全 `Stop`/排空，配合 `select`。

- **注意重点**

    - 循环内**不要反复 ****`time\\.After`**（每次都会泄漏一个定时器 goroutine）。

    - `timer\\.Stop\\(\\)` 返回 `false` 说明计时器已触发，需要**排空 ****`timer\\.C`** 再 `Reset`。

    - 超时是**次要分支**，不要吞掉真正的错误/状态。

```Go

func recvWithTimeout[T any](in <-chan T, d time.Duration) (T, bool) {
    var zero T
    timer := time.NewTimer(d)
    defer timer.Stop()

    for {
        select {
        case v, ok := <-in:
            return v, ok
        case <-timer.C:
            return zero, false // timeout
        }
    }
}

// 循环等待（可复用定时器）
func loopWait(in <-chan struct{}, period time.Duration) {
    timer := time.NewTimer(period)
    defer timer.Stop()

    for {
        select {
        case _, ok := <-in:
            if !ok { return }
            // ...处理...
            // 复用定时器
            if !timer.Stop() {
                select { case <-timer.C: default: }
            }
            timer.Reset(period)
        case <-timer.C:
            // 周期性任务 / 或者超时逻辑
            timer.Reset(period)
        }
    }
}

```



### 取消 / 关停（优先 `ctx\\.Done\\(\\)`）

- **要解决的问题**
统一、可传递的关停信号，优雅取消多个 goroutine 的工作。

- **解决方案**
以 `context\\.Context` 作为“关停广播”，在所有循环 `select` 中优先监听 `ctx\\.Done\\(\\)`。

- **注意重点**

    - **所有阻塞点**（`select`、`send`/`recv`、`time\\.Sleep` 等）都要可被 `ctx\\.Done\\(\\)` 抢占。

    - 若有需要回收的资源，**用 ****`defer`** 放在 goroutine 开头注册。

    - 上层统一创建 `ctx, cancel := context\\.WithCancel\\(\\.\\.\\.\\)` 并在收尾 `cancel\\(\\)`。

```Go
func worker(ctx context.Context, in <-chan int, out chan<- int) {
    defer close(out) // 若该 goroutine 是唯一 sender，则可在此关闭
    for {
        select {
        case <-ctx.Done():
            return
        case v, ok := <-in:
            if !ok {
                return
            }
            // ...处理...
            select {
            case <-ctx.Done():
                return
            case out <- v + 1:
            }
        }
    }
}

func startPipeline(parent context.Context) {
    ctx, cancel := context.WithCancel(parent)
    defer cancel()

    in := make(chan int)
    out := make(chan int)

    go worker(ctx, in, out)

    // ...业务逻辑...
    // cancel() 触发全链路退出
}
```



### 非阻塞收发（日志 / 遥测等可丢弃场景）

- **要解决的问题**
低价值的“最好发送一下”场景（日志、metrics、trace），**不能**阻塞主流程；通道满时丢弃而不是卡死。

- **解决方案**
用 `select` 的 `default` 分支实现**非阻塞** `send/recv`，必要时计数统计丢弃量。

- **注意重点**

    - 明确丢弃策略：计数（prom/gostats）、采样、或降级到同步输出。

    - 非阻塞只适用于**可丢**数据；关键路径严禁默默丢弃。

```Go
type Logger struct {
    ch     chan string
    dropped uint64
}

func NewLogger(buf int) *Logger {
    lg := &Logger{ch: make(chan string, buf)}
    go func() {
            for msg := range lg.ch {
                    // 实际写盘/网络 I/O
                    _ = msg
            }
    }()
    return lg
}

func (l *Logger) TryLog(msg string) {
    select {
    case l.ch <- msg: // 写入成功
    default:
            // 通道满：非阻塞丢弃
            atomic.AddUint64(&l.dropped, 1)
    }
}

func (l *Logger) DrainOnce() (string, bool) {
    select {
    case m := <-l.ch:
            return m, true
    default:
            return "", false
    }
}
```



### “发送 \\+ 关停广播”抢占满缓冲（避免卡死）

- **要解决的问题**
发送端向**可能已满**的缓冲通道发送时，如果没有接收者，常见写法会**永久阻塞**；需要能被关停信号“抢占”。

- **解决方案**
发送路径使用 `select` **同时**监听“发送”和“stop/ctx\\.Done\\(\\)”两条路：

    - 当缓冲通道满时，`select` 会阻塞；

    - 一旦 `stop` 被 `close` 或 `ctx` 取消，`select` 被**唤醒**并走停止分支，从而**抢占**阻塞。

- **注意重点**

    - 这里**不要加 ****`default`**：否则会变成“非阻塞尝试发送”，丢数据且无法等待“空间或关停”。

    - `stop` 推荐为**只关闭不写入**的“广播通道”，或直接使用 `ctx\\.Done\\(\\)`。

    - 多个 sender 时，不要关闭数据通道；结束由**广播信号**驱动。

```Go
// stop 或 ctx.Done() 作为广播信号，抢占 send 阻塞
func producer(ctx context.Context, out chan<- int) {
    v := 0
    for {
        select {
        case <-ctx.Done(): // 关停抢占，解除 send 阻塞
                return
        case out <- v:     // 若缓冲已满则阻塞在此，直到有空间或 ctx.Done()
                v++
        }
    }
}

// 典型收尾：由上层取消 + 统一关闭数据通道（若有且仅有唯一 sender）
func run() {
    ctx, cancel := context.WithCancel(context.Background())
    defer cancel()

    out := make(chan int, 1024)
    var wg sync.WaitGroup
    wg.Add(1)
    go func() {
            defer wg.Done()
            producer(ctx, out)
    }()

    // 消费一段时间
    time.AfterFunc(2*time.Second, cancel) // 模拟关停广播

    // 消费者：若有多个消费者，不要在消费者里关闭 out
    go func() {
        for v := range out {
            _ = v // 处理
        }
    }()

    // 等生产者收尾，再由“唯一 sender”关闭 out
    wg.Wait()
    close(out)
}

```



', 'https://vdbapmvz0i.feishu.cn/docx/Pv10dMUkrogwp6xkLa2cdS01ntg', 'go_base', 'clack', 'CSP,协程间通信', 8, 2, '2025-08-23 14:22:27', '2025-08-23 14:22:31');
INSERT INTO miniblog.article (id, title, content, external_link, section_code, author, tags, pos, status, created_at, updated_at) VALUES (582925797476545070, 'Go 并发（下）：Go 调度器 与 GMP 模型', '# Go 并发（下）：Go 调度器 与 GMP 模型

在前两篇里，我们从操作系统的并发原语（进程/线程）走到 Go 的轻量级线程 `goroutine`；又从协程间通信出发，理解了 CSP 模型及其在 Go 中的实现（`channel \\+ select`）。



在《[Go 并发（上）：进程、线程、协程](https://vdbapmvz0i.feishu.cn/docx/QQXSdRaxWoM6oTxlbQlcJ86Ln5f)》篇我们已经知道：为了尽量减少上下文切换带来的 CPU 消耗，我们采取将用户态与内核态相分离的设计方式：

1. 协程（用户态线程）：承担应用程序并发执行的职责；

2. OS 线程（内核线程）：承担内存空间开辟、堆栈处理等与 CPU 打交道的职责；

3. 调度器：负责将协程调度到 OS 线程上去，实现协程内任务的执行。



Go 调度器是如何调度的呢？

本篇切换到 **runtime** 视角：介绍早期的 **M:N 模型**当前的** GMP 模型**，看清**Go 调度器**如何在用户态把成千上万的`goroutine` 高效映射到少量 OS 线程上运行。



---



## 一、早期的 M:N 模型

### 概念元素：

- G：代表协程 goroutine，是并发的执行体，最小的逻辑处理单元；

- M：代表 OS 线程，是真正执运行指令、执行运行的地方；

- 全局协程队列：带锁的全局协程队列，存放待执行的协程。



### 调度流程：

- M 获取 G：先获取全局协程队列的锁，获取锁后在队列中 pop 一个协程

- M 执行 G：G 在 M 上执行

- M 归还 G：到达执行时间后，M 再次获取全局协程队列的锁，让 G 归还给队列。



### M:N 模型的缺陷：

1. 激烈的锁竞争：每个 M 创建、调度 G 时都需要获取全局队列的锁，形成了激烈的锁竞争；

2. 较差的局部性：M 创建新的 G 时只能放入全局队列中，而新的 G 并不一定在当前 M 中执行，形成了较差的局部性。





## 二、高效的 GMP 模型



**一句话总结 GMP 模型：**

**Go 语言仿照操作系统中 CPU 和 OS 线程的关系构造了一套并发处理模型，在 Go 语言层面：**

- **G 代表协程：是用户代码的最小执行体，是并发执行的核心；**

- **M 代表 OS 线程：被视为 CPU 核心的代理，真正执行机器指令；**

- **P 代表 逻辑处理器：连接 G 与 M，负责调度和本地队列，完成将 M 个 ****`goroutine`****调度到 N 个 OS 线程上并发执行的任务。**





### 概念元素：



#### **G（goroutine）**：协程

- **定义：G 代表协程 ****`goroutine`****，是 Go 语言的并发执行单元，是用户代码的最小执行体。**

- **特点：**

    - **占用内存小**：创建协程时默认只会分配 4 KB 的内存空间，并支持动态扩容；

    - **切换成本低**：协程是用户级的，由 Go 运行时进行维护，切换时成本非常低；

    - **数量非常多**：因协程占用内存非常小，所以可以创建成千上万个协程进行并行运行。

- **结构：**

    ```Go
    // G 的结构体
    type g struct {
        stack       stack       // 描述了当前 Goroutine 的栈内存范围 [stack.lo, stack.hi)
        stackguard0 uintptr     // 用于调度器抢占式调度
        
        _panic      *_panic     // 最内侧的 panic 结构体
        _defer      *_defer     // 最内侧的 defer 延迟函数结构体
        
        m           *m          // **当前 G 占用的线程，可能为空**
        sched       gobuf       //  存储 G 的调度相关的数据
        
        atomicstatus uint32     // G 的状态
        goid         int64      //  G 的 ID
        waitreason   waitReason //当状态status==Gwaiting时等待的原因
        
        preempt       bool      // 抢占信号
        preemptStop   bool      // 抢占时将状态修改成 `_Gpreempted`
        preemptShrink bool      // 在同步安全点收缩栈
        
        lockedm        muintptr   //G 被锁定只能在这个 m 上运行
        waiting        *sudog     // 这个 g 当前正在阻塞的 sudog 结构体
        ......
    }
    
    // Goroutine 调度相关的数据
    type gobuf struct { 
        sp   uintptr     // 栈指针
        pc   uintptr     // 程序计数器
        g    guintptr    // gobuf对应的Goroutine 
        // 系统调用的返回值
        ret  sys.Uintreg
        ...
    }
    ```

**要点注意：**

- **g 绑定 m：**

    - g 中记录了当前占用的 m

    - 若 g 还没有被 m 执行，m 可能为 nil

- **gobuf 记录协程调度数据**

    - 由于 `goroutine` 在执行过程中，可以被调度器抢占，放回等待队列中等待重新执行的；

    - 为了保证重新执行 `goroutine` 时可以继续执行流，所以在 g 内部保存了sp（栈指针）、pc（程序计数器） 等信息

- **g 的状态**

    - \\_Gidle：G 被创建但还未完全被初始化

    - **\\_Grunable：G 为可运行的，正在等待被运行；**

    - **\\_Grunning：G 正在被运行；**

    - **\\_Gsyscall：G 正在执行系统调用；**

    - **\\_Gwaiting：G 正在因某个原因而等待；**

    - \\_Gdead：当前 G 完成了运行





#### **M（OS thread）：操作系统线程**

- **定义：M 代表操作系统线程，被视为 CPU 核心的代理，真正执行机器指令；**

- **结构：**

    ```Go
    
    type m struct {
        **g0**            *g          // **持有调度栈的 G**
        gsignal       *g                // 处理 signal 的 g
        tls           [tlsSlots]uintptr // 线程本地存储
        mstartfn      func()      // M的起始函数，go语句携带的那个函数
        
        **curg**          *g          // **在当前线程上运行的 G**
        **p**             puintptr    // **执行 go 代码时持有的 p (如果没有执行则为 nil)**
        nextp         puintptr    // 用于暂存与当前 M 有潜在关联的 P
        oldp          puintptr    // 执行系统调用前绑定的 P
        spinning      bool        // 表示当前 M 是否正在寻找 G，在寻找过程中 M 处于自旋状态
        **lockedg**       guintptr    // **表示与当前 M 锁定的那个 G**
        .....
    }
    ```

**要点注意：**

- **关联关系：**

    - g0: 在 Go 运行时启动之初创建的，用来调度其他 G 到 M 上；

    - curg：当前正在运行的 G 的指针；

    - lockedg：表示与当前 M 锁定的那个 G，运行时系统会把 一个 M 和一个 G 锁定，一旦锁定就只能双方相互作用，不接受第三者；

    - p：指向当前与 M 关联的 P；

- **m 的状态：**

    - **自旋中\\(spinning\\)**: M 正在从运行队列获取 G, 这时候 M 会拥有一个 P；

    - **执行go代码中**: M 正在执行go代码, 这时候 M 会拥有一个 P；

    - **执行原生代码中**: M 正在执行原生代码或者阻塞的syscall, 这时M并不拥有P；

    - **休眠中**: M 发现无待运行的 G 时会进入休眠, 并添加到空闲 M 链表中, 这时 M 并不拥有 P。

    

    

#### **P（processor）**：**逻辑处理器**

- **定义：p 是逻辑处理器，是 G 与 M 之间的调度桥梁，本质是“调度权”；**

- **特点：**

    - **数量固定，等于 GOMAXPROCS 个**

    - 进程启动的时候，所有的 **processor 就会被创建处理**

    - **每个 P 都与一个 M  1:1 的进行绑定**

- **结构：**

    ```Go
    type p struct {
        id          int32
        status      uint32        // p 的状态  
        schedtick   uint32        // 调度器调用会+1
        syscalltick uint32        // 系统调用会+1
        **m**           muintptr      // **对应关联的 M**
        mcache      *mcache
        pcache      pageCache 
        // defer 结构池
        deferpool    [5][]*_defer  
        deferpoolbuf [5][32]*_defer  
        
        // **可运行的 Goroutine 队列，可无锁访问**
        runqhead uint32
        runqtail uint32
        **runq     [256]guintptr**
        
        // **缓存可立即执行的 G**
    **    runnext guintptr **
        
        // 可用的 G 列表，G 状态等于 Gdead 
        gFree struct {
            gList
            n int32
        }
        ...
    }
    ```

**要点注意：**

- **关联关系：**

    - m：每个 p 都 1:1 的关联一个 m

    - **runq：一个 256 长度的可运行 ****`goroutine`**** 队列，就是 p 的本地可执行队列**

    - **runnext：下一个可立即执行的 ****`goroutine`**

- **状态：**

    - \\_Pidle：P 没有运行用户代码或者调度器，被空闲队列或者改变其状态的结构持有，运行队列为空；

    - \\_Prunning：被线程 M 持有，并且正在执行用户代码或者调度器；

    - \\_Psyscall：没有执行用户代码，当前线程陷入系统调用；

    - \\_Pgcstop：被线程 M 持有，当前处理器由于垃圾回收被停止；

    - \\_Pdead：当前 P 已经不被使用；



#### **LRQ（local runq）：本地可执行队列**

- **定义：**每个 **`processor`** **独立拥有**本地可执行队列，存储 \\&\\#34;**\\_Grunable**\\&\\#34; **状态的 ****`goroutine`****，**在协程切换时提供给当前的 `processor` 使用；

- **特点：**

    - **局部性：**

        - 本地可执行队列是 **processor（逻辑处理器） 的私有队列；**

        - 正在运行的 G 创建新的协程 G’ 时，优先放入当前逻辑处理器的本地可执行队列；

    - **固定长度：**

        - 本地可执行队列最多可暂存 256 个 `goroutine`

    - **灵活调度：**

        - **工作窃取（work stealing）机制**

        - **阻塞分离（Hand off）机制**

        - **满载归还机制**



#### **GRQ（global runq）：全局可执行队列**

- **定义：****所有****`processor`**** 共有的全局可执行队列****，存储 \\&\\#34;\\_Grunable\\&\\#34; 状态的 ****`goroutine`****，**可将全局队列中的 `goroutine` 调配到本地可执行队列中使用。

- **特点：**

    - **全局锁：全局可执行队列是带锁的队列，每次入队、出队时都要先获取锁**



---



## 三、调度器

### 调度循环：`g0 → g → g0`

**定义：调度循环是指从调度协程 g0 开始，找到下一个要运行的协程 g，再从协程 g 切换回协程 g0 开始新一轮调度的过程**。



- g0 调度：经历了 `schedule\\(\\) \\-\\&gt; execute\\(\\) \\-\\&gt; gogo\\(\\)` 的执行过程

    - schedule函数：处理具体的调度策略，选择下一个要执行的协程；

    - execute函数：执行一些具体的状态转移、协程g与结构体m之间的绑定等操作；

    - gogo函数：与操作系统有关的函数，用于完成栈的切换及CPU寄存器的恢复；

- g 获得执行权：

    - g0 调度执行完毕后，协程 g 获得执行权，执行逻辑代码；

- g0 再次调度：

    - 当协程 g 主动让渡、被抢占或退出后，又会切换到协程 g0 进入第二轮调度。



### 调度策略（优先级/来源顺序）



我们已经知道 m 的 g0 负责具体的调度事宜，而 schedule\\(\\) 函数处理具体的调度策略。

```Go
// schedule 
func schedule() {
    ...
    var gp *g
    var inheritTime bool 
    ...
    if gp == nil { 
        // **为了公平，每调用 schedule 函数 61 次就要从全局可运行 G 队列中获取**
        if _g_.m.p.ptr().schedtick%61 == 0 && sched.runqsize > 0 {
            lock(&sched.lock)
            // 从全局队列获取1个 G
            gp = globrunqget(_g_.m.p.ptr(), 1)
            unlock(&sched.lock)
        }
    }
    
    // **从 P 本地获取 G 任务**
    if gp == nil {
        gp, inheritTime = runqget(_g_.m.p.ptr()) 
    }
    
    // 运行到这里表示从本地运行队列和全局运行队列都没有找到需要运行的 G
    if gp == nil {
        // **阻塞地查找可用 G**
        gp, inheritTime = findrunnable() // blocks until work is available
    }
    
    ...
    // 执行 G 任务函数
    execute(gp, inheritTime)
}


// 从 P 本地获取 G 任务
func runqget(_p_ *p) (gp *g, inheritTime bool) {
    // **第一优先级：获取 p.runnext 中的 goroutine**
    for {
        next := _p_.runnext
        if next == 0 {
            break
        }
        if _p_.runnext.cas(next, 0) {
            return next.ptr(), true
        }
    }

    // **第二优先级：从本地执行队列获取 goroutine**
    for {
        h := atomic.LoadAcq(&_p_.runqhead) // load-acquire, synchronize with other consumers
        t := _p_.runqtail
        if t == h {
            return nil, false
        }
        gp := _p_.runq[h%uint32(len(_p_.runq))].ptr()
        if atomic.CasRel(&_p_.runqhead, h, h+1) { // cas-release, commits consume
            return gp, false
        }
    }
}


// 从全局队列获取1个 G
func globrunqget(_p_ *p, max int32) *g {
    ...
    n := sched.runqsize/gomaxprocs + 1
    if n > sched.runqsize {
        n = sched.runqsize
    }
    if max > 0 && n > max {
        n = max
    }
    if n > int32(len(_p_.runq))/2 {
        n = int32(len(_p_.runq)) / 2
    }
    sched.runqsize -= n

    gp := sched.runq.pop()
    n--
    for ; n > 0; n-- {
        gp1 := sched.runq.pop()
        runqput(_p_, gp1, false) 
    }
    return gp
}

// 阻塞地查找可用 G
func findrunnable() (gp *g, inheritTime bool) {
    ...
    // **从本地 P 的可运行队列获取 G**
    if gp, inheritTime := runqget(_p_); gp != nil {
        return gp, inheritTime
    }

    // **从全局的可运行队列获取 G**
    if sched.runqsize != 0 {
        lock(&sched.lock)
        gp := globrunqget(_p_, 0)
        unlock(&sched.lock)
        if gp != nil {
            return gp, false
        }
    } 
    
    // **从I/O轮询器获取 G**
    if netpollinited() && atomic.Load(&netpollWaiters) > 0 && atomic.Load64(&sched.lastpoll) != 0 {
        // 尝试从netpoller获取Glist
        if list := netpoll(0); !list.empty() { // non-blocking
            gp := list.pop()
            //将其余队列放入 P 的可运行G队列
            injectglist(&list)
            casgstatus(gp, _Gwaiting, _Grunnable)
            if trace.enabled {
                traceGoUnpark(gp, 0)
            }
            return gp, false
        }
    }
    
    ...
    
    // **工作窃取**
    if !_g_.m.spinning {
        // 设置 spinning ，表示正在窃取 G
        _g_.m.spinning = true
        atomic.Xadd(&sched.nmspinning, 1)
    }
    // **开始窃取**
    for i := 0; i < 4; i++ {
        for enum := stealOrder.start(fastrand()); !enum.done(); enum.next() {
            if sched.gcwaiting != 0 {
                goto top
            }
            // 如果 i>2 表示如果其他 P 运行队列中没有 G ，将要从其他队列的 runnext 中获取
            stealRunNextG := i > 2 // first look for ready queues with more than 1 g
            // 随机获取一个 P
            p2 := allp[enum.position()]
            if _p_ == p2 {
                continue
            }
            // 从其他 P 的运行队列中获取一般的 G 到当前队列中
            if gp := runqsteal(_p_, p2, stealRunNextG); gp != nil {
                return gp, false
            }

            // 如果运行队列中没有 G，那么从 timers 中获取可执行的定时器
            if i > 2 || (i > 1 && shouldStealTimers(p2)) {
                tnow, w, ran := checkTimers(p2, now)
                now = tnow
                if w != 0 && (pollUntil == 0 || w < pollUntil) {
                    pollUntil = w
                }
                if ran {
                    if gp, inheritTime := runqget(_p_); gp != nil {
                        return gp, inheritTime
                    }
                    ranTimer = true
                }
            }
        }
    }
    if ranTimer {
        goto top
    }

stop: 
    ...
    
    // 将 p 放入 idle 空闲链表
    pidleput(_p_)
    unlock(&sched.lock)

    ...
    
    // 休眠当前 M
    stopm()
    
    goto top
}
```



#### **调度优先级**

1. 第一优先级：p\\.runnext 中存储的 G

2. 第二优先级：p 的本地可执行队列中 G

3. 第三优先级：全局可执行队列中的 G

4. 第四优先级：工作窃取，偷其他 p 的本地可执行队列



#### 全局队列批量获取机制

- **定义：当 M 对应的本地队列没有可运行的 G 时，尝试从全局队列中批量拿取一部分 G，转移到本地队列中去。**

- **批量拿取数量：**

    ```Go
    n =  min(len(GQ) / GOMAXPROCS +  1,  cap(LQ) / 2 )
    ```

    - 含义：为了避免一个 M 拿取过多的 G，要么将全局队列 G 平均分给 P 的 G 个数，或者拿 本地队列一半的 G 个数，哪个少用哪个。



**案例分析：**

1. G1 创建 G8 时，会尝试唤醒其他空闲的 M

2. G1 唤醒了 M2，M2 绑定 P2 ，而 P2 的本地队列为空，M2 进入自旋状态

3. 自旋状态的 M2 尝试从全局队列中批量拿取 G，由于 全局队列中有  4 个 G，就获取了一半





#### **work stealing：工作窃取机制**

- **定义：当 M 对应的本地可执行队列、全局可执行队列中都没有可运行的 G 时，尝试从其他 M 的本地可执行队列中偷取 G 的行为，称为工作窃取机制。**

- **目的：让 OS 线程空闲时帮助其他线程处理工作，尽量复用 OS 线程，减少 OS 线程的休眠、销毁。**

- **偷取时机：**

    - P 的本地可执行队列没有可运行的 G，且全局可执行队列也没有可运行的 G 时，开始偷取。

- **偷多少？**

    - **偷一半**：窃取其他 P 中一半的 G，放到自己的本地可执行队列中



**案例分析：**

- **全局队列已经没有G，那 m1 就要执行work stealing\\(偷取\\)：从其他有 G 的 P 那里偷取一半G过来，放到自己的P本地队列**。

- P2 从 P1 的本地队列尾部取一半的G，本例中一半是 2 个（G5，G6），放到 P2 的本地队列并执行。





#### **hand off：阻塞分离机制**

- **定义：当前线程因为 G 进行系统调用阻塞时，线程释放绑定的 P，把 P 转移给其他空闲的线程执行的行为，称为 hand off 阻塞分离机制。**

- **目的：**避免协程阻塞导致其他协程无法正常执行。

    

    **案例分析：**

    - M2 执行 G7 时，G7 发生阻塞（系统调用、channel 阻塞等）

    - 为了避免 P2 内的 G8、G9 一直无法执行，Go 调度器做了如下工作：

        - M2 与 P2 解绑

        - 唤醒 M3 （若没有休眠的 m，则会新建），将 P2 与 M3 绑定

        - M3 开始调度循环，执行 P2 中的 G

    - 当 G7 执行完成后， M2 会被放入休眠线程队列





#### **本地队列满载归还机制**

- **定义：当 M 正在运行的 G 一直创建新的 G 时，根据局部性规则新的 G 会优先存放在 P 的本地队列，而到达本地队列承载上限（256 个 G）后，调度器会批量的将本地队列中的 G 转移到 全局队列中去。**

- **目的：尽最大可能性，使用 M 并发执行 G**

    

    **案例分析：**

    - G1 创建新的 G 后，新的 G 存放到 P1 本地队列中

    - 当 P1 本地队列到达上限，G1 又继续创建新的 G7 时，调度器会将 P1 中前半段 G 打乱顺序，与新创建的 G7 一同放入全局队列。



---



### 调度时机



#### 主动调度

- 定义：协程可以选择主动让渡自己的执行权利。

- 场景：主要是通过用户在代码中执行 runtime\\.Gosched 函数实现的。

- 调度过程：

    - 从当前协程切换到协程 g0，取消 G 与 M 之间的绑定关系；

    - 将 G 放入全局运行队列；

    - 调用 schedule 函数开始新一轮的循环。





#### 被动调度

- **定义：当协程进入休眠/阻塞状态时，被动的让出执行权利。**

- **场景：**

    - 协程休眠

    - channel 通道堵塞

    - 网络I/O堵塞

    - 执行垃圾回收而暂停

- **意义：被动调度可以最大化地保证利用 CPU 的资源。**





#### 抢占调度

为了让每个协程都有执行的机会，并且最大化利用CPU资源，Go语言在初始化时会启动一个特殊的线程来执行系统监控任务。

系统监控在一个独立的 M 上运行，不用绑定逻辑处理器 P，系统监控每隔10ms会检测是否有准备就绪的网络协程，并放置到全局队列中。

和抢占调度相关的是，系统监控服务会判断当前协程是否运行时间过长，或者处于系统调用阶段，如果是，则会抢占当前 G 的执行。其核心逻辑位于runtime\\.retake函数中。









---





















', 'https://vdbapmvz0i.feishu.cn/docx/CNWPdhv0kodsRHxkZ8HcXqSBnbf', 'go_base', 'clack', 'GMP,调度器', 9, 2, '2025-09-04 18:07:31', '2025-09-04 18:07:34');
